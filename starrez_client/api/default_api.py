# coding: utf-8

"""
    StarRez API

    This is a way to connect with the StarRez API. We are not the developers of the StarRez API, we are just an organization that uses it and wanted a better way to connect to it.  # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: resdev@calpoly.edu
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from starrez_client.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def get_columns(self, table_name, **kwargs):  # noqa: E501
        """gets all of the column names and attributes of a table  # noqa: E501

        gets all of the column names and attributes of a table  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_columns(table_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_name: The name of the table you want the column info for. (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_columns_with_http_info(table_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_columns_with_http_info(table_name, **kwargs)  # noqa: E501
            return data

    def get_columns_with_http_info(self, table_name, **kwargs):  # noqa: E501
        """gets all of the column names and attributes of a table  # noqa: E501

        gets all of the column names and attributes of a table  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_columns_with_http_info(table_name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str table_name: The name of the table you want the column info for. (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['table_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_columns" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'table_name' is set
        if ('table_name' not in params or
                params['table_name'] is None):
            raise ValueError("Missing the required parameter `table_name` when calling `get_columns`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'table_name' in params:
            path_params['TableName'] = params['table_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/atom+xml'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'databaseinfo/columnlist/{TableName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tables(self, **kwargs):  # noqa: E501
        """gets all of the tables in StarRez  # noqa: E501

        gets all of the tables in StarRez  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_tables(async=True)
        >>> result = thread.get()

        :param async bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_tables_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_tables_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_tables_with_http_info(self, **kwargs):  # noqa: E501
        """gets all of the tables in StarRez  # noqa: E501

        gets all of the tables in StarRez  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_tables_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tables" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'databaseinfo/tablelist', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_address_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a AddressType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_address_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int address_type_id: ID of the AddressType you want to look up
        :return: list[AddressTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_address_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_address_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_address_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a AddressType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_address_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int address_type_id: ID of the AddressType you want to look up
        :return: list[AddressTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_address_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'address_type_id' in params:
            query_params.append(('AddressTypeID', params['address_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/AddressType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AddressTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_application_status(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ApplicationStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_application_status(async=True)
        >>> result = thread.get()

        :param async bool
        :param int application_status_id: ID of the ApplicationStatus you want to look up
        :return: list[ApplicationStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_application_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_application_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_application_status_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ApplicationStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_application_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int application_status_id: ID of the ApplicationStatus you want to look up
        :return: list[ApplicationStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_status_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_application_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'application_status_id' in params:
            query_params.append(('ApplicationStatusID', params['application_status_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ApplicationStatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ApplicationStatusItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_auto_allocate_run(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a AutoAllocateRun in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_auto_allocate_run(async=True)
        >>> result = thread.get()

        :param async bool
        :param int auto_allocate_run_id: ID of the AutoAllocateRun you want to look up
        :return: list[AutoAllocateRunItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_auto_allocate_run_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_auto_allocate_run_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_auto_allocate_run_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a AutoAllocateRun in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_auto_allocate_run_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int auto_allocate_run_id: ID of the AutoAllocateRun you want to look up
        :return: list[AutoAllocateRunItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['auto_allocate_run_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_auto_allocate_run" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'auto_allocate_run_id' in params:
            query_params.append(('AutoAllocateRunID', params['auto_allocate_run_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/AutoAllocateRun', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AutoAllocateRunItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_booking(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Booking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_booking(async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_id: ID of the Booking you want to look up
        :return: list[BookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_booking_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_booking_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_booking_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Booking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_booking_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_id: ID of the Booking you want to look up
        :return: list[BookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['booking_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_booking" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'booking_id' in params:
            query_params.append(('BookingID', params['booking_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Booking', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BookingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_booking_agreement(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a BookingAgreement in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_booking_agreement(async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_agreement_id: ID of the BookingAgreement you want to look up
        :return: list[BookingAgreementItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_booking_agreement_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_booking_agreement_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_booking_agreement_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a BookingAgreement in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_booking_agreement_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_agreement_id: ID of the BookingAgreement you want to look up
        :return: list[BookingAgreementItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['booking_agreement_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_booking_agreement" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'booking_agreement_id' in params:
            query_params.append(('BookingAgreementID', params['booking_agreement_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/BookingAgreement', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BookingAgreementItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_booking_custom_field(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a BookingCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_booking_custom_field(async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_custom_field_id: ID of the BookingCustomField you want to look up
        :return: list[BookingCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_booking_custom_field_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_booking_custom_field_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_booking_custom_field_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a BookingCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_booking_custom_field_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_custom_field_id: ID of the BookingCustomField you want to look up
        :return: list[BookingCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['booking_custom_field_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_booking_custom_field" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'booking_custom_field_id' in params:
            query_params.append(('BookingCustomFieldID', params['booking_custom_field_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/BookingCustomField', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BookingCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_booking_linked(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a BookingLinked in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_booking_linked(async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_linked_id: ID of the BookingLinked you want to look up
        :return: list[BookingLinkedItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_booking_linked_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_booking_linked_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_booking_linked_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a BookingLinked in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_booking_linked_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_linked_id: ID of the BookingLinked you want to look up
        :return: list[BookingLinkedItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['booking_linked_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_booking_linked" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'booking_linked_id' in params:
            query_params.append(('BookingLinkedID', params['booking_linked_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/BookingLinked', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BookingLinkedItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_booking_occupant(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a BookingOccupant in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_booking_occupant(async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_occupant_id: ID of the BookingOccupant you want to look up
        :return: list[BookingOccupantItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_booking_occupant_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_booking_occupant_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_booking_occupant_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a BookingOccupant in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_booking_occupant_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_occupant_id: ID of the BookingOccupant you want to look up
        :return: list[BookingOccupantItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['booking_occupant_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_booking_occupant" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'booking_occupant_id' in params:
            query_params.append(('BookingOccupantID', params['booking_occupant_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/BookingOccupant', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BookingOccupantItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_booking_reason(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a BookingReason in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_booking_reason(async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_reason_id: ID of the BookingReason you want to look up
        :return: list[BookingReasonItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_booking_reason_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_booking_reason_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_booking_reason_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a BookingReason in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_booking_reason_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_reason_id: ID of the BookingReason you want to look up
        :return: list[BookingReasonItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['booking_reason_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_booking_reason" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'booking_reason_id' in params:
            query_params.append(('BookingReasonID', params['booking_reason_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/BookingReason', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BookingReasonItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_booking_tag(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a BookingTag in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_booking_tag(async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_tag_id: ID of the BookingTag you want to look up
        :return: list[BookingTagItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_booking_tag_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_booking_tag_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_booking_tag_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a BookingTag in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_booking_tag_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_tag_id: ID of the BookingTag you want to look up
        :return: list[BookingTagItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['booking_tag_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_booking_tag" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'booking_tag_id' in params:
            query_params.append(('BookingTagID', params['booking_tag_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/BookingTag', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BookingTagItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_booking_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a BookingType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_booking_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_type_id: ID of the BookingType you want to look up
        :return: list[BookingTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_booking_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_booking_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_booking_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a BookingType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_booking_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_type_id: ID of the BookingType you want to look up
        :return: list[BookingTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['booking_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_booking_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'booking_type_id' in params:
            query_params.append(('BookingTypeID', params['booking_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/BookingType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BookingTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_calendar(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Calendar in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_calendar(async=True)
        >>> result = thread.get()

        :param async bool
        :param int calendar_id: ID of the Calendar you want to look up
        :return: list[CalendarItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_calendar_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_calendar_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_calendar_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Calendar in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_calendar_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int calendar_id: ID of the Calendar you want to look up
        :return: list[CalendarItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['calendar_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_calendar" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'calendar_id' in params:
            query_params.append(('CalendarID', params['calendar_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Calendar', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CalendarItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_category(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Category in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_category(async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_id: ID of the Category you want to look up
        :return: list[CategoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_category_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_category_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_category_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Category in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_category_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_id: ID of the Category you want to look up
        :return: list[CategoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_category" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'category_id' in params:
            query_params.append(('CategoryID', params['category_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Category', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CategoryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_category_custom_field(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CategoryCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_category_custom_field(async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_custom_field_id: ID of the CategoryCustomField you want to look up
        :return: list[CategoryCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_category_custom_field_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_category_custom_field_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_category_custom_field_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CategoryCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_category_custom_field_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_custom_field_id: ID of the CategoryCustomField you want to look up
        :return: list[CategoryCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category_custom_field_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_category_custom_field" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'category_custom_field_id' in params:
            query_params.append(('CategoryCustomFieldID', params['category_custom_field_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/CategoryCustomField', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CategoryCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_category_level(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CategoryLevel in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_category_level(async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_level_id: ID of the CategoryLevel you want to look up
        :return: list[CategoryLevelItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_category_level_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_category_level_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_category_level_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CategoryLevel in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_category_level_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_level_id: ID of the CategoryLevel you want to look up
        :return: list[CategoryLevelItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category_level_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_category_level" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'category_level_id' in params:
            query_params.append(('CategoryLevelID', params['category_level_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/CategoryLevel', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CategoryLevelItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_category_permission(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CategoryPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_category_permission(async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_permission_id: ID of the CategoryPermission you want to look up
        :return: list[CategoryPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_category_permission_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_category_permission_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_category_permission_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CategoryPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_category_permission_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_permission_id: ID of the CategoryPermission you want to look up
        :return: list[CategoryPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category_permission_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_category_permission" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'category_permission_id' in params:
            query_params.append(('CategoryPermissionID', params['category_permission_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/CategoryPermission', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CategoryPermissionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_category_schedule_transaction(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CategoryScheduleTransaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_category_schedule_transaction(async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_schedule_transaction_id: ID of the CategoryScheduleTransaction you want to look up
        :return: list[CategoryScheduleTransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_category_schedule_transaction_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_category_schedule_transaction_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_category_schedule_transaction_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CategoryScheduleTransaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_category_schedule_transaction_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_schedule_transaction_id: ID of the CategoryScheduleTransaction you want to look up
        :return: list[CategoryScheduleTransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category_schedule_transaction_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_category_schedule_transaction" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'category_schedule_transaction_id' in params:
            query_params.append(('CategoryScheduleTransactionID', params['category_schedule_transaction_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/CategoryScheduleTransaction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CategoryScheduleTransactionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_catering(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Catering in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_catering(async=True)
        >>> result = thread.get()

        :param async bool
        :param int catering_id: ID of the Catering you want to look up
        :return: list[CateringItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_catering_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_catering_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_catering_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Catering in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_catering_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int catering_id: ID of the Catering you want to look up
        :return: list[CateringItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catering_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_catering" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'catering_id' in params:
            query_params.append(('CateringID', params['catering_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Catering', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CateringItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_catering_item(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CateringItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_catering_item(async=True)
        >>> result = thread.get()

        :param async bool
        :param int catering_item_id: ID of the CateringItem you want to look up
        :return: list[CateringItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_catering_item_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_catering_item_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_catering_item_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CateringItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_catering_item_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int catering_item_id: ID of the CateringItem you want to look up
        :return: list[CateringItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catering_item_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_catering_item" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'catering_item_id' in params:
            query_params.append(('CateringItemID', params['catering_item_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/CateringItem', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CateringItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_catering_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CateringType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_catering_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int catering_type_id: ID of the CateringType you want to look up
        :return: list[CateringTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_catering_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_catering_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_catering_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CateringType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_catering_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int catering_type_id: ID of the CateringType you want to look up
        :return: list[CateringTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catering_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_catering_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'catering_type_id' in params:
            query_params.append(('CateringTypeID', params['catering_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/CateringType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CateringTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_charge_group(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ChargeGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_charge_group(async=True)
        >>> result = thread.get()

        :param async bool
        :param int charge_group_id: ID of the ChargeGroup you want to look up
        :return: list[ChargeGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_charge_group_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_charge_group_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_charge_group_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ChargeGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_charge_group_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int charge_group_id: ID of the ChargeGroup you want to look up
        :return: list[ChargeGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['charge_group_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_charge_group" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'charge_group_id' in params:
            query_params.append(('ChargeGroupID', params['charge_group_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ChargeGroup', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ChargeGroupItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_charge_item(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ChargeItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_charge_item(async=True)
        >>> result = thread.get()

        :param async bool
        :param int charge_item_id: ID of the ChargeItem you want to look up
        :return: list[ChargeItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_charge_item_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_charge_item_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_charge_item_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ChargeItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_charge_item_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int charge_item_id: ID of the ChargeItem you want to look up
        :return: list[ChargeItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['charge_item_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_charge_item" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'charge_item_id' in params:
            query_params.append(('ChargeItemID', params['charge_item_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ChargeItem', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ChargeItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_classification(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Classification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_classification(async=True)
        >>> result = thread.get()

        :param async bool
        :param int classification_id: ID of the Classification you want to look up
        :return: list[ClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_classification_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_classification_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_classification_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Classification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_classification_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int classification_id: ID of the Classification you want to look up
        :return: list[ClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['classification_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_classification" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'classification_id' in params:
            query_params.append(('ClassificationID', params['classification_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Classification', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ClassificationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_concern(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Concern in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_concern(async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_id: ID of the Concern you want to look up
        :return: list[ConcernItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_concern_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_concern_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_concern_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Concern in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_concern_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_id: ID of the Concern you want to look up
        :return: list[ConcernItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concern_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_concern" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'concern_id' in params:
            query_params.append(('ConcernID', params['concern_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Concern', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ConcernItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_concern_custom_field(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ConcernCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_concern_custom_field(async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_custom_field_id: ID of the ConcernCustomField you want to look up
        :return: list[ConcernCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_concern_custom_field_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_concern_custom_field_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_concern_custom_field_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ConcernCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_concern_custom_field_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_custom_field_id: ID of the ConcernCustomField you want to look up
        :return: list[ConcernCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concern_custom_field_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_concern_custom_field" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'concern_custom_field_id' in params:
            query_params.append(('ConcernCustomFieldID', params['concern_custom_field_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ConcernCustomField', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ConcernCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_concern_entry(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ConcernEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_concern_entry(async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_entry_id: ID of the ConcernEntry you want to look up
        :return: list[ConcernEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_concern_entry_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_concern_entry_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_concern_entry_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ConcernEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_concern_entry_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_entry_id: ID of the ConcernEntry you want to look up
        :return: list[ConcernEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concern_entry_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_concern_entry" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'concern_entry_id' in params:
            query_params.append(('ConcernEntryID', params['concern_entry_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ConcernEntry', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ConcernEntryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_concern_note(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ConcernNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_concern_note(async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_note_id: ID of the ConcernNote you want to look up
        :return: list[ConcernNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_concern_note_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_concern_note_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_concern_note_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ConcernNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_concern_note_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_note_id: ID of the ConcernNote you want to look up
        :return: list[ConcernNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concern_note_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_concern_note" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'concern_note_id' in params:
            query_params.append(('ConcernNoteID', params['concern_note_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ConcernNote', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ConcernNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_concern_sub_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ConcernSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_concern_sub_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_sub_type_id: ID of the ConcernSubType you want to look up
        :return: list[ConcernSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_concern_sub_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_concern_sub_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_concern_sub_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ConcernSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_concern_sub_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_sub_type_id: ID of the ConcernSubType you want to look up
        :return: list[ConcernSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concern_sub_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_concern_sub_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'concern_sub_type_id' in params:
            query_params.append(('ConcernSubTypeID', params['concern_sub_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ConcernSubType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ConcernSubTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_concern_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ConcernType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_concern_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_type_id: ID of the ConcernType you want to look up
        :return: list[ConcernTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_concern_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_concern_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_concern_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ConcernType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_concern_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_type_id: ID of the ConcernType you want to look up
        :return: list[ConcernTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concern_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_concern_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'concern_type_id' in params:
            query_params.append(('ConcernTypeID', params['concern_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ConcernType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ConcernTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_contact(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Contact in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contact(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contact_id: ID of the Contact you want to look up
        :return: list[ContactItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_contact_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_contact_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_contact_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Contact in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contact_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contact_id: ID of the Contact you want to look up
        :return: list[ContactItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_contact" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'contact_id' in params:
            query_params.append(('ContactID', params['contact_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Contact', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContactItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_contact_custom_field(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ContactCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contact_custom_field(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contact_custom_field_id: ID of the ContactCustomField you want to look up
        :return: list[ContactCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_contact_custom_field_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_contact_custom_field_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_contact_custom_field_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ContactCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contact_custom_field_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contact_custom_field_id: ID of the ContactCustomField you want to look up
        :return: list[ContactCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_custom_field_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_contact_custom_field" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'contact_custom_field_id' in params:
            query_params.append(('ContactCustomFieldID', params['contact_custom_field_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ContactCustomField', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContactCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_contact_note(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ContactNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contact_note(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contact_note_id: ID of the ContactNote you want to look up
        :return: list[ContactNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_contact_note_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_contact_note_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_contact_note_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ContactNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contact_note_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contact_note_id: ID of the ContactNote you want to look up
        :return: list[ContactNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_note_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_contact_note" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'contact_note_id' in params:
            query_params.append(('ContactNoteID', params['contact_note_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ContactNote', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContactNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_contact_status(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ContactStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contact_status(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contact_status_id: ID of the ContactStatus you want to look up
        :return: list[ContactStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_contact_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_contact_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_contact_status_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ContactStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contact_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contact_status_id: ID of the ContactStatus you want to look up
        :return: list[ContactStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_status_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_contact_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'contact_status_id' in params:
            query_params.append(('ContactStatusID', params['contact_status_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ContactStatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContactStatusItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_contribution(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Contribution in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contribution(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_id: ID of the Contribution you want to look up
        :return: list[ContributionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_contribution_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_contribution_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_contribution_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Contribution in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contribution_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_id: ID of the Contribution you want to look up
        :return: list[ContributionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contribution_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_contribution" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'contribution_id' in params:
            query_params.append(('ContributionID', params['contribution_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Contribution', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContributionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_contribution_custom_field(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ContributionCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contribution_custom_field(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_custom_field_id: ID of the ContributionCustomField you want to look up
        :return: list[ContributionCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_contribution_custom_field_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_contribution_custom_field_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_contribution_custom_field_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ContributionCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contribution_custom_field_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_custom_field_id: ID of the ContributionCustomField you want to look up
        :return: list[ContributionCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contribution_custom_field_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_contribution_custom_field" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'contribution_custom_field_id' in params:
            query_params.append(('ContributionCustomFieldID', params['contribution_custom_field_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ContributionCustomField', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContributionCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_contribution_entry(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ContributionEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contribution_entry(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_entry_id: ID of the ContributionEntry you want to look up
        :return: list[ContributionEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_contribution_entry_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_contribution_entry_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_contribution_entry_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ContributionEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contribution_entry_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_entry_id: ID of the ContributionEntry you want to look up
        :return: list[ContributionEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contribution_entry_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_contribution_entry" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'contribution_entry_id' in params:
            query_params.append(('ContributionEntryID', params['contribution_entry_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ContributionEntry', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContributionEntryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_contribution_note(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ContributionNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contribution_note(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_note_id: ID of the ContributionNote you want to look up
        :return: list[ContributionNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_contribution_note_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_contribution_note_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_contribution_note_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ContributionNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contribution_note_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_note_id: ID of the ContributionNote you want to look up
        :return: list[ContributionNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contribution_note_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_contribution_note" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'contribution_note_id' in params:
            query_params.append(('ContributionNoteID', params['contribution_note_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ContributionNote', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContributionNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_contribution_sub_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ContributionSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contribution_sub_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_sub_type_id: ID of the ContributionSubType you want to look up
        :return: list[ContributionSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_contribution_sub_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_contribution_sub_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_contribution_sub_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ContributionSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contribution_sub_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_sub_type_id: ID of the ContributionSubType you want to look up
        :return: list[ContributionSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contribution_sub_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_contribution_sub_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'contribution_sub_type_id' in params:
            query_params.append(('ContributionSubTypeID', params['contribution_sub_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ContributionSubType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContributionSubTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_contribution_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ContributionType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contribution_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_type_id: ID of the ContributionType you want to look up
        :return: list[ContributionTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_contribution_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_contribution_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_contribution_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ContributionType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_contribution_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_type_id: ID of the ContributionType you want to look up
        :return: list[ContributionTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contribution_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_contribution_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'contribution_type_id' in params:
            query_params.append(('ContributionTypeID', params['contribution_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ContributionType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContributionTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_correspondence_source(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CorrespondenceSource in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_correspondence_source(async=True)
        >>> result = thread.get()

        :param async bool
        :param int correspondence_source_id: ID of the CorrespondenceSource you want to look up
        :return: list[CorrespondenceSourceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_correspondence_source_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_correspondence_source_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_correspondence_source_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CorrespondenceSource in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_correspondence_source_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int correspondence_source_id: ID of the CorrespondenceSource you want to look up
        :return: list[CorrespondenceSourceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['correspondence_source_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_correspondence_source" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'correspondence_source_id' in params:
            query_params.append(('CorrespondenceSourceID', params['correspondence_source_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/CorrespondenceSource', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CorrespondenceSourceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_country(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Country in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_country(async=True)
        >>> result = thread.get()

        :param async bool
        :param int country_id: ID of the Country you want to look up
        :return: list[CountryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_country_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_country_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_country_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Country in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_country_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int country_id: ID of the Country you want to look up
        :return: list[CountryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['country_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_country" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'country_id' in params:
            query_params.append(('CountryID', params['country_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Country', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CountryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_course(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Course in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_course(async=True)
        >>> result = thread.get()

        :param async bool
        :param int course_id: ID of the Course you want to look up
        :return: list[CourseItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_course_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_course_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_course_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Course in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_course_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int course_id: ID of the Course you want to look up
        :return: list[CourseItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_course" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'course_id' in params:
            query_params.append(('CourseID', params['course_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Course', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CourseItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_currency_conversion(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CurrencyConversion in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_currency_conversion(async=True)
        >>> result = thread.get()

        :param async bool
        :param int currency_conversion_id: ID of the CurrencyConversion you want to look up
        :return: list[CurrencyConversionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_currency_conversion_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_currency_conversion_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_currency_conversion_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CurrencyConversion in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_currency_conversion_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int currency_conversion_id: ID of the CurrencyConversion you want to look up
        :return: list[CurrencyConversionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['currency_conversion_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_currency_conversion" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'currency_conversion_id' in params:
            query_params.append(('CurrencyConversionID', params['currency_conversion_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/CurrencyConversion', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CurrencyConversionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_custom_field_definition(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CustomFieldDefinition in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_custom_field_definition(async=True)
        >>> result = thread.get()

        :param async bool
        :param int custom_field_definition_id: ID of the CustomFieldDefinition you want to look up
        :return: list[CustomFieldDefinitionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_custom_field_definition_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_custom_field_definition_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_custom_field_definition_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CustomFieldDefinition in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_custom_field_definition_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int custom_field_definition_id: ID of the CustomFieldDefinition you want to look up
        :return: list[CustomFieldDefinitionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['custom_field_definition_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_custom_field_definition" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'custom_field_definition_id' in params:
            query_params.append(('CustomFieldDefinitionID', params['custom_field_definition_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/CustomFieldDefinition', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CustomFieldDefinitionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_custom_method_tag(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CustomMethodTag in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_custom_method_tag(async=True)
        >>> result = thread.get()

        :param async bool
        :param int custom_method_tag_id: ID of the CustomMethodTag you want to look up
        :return: list[CustomMethodTagItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_custom_method_tag_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_custom_method_tag_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_custom_method_tag_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a CustomMethodTag in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_custom_method_tag_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int custom_method_tag_id: ID of the CustomMethodTag you want to look up
        :return: list[CustomMethodTagItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['custom_method_tag_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_custom_method_tag" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'custom_method_tag_id' in params:
            query_params.append(('CustomMethodTagID', params['custom_method_tag_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/CustomMethodTag', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CustomMethodTagItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_dashboard(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Dashboard in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_dashboard(async=True)
        >>> result = thread.get()

        :param async bool
        :param int dashboard_id: ID of the Dashboard you want to look up
        :return: list[DashboardItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_dashboard_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_dashboard_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_dashboard_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Dashboard in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_dashboard_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int dashboard_id: ID of the Dashboard you want to look up
        :return: list[DashboardItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dashboard_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_dashboard" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'dashboard_id' in params:
            query_params.append(('DashboardID', params['dashboard_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Dashboard', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DashboardItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_dashboard_panel(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a DashboardPanel in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_dashboard_panel(async=True)
        >>> result = thread.get()

        :param async bool
        :param int dashboard_panel_id: ID of the DashboardPanel you want to look up
        :return: list[DashboardPanelItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_dashboard_panel_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_dashboard_panel_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_dashboard_panel_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a DashboardPanel in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_dashboard_panel_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int dashboard_panel_id: ID of the DashboardPanel you want to look up
        :return: list[DashboardPanelItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dashboard_panel_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_dashboard_panel" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'dashboard_panel_id' in params:
            query_params.append(('DashboardPanelID', params['dashboard_panel_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/DashboardPanel', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DashboardPanelItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_dashboard_panel_setting(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a DashboardPanelSetting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_dashboard_panel_setting(async=True)
        >>> result = thread.get()

        :param async bool
        :param int dashboard_panel_setting_id: ID of the DashboardPanelSetting you want to look up
        :return: list[DashboardPanelSettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_dashboard_panel_setting_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_dashboard_panel_setting_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_dashboard_panel_setting_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a DashboardPanelSetting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_dashboard_panel_setting_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int dashboard_panel_setting_id: ID of the DashboardPanelSetting you want to look up
        :return: list[DashboardPanelSettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dashboard_panel_setting_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_dashboard_panel_setting" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'dashboard_panel_setting_id' in params:
            query_params.append(('DashboardPanelSettingID', params['dashboard_panel_setting_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/DashboardPanelSetting', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DashboardPanelSettingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_dashboard_sharing(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a DashboardSharing in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_dashboard_sharing(async=True)
        >>> result = thread.get()

        :param async bool
        :param int dashboard_sharing_id: ID of the DashboardSharing you want to look up
        :return: list[DashboardSharingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_dashboard_sharing_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_dashboard_sharing_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_dashboard_sharing_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a DashboardSharing in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_dashboard_sharing_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int dashboard_sharing_id: ID of the DashboardSharing you want to look up
        :return: list[DashboardSharingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dashboard_sharing_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_dashboard_sharing" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'dashboard_sharing_id' in params:
            query_params.append(('DashboardSharingID', params['dashboard_sharing_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/DashboardSharing', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DashboardSharingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_deleted_transaction(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a DeletedTransaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_deleted_transaction(async=True)
        >>> result = thread.get()

        :param async bool
        :param int deleted_transaction_id: ID of the DeletedTransaction you want to look up
        :return: list[DeletedTransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_deleted_transaction_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_deleted_transaction_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_deleted_transaction_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a DeletedTransaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_deleted_transaction_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int deleted_transaction_id: ID of the DeletedTransaction you want to look up
        :return: list[DeletedTransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deleted_transaction_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_deleted_transaction" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'deleted_transaction_id' in params:
            query_params.append(('DeletedTransactionID', params['deleted_transaction_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/DeletedTransaction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DeletedTransactionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_document(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Document in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_document(async=True)
        >>> result = thread.get()

        :param async bool
        :param int document_id: ID of the Document you want to look up
        :return: list[DocumentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_document_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_document_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_document_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Document in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_document_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int document_id: ID of the Document you want to look up
        :return: list[DocumentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['document_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_document" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'document_id' in params:
            query_params.append(('DocumentID', params['document_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Document', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DocumentItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_dynamic_list(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a DynamicList in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_dynamic_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param int dynamic_list_id: ID of the DynamicList you want to look up
        :return: list[DynamicListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_dynamic_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_dynamic_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_dynamic_list_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a DynamicList in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_dynamic_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int dynamic_list_id: ID of the DynamicList you want to look up
        :return: list[DynamicListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dynamic_list_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_dynamic_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'dynamic_list_id' in params:
            query_params.append(('DynamicListID', params['dynamic_list_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/DynamicList', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DynamicListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_dynamic_list_permission(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a DynamicListPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_dynamic_list_permission(async=True)
        >>> result = thread.get()

        :param async bool
        :param int dynamic_list_permission_id: ID of the DynamicListPermission you want to look up
        :return: list[DynamicListPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_dynamic_list_permission_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_dynamic_list_permission_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_dynamic_list_permission_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a DynamicListPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_dynamic_list_permission_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int dynamic_list_permission_id: ID of the DynamicListPermission you want to look up
        :return: list[DynamicListPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dynamic_list_permission_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_dynamic_list_permission" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'dynamic_list_permission_id' in params:
            query_params.append(('DynamicListPermissionID', params['dynamic_list_permission_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/DynamicListPermission', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DynamicListPermissionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_electronic_identity_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ElectronicIdentityType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_electronic_identity_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int electronic_identity_type_id: ID of the ElectronicIdentityType you want to look up
        :return: list[ElectronicIdentityTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_electronic_identity_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_electronic_identity_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_electronic_identity_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ElectronicIdentityType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_electronic_identity_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int electronic_identity_type_id: ID of the ElectronicIdentityType you want to look up
        :return: list[ElectronicIdentityTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['electronic_identity_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_electronic_identity_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'electronic_identity_type_id' in params:
            query_params.append(('ElectronicIdentityTypeID', params['electronic_identity_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ElectronicIdentityType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ElectronicIdentityTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_email_from_address(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EmailFromAddress in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_email_from_address(async=True)
        >>> result = thread.get()

        :param async bool
        :param int email_from_address_id: ID of the EmailFromAddress you want to look up
        :return: list[EmailFromAddressItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_email_from_address_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_email_from_address_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_email_from_address_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EmailFromAddress in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_email_from_address_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int email_from_address_id: ID of the EmailFromAddress you want to look up
        :return: list[EmailFromAddressItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email_from_address_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_email_from_address" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'email_from_address_id' in params:
            query_params.append(('EmailFromAddressID', params['email_from_address_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EmailFromAddress', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EmailFromAddressItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_email_from_address_permission(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EmailFromAddressPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_email_from_address_permission(async=True)
        >>> result = thread.get()

        :param async bool
        :param int email_from_address_permission_id: ID of the EmailFromAddressPermission you want to look up
        :return: list[EmailFromAddressPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_email_from_address_permission_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_email_from_address_permission_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_email_from_address_permission_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EmailFromAddressPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_email_from_address_permission_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int email_from_address_permission_id: ID of the EmailFromAddressPermission you want to look up
        :return: list[EmailFromAddressPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email_from_address_permission_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_email_from_address_permission" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'email_from_address_permission_id' in params:
            query_params.append(('EmailFromAddressPermissionID', params['email_from_address_permission_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EmailFromAddressPermission', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EmailFromAddressPermissionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_email_outbox(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EmailOutbox in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_email_outbox(async=True)
        >>> result = thread.get()

        :param async bool
        :param int email_outbox_id: ID of the EmailOutbox you want to look up
        :return: list[EmailOutboxItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_email_outbox_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_email_outbox_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_email_outbox_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EmailOutbox in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_email_outbox_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int email_outbox_id: ID of the EmailOutbox you want to look up
        :return: list[EmailOutboxItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email_outbox_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_email_outbox" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'email_outbox_id' in params:
            query_params.append(('EmailOutboxID', params['email_outbox_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EmailOutbox', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EmailOutboxItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_end_of_session(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EndOfSession in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_end_of_session(async=True)
        >>> result = thread.get()

        :param async bool
        :param int end_of_session_id: ID of the EndOfSession you want to look up
        :return: list[EndOfSessionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_end_of_session_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_end_of_session_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_end_of_session_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EndOfSession in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_end_of_session_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int end_of_session_id: ID of the EndOfSession you want to look up
        :return: list[EndOfSessionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['end_of_session_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_end_of_session" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'end_of_session_id' in params:
            query_params.append(('EndOfSessionID', params['end_of_session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EndOfSession', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EndOfSessionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_end_of_session_charge_group(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EndOfSessionChargeGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_end_of_session_charge_group(async=True)
        >>> result = thread.get()

        :param async bool
        :param int end_of_session_charge_group_id: ID of the EndOfSessionChargeGroup you want to look up
        :return: list[EndOfSessionChargeGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_end_of_session_charge_group_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_end_of_session_charge_group_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_end_of_session_charge_group_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EndOfSessionChargeGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_end_of_session_charge_group_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int end_of_session_charge_group_id: ID of the EndOfSessionChargeGroup you want to look up
        :return: list[EndOfSessionChargeGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['end_of_session_charge_group_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_end_of_session_charge_group" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'end_of_session_charge_group_id' in params:
            query_params.append(('EndOfSessionChargeGroupID', params['end_of_session_charge_group_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EndOfSessionChargeGroup', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EndOfSessionChargeGroupItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry(self, **kwargs):  # noqa: E501
        """student info  # noqa: E501

        By passing in the appropriate options, you can search for a resident in the system   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name_first: First Name of the resident you want to look up
        :param str name_last: Last Name of the resident you want to look up
        :param str name_web: Email address of the resident you want to look up
        :param str name_preferred: Preferred First Name of the resident you want to look up
        :return: list[EntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_with_http_info(self, **kwargs):  # noqa: E501
        """student info  # noqa: E501

        By passing in the appropriate options, you can search for a resident in the system   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str name_first: First Name of the resident you want to look up
        :param str name_last: Last Name of the resident you want to look up
        :param str name_web: Email address of the resident you want to look up
        :param str name_preferred: Preferred First Name of the resident you want to look up
        :return: list[EntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name_first', 'name_last', 'name_web', 'name_preferred']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name_first' in params:
            query_params.append(('NameFirst', params['name_first']))  # noqa: E501
        if 'name_last' in params:
            query_params.append(('NameLast', params['name_last']))  # noqa: E501
        if 'name_web' in params:
            query_params.append(('NameWeb', params['name_web']))  # noqa: E501
        if 'name_preferred' in params:
            query_params.append(('NamePreferred', params['name_preferred']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Entry', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_address(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryAddress in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_address(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_address_id: ID of the EntryAddress you want to look up
        :return: list[EntryAddressItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_address_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_address_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_address_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryAddress in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_address_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_address_id: ID of the EntryAddress you want to look up
        :return: list[EntryAddressItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_address_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_address" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_address_id' in params:
            query_params.append(('EntryAddressID', params['entry_address_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryAddress', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryAddressItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_alumni(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryAlumni in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_alumni(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_alumni_id: ID of the EntryAlumni you want to look up
        :return: list[EntryAlumniItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_alumni_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_alumni_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_alumni_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryAlumni in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_alumni_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_alumni_id: ID of the EntryAlumni you want to look up
        :return: list[EntryAlumniItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_alumni_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_alumni" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_alumni_id' in params:
            query_params.append(('EntryAlumniID', params['entry_alumni_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryAlumni', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryAlumniItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_alumni_status(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryAlumniStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_alumni_status(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_alumni_status_id: ID of the EntryAlumniStatus you want to look up
        :return: list[EntryAlumniStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_alumni_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_alumni_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_alumni_status_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryAlumniStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_alumni_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_alumni_status_id: ID of the EntryAlumniStatus you want to look up
        :return: list[EntryAlumniStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_alumni_status_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_alumni_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_alumni_status_id' in params:
            query_params.append(('EntryAlumniStatusID', params['entry_alumni_status_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryAlumniStatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryAlumniStatusItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_application(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryApplication in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_application(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_id: ID of the EntryApplication you want to look up
        :return: list[EntryApplicationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_application_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_application_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_application_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryApplication in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_application_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_id: ID of the EntryApplication you want to look up
        :return: list[EntryApplicationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_application_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_application" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_application_id' in params:
            query_params.append(('EntryApplicationID', params['entry_application_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryApplication', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryApplicationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_application_custom_field(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryApplicationCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_application_custom_field(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_custom_field_id: ID of the EntryApplicationCustomField you want to look up
        :return: list[EntryApplicationCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_application_custom_field_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_application_custom_field_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_application_custom_field_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryApplicationCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_application_custom_field_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_custom_field_id: ID of the EntryApplicationCustomField you want to look up
        :return: list[EntryApplicationCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_application_custom_field_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_application_custom_field" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_application_custom_field_id' in params:
            query_params.append(('EntryApplicationCustomFieldID', params['entry_application_custom_field_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryApplicationCustomField', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryApplicationCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_application_note(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryApplicationNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_application_note(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_note_id: ID of the EntryApplicationNote you want to look up
        :return: list[EntryApplicationNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_application_note_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_application_note_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_application_note_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryApplicationNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_application_note_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_note_id: ID of the EntryApplicationNote you want to look up
        :return: list[EntryApplicationNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_application_note_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_application_note" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_application_note_id' in params:
            query_params.append(('EntryApplicationNoteID', params['entry_application_note_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryApplicationNote', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryApplicationNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_application_portal_section(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryApplicationPortalSection in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_application_portal_section(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_portal_section_id: ID of the EntryApplicationPortalSection you want to look up
        :return: list[EntryApplicationPortalSectionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_application_portal_section_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_application_portal_section_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_application_portal_section_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryApplicationPortalSection in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_application_portal_section_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_portal_section_id: ID of the EntryApplicationPortalSection you want to look up
        :return: list[EntryApplicationPortalSectionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_application_portal_section_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_application_portal_section" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_application_portal_section_id' in params:
            query_params.append(('EntryApplicationPortalSectionID', params['entry_application_portal_section_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryApplicationPortalSection', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryApplicationPortalSectionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_application_preference(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryApplicationPreference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_application_preference(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_preference_id: ID of the EntryApplicationPreference you want to look up
        :return: list[EntryApplicationPreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_application_preference_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_application_preference_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_application_preference_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryApplicationPreference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_application_preference_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_preference_id: ID of the EntryApplicationPreference you want to look up
        :return: list[EntryApplicationPreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_application_preference_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_application_preference" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_application_preference_id' in params:
            query_params.append(('EntryApplicationPreferenceID', params['entry_application_preference_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryApplicationPreference', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryApplicationPreferenceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_application_proxy(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryApplicationProxy in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_application_proxy(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_proxy_id: ID of the EntryApplicationProxy you want to look up
        :return: list[EntryApplicationProxyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_application_proxy_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_application_proxy_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_application_proxy_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryApplicationProxy in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_application_proxy_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_proxy_id: ID of the EntryApplicationProxy you want to look up
        :return: list[EntryApplicationProxyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_application_proxy_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_application_proxy" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_application_proxy_id' in params:
            query_params.append(('EntryApplicationProxyID', params['entry_application_proxy_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryApplicationProxy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryApplicationProxyItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_application_room_mate(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryApplicationRoomMate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_application_room_mate(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_room_mate_id: ID of the EntryApplicationRoomMate you want to look up
        :return: list[EntryApplicationRoomMateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_application_room_mate_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_application_room_mate_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_application_room_mate_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryApplicationRoomMate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_application_room_mate_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_room_mate_id: ID of the EntryApplicationRoomMate you want to look up
        :return: list[EntryApplicationRoomMateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_application_room_mate_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_application_room_mate" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_application_room_mate_id' in params:
            query_params.append(('EntryApplicationRoomMateID', params['entry_application_room_mate_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryApplicationRoomMate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryApplicationRoomMateItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_application_room_preference(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryApplicationRoomPreference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_application_room_preference(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_room_preference_id: ID of the EntryApplicationRoomPreference you want to look up
        :return: list[EntryApplicationRoomPreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_application_room_preference_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_application_room_preference_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_application_room_preference_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryApplicationRoomPreference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_application_room_preference_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_room_preference_id: ID of the EntryApplicationRoomPreference you want to look up
        :return: list[EntryApplicationRoomPreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_application_room_preference_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_application_room_preference" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_application_room_preference_id' in params:
            query_params.append(('EntryApplicationRoomPreferenceID', params['entry_application_room_preference_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryApplicationRoomPreference', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryApplicationRoomPreferenceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_correspondence(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryCorrespondence in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_correspondence(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_correspondence_id: ID of the EntryCorrespondence you want to look up
        :return: list[EntryCorrespondenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_correspondence_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_correspondence_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_correspondence_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryCorrespondence in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_correspondence_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_correspondence_id: ID of the EntryCorrespondence you want to look up
        :return: list[EntryCorrespondenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_correspondence_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_correspondence" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_correspondence_id' in params:
            query_params.append(('EntryCorrespondenceID', params['entry_correspondence_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryCorrespondence', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryCorrespondenceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_custom_field(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_custom_field(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_custom_field_id: ID of the EntryCustomField you want to look up
        :return: list[EntryCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_custom_field_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_custom_field_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_custom_field_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_custom_field_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_custom_field_id: ID of the EntryCustomField you want to look up
        :return: list[EntryCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_custom_field_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_custom_field" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_custom_field_id' in params:
            query_params.append(('EntryCustomFieldID', params['entry_custom_field_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryCustomField', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_detail(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_detail(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_detail_id: ID of the EntryDetail you want to look up
        :return: list[EntryDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_detail_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_detail_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_detail_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_detail_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_detail_id: ID of the EntryDetail you want to look up
        :return: list[EntryDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_detail_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_detail" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_detail_id' in params:
            query_params.append(('EntryDetailID', params['entry_detail_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryDetail', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryDetailItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_electronic_identity(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryElectronicIdentity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_electronic_identity(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_electronic_identity_id: ID of the EntryElectronicIdentity you want to look up
        :return: list[EntryElectronicIdentityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_electronic_identity_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_electronic_identity_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_electronic_identity_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryElectronicIdentity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_electronic_identity_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_electronic_identity_id: ID of the EntryElectronicIdentity you want to look up
        :return: list[EntryElectronicIdentityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_electronic_identity_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_electronic_identity" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_electronic_identity_id' in params:
            query_params.append(('EntryElectronicIdentityID', params['entry_electronic_identity_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryElectronicIdentity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryElectronicIdentityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_enrollment(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryEnrollment in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_enrollment(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_enrollment_id: ID of the EntryEnrollment you want to look up
        :return: list[EntryEnrollmentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_enrollment_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_enrollment_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_enrollment_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryEnrollment in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_enrollment_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_enrollment_id: ID of the EntryEnrollment you want to look up
        :return: list[EntryEnrollmentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_enrollment_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_enrollment" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_enrollment_id' in params:
            query_params.append(('EntryEnrollmentID', params['entry_enrollment_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryEnrollment', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryEnrollmentItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_event(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryEvent in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_event(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_event_id: ID of the EntryEvent you want to look up
        :return: list[EntryEventItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_event_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_event_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_event_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryEvent in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_event_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_event_id: ID of the EntryEvent you want to look up
        :return: list[EntryEventItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_event_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_event" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_event_id' in params:
            query_params.append(('EntryEventID', params['entry_event_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryEvent', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryEventItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_family(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryFamily in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_family(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_family_id: ID of the EntryFamily you want to look up
        :return: list[EntryFamilyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_family_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_family_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_family_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryFamily in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_family_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_family_id: ID of the EntryFamily you want to look up
        :return: list[EntryFamilyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_family_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_family" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_family_id' in params:
            query_params.append(('EntryFamilyID', params['entry_family_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryFamily', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryFamilyItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_group(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_group(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_group_id: ID of the EntryGroup you want to look up
        :return: list[EntryGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_group_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_group_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_group_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_group_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_group_id: ID of the EntryGroup you want to look up
        :return: list[EntryGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_group_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_group" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_group_id' in params:
            query_params.append(('EntryGroupID', params['entry_group_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryGroup', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryGroupItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_invitation(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryInvitation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_invitation(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_invitation_id: ID of the EntryInvitation you want to look up
        :return: list[EntryInvitationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_invitation_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_invitation_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_invitation_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryInvitation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_invitation_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_invitation_id: ID of the EntryInvitation you want to look up
        :return: list[EntryInvitationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_invitation_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_invitation" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_invitation_id' in params:
            query_params.append(('EntryInvitationID', params['entry_invitation_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryInvitation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryInvitationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_meal(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryMeal in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_meal(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_meal_id: ID of the EntryMeal you want to look up
        :return: list[EntryMealItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_meal_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_meal_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_meal_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryMeal in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_meal_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_meal_id: ID of the EntryMeal you want to look up
        :return: list[EntryMealItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_meal_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_meal" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_meal_id' in params:
            query_params.append(('EntryMealID', params['entry_meal_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryMeal', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryMealItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_meal_plan_detail(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryMealPlanDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_meal_plan_detail(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_meal_plan_detail_id: ID of the EntryMealPlanDetail you want to look up
        :return: list[EntryMealPlanDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_meal_plan_detail_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_meal_plan_detail_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_meal_plan_detail_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryMealPlanDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_meal_plan_detail_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_meal_plan_detail_id: ID of the EntryMealPlanDetail you want to look up
        :return: list[EntryMealPlanDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_meal_plan_detail_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_meal_plan_detail" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_meal_plan_detail_id' in params:
            query_params.append(('EntryMealPlanDetailID', params['entry_meal_plan_detail_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryMealPlanDetail', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryMealPlanDetailItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_meal_tag(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryMealTag in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_meal_tag(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_meal_tag_id: ID of the EntryMealTag you want to look up
        :return: list[EntryMealTagItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_meal_tag_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_meal_tag_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_meal_tag_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryMealTag in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_meal_tag_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_meal_tag_id: ID of the EntryMealTag you want to look up
        :return: list[EntryMealTagItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_meal_tag_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_meal_tag" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_meal_tag_id' in params:
            query_params.append(('EntryMealTagID', params['entry_meal_tag_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryMealTag', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryMealTagItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_membership(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryMembership in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_membership(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_membership_id: ID of the EntryMembership you want to look up
        :return: list[EntryMembershipItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_membership_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_membership_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_membership_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryMembership in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_membership_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_membership_id: ID of the EntryMembership you want to look up
        :return: list[EntryMembershipItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_membership_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_membership" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_membership_id' in params:
            query_params.append(('EntryMembershipID', params['entry_membership_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryMembership', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryMembershipItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_note(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_note(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_note_id: ID of the EntryNote you want to look up
        :return: list[EntryNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_note_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_note_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_note_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_note_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_note_id: ID of the EntryNote you want to look up
        :return: list[EntryNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_note_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_note" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_note_id' in params:
            query_params.append(('EntryNoteID', params['entry_note_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryNote', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_parcel(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryParcel in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_parcel(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_parcel_id: ID of the EntryParcel you want to look up
        :return: list[EntryParcelItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_parcel_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_parcel_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_parcel_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryParcel in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_parcel_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_parcel_id: ID of the EntryParcel you want to look up
        :return: list[EntryParcelItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_parcel_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_parcel" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_parcel_id' in params:
            query_params.append(('EntryParcelID', params['entry_parcel_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryParcel', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryParcelItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_portal_activity(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryPortalActivity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_portal_activity(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_portal_activity_id: ID of the EntryPortalActivity you want to look up
        :return: list[EntryPortalActivityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_portal_activity_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_portal_activity_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_portal_activity_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryPortalActivity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_portal_activity_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_portal_activity_id: ID of the EntryPortalActivity you want to look up
        :return: list[EntryPortalActivityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_portal_activity_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_portal_activity" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_portal_activity_id' in params:
            query_params.append(('EntryPortalActivityID', params['entry_portal_activity_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryPortalActivity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryPortalActivityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_position(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryPosition in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_position(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_position_id: ID of the EntryPosition you want to look up
        :return: list[EntryPositionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_position_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_position_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_position_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryPosition in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_position_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_position_id: ID of the EntryPosition you want to look up
        :return: list[EntryPositionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_position_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_position" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_position_id' in params:
            query_params.append(('EntryPositionID', params['entry_position_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryPosition', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryPositionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_profile(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_profile(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_profile_id: ID of the EntryProfile you want to look up
        :return: list[EntryProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_profile_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_profile_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_profile_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_profile_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_profile_id: ID of the EntryProfile you want to look up
        :return: list[EntryProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_profile" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_profile_id' in params:
            query_params.append(('EntryProfileID', params['entry_profile_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryProfile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryProfileItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_result(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryResult in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_result(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_result_id: ID of the EntryResult you want to look up
        :return: list[EntryResultItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_result_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_result_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_result_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryResult in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_result_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_result_id: ID of the EntryResult you want to look up
        :return: list[EntryResultItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_result_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_result" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_result_id' in params:
            query_params.append(('EntryResultID', params['entry_result_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryResult', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryResultItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_schedule_transaction(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryScheduleTransaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_schedule_transaction(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_schedule_transaction_id: ID of the EntryScheduleTransaction you want to look up
        :return: list[EntryScheduleTransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_schedule_transaction_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_schedule_transaction_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_schedule_transaction_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryScheduleTransaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_schedule_transaction_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_schedule_transaction_id: ID of the EntryScheduleTransaction you want to look up
        :return: list[EntryScheduleTransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_schedule_transaction_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_schedule_transaction" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_schedule_transaction_id' in params:
            query_params.append(('EntryScheduleTransactionID', params['entry_schedule_transaction_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryScheduleTransaction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryScheduleTransactionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_scholarship(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryScholarship in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_scholarship(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_scholarship_id: ID of the EntryScholarship you want to look up
        :return: list[EntryScholarshipItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_scholarship_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_scholarship_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_scholarship_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryScholarship in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_scholarship_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_scholarship_id: ID of the EntryScholarship you want to look up
        :return: list[EntryScholarshipItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_scholarship_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_scholarship" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_scholarship_id' in params:
            query_params.append(('EntryScholarshipID', params['entry_scholarship_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryScholarship', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryScholarshipItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_school(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntrySchool in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_school(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_school_id: ID of the EntrySchool you want to look up
        :return: list[EntrySchoolItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_school_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_school_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_school_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntrySchool in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_school_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_school_id: ID of the EntrySchool you want to look up
        :return: list[EntrySchoolItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_school_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_school" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_school_id' in params:
            query_params.append(('EntrySchoolID', params['entry_school_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntrySchool', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntrySchoolItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_sdas(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntrySDAS in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_sdas(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_sdasid: ID of the EntrySDAS you want to look up
        :return: list[EntrySDASItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_sdas_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_sdas_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_sdas_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntrySDAS in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_sdas_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_sdasid: ID of the EntrySDAS you want to look up
        :return: list[EntrySDASItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_sdasid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_sdas" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_sdasid' in params:
            query_params.append(('EntrySDASID', params['entry_sdasid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntrySDAS', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntrySDASItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_visitor(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryVisitor in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_visitor(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_visitor_id: ID of the EntryVisitor you want to look up
        :return: list[EntryVisitorItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_visitor_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_visitor_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_entry_visitor_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EntryVisitor in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_visitor_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_visitor_id: ID of the EntryVisitor you want to look up
        :return: list[EntryVisitorItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_visitor_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_visitor" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entry_visitor_id' in params:
            query_params.append(('EntryVisitorID', params['entry_visitor_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EntryVisitor', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryVisitorItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_entry_xml(self, query, **kwargs):  # noqa: E501
        """student info  # noqa: E501

        By passing in the appropriate options, you can search for a resident in the system   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_xml(query, async=True)
        >>> result = thread.get()

        :param async bool
        :param str query: An XML query on the table (required)
        :return: list[EntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_entry_xml_with_http_info(query, **kwargs)  # noqa: E501
        else:
            (data) = self.search_entry_xml_with_http_info(query, **kwargs)  # noqa: E501
            return data

    def search_entry_xml_with_http_info(self, query, **kwargs):  # noqa: E501
        """student info  # noqa: E501

        By passing in the appropriate options, you can search for a resident in the system   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_entry_xml_with_http_info(query, async=True)
        >>> result = thread.get()

        :param async bool
        :param str query: An XML query on the table (required)
        :return: list[EntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_entry_xml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'query' is set
        if ('query' not in params or
                params['query'] is None):
            raise ValueError("Missing the required parameter `query` when calling `search_entry_xml`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'query' in params:
            body_params = params['query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Entry', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_event(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Event in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: ID of the Event you want to look up
        :return: list[EventItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_event_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_event_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_event_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Event in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: ID of the Event you want to look up
        :return: list[EventItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_event" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'event_id' in params:
            query_params.append(('EventID', params['event_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Event', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_event_charge(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EventCharge in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event_charge(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_charge_id: ID of the EventCharge you want to look up
        :return: list[EventChargeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_event_charge_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_event_charge_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_event_charge_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EventCharge in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event_charge_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_charge_id: ID of the EventCharge you want to look up
        :return: list[EventChargeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_charge_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_event_charge" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'event_charge_id' in params:
            query_params.append(('EventChargeID', params['event_charge_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EventCharge', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventChargeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_event_contact_entry(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EventContactEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event_contact_entry(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_contact_entry_id: ID of the EventContactEntry you want to look up
        :return: list[EventContactEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_event_contact_entry_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_event_contact_entry_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_event_contact_entry_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EventContactEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event_contact_entry_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_contact_entry_id: ID of the EventContactEntry you want to look up
        :return: list[EventContactEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_contact_entry_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_event_contact_entry" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'event_contact_entry_id' in params:
            query_params.append(('EventContactEntryID', params['event_contact_entry_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EventContactEntry', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventContactEntryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_event_custom_field(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EventCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event_custom_field(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_custom_field_id: ID of the EventCustomField you want to look up
        :return: list[EventCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_event_custom_field_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_event_custom_field_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_event_custom_field_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EventCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event_custom_field_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_custom_field_id: ID of the EventCustomField you want to look up
        :return: list[EventCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_custom_field_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_event_custom_field" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'event_custom_field_id' in params:
            query_params.append(('EventCustomFieldID', params['event_custom_field_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EventCustomField', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_event_meal_plan(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EventMealPlan in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event_meal_plan(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_meal_plan_id: ID of the EventMealPlan you want to look up
        :return: list[EventMealPlanItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_event_meal_plan_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_event_meal_plan_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_event_meal_plan_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EventMealPlan in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event_meal_plan_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_meal_plan_id: ID of the EventMealPlan you want to look up
        :return: list[EventMealPlanItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_meal_plan_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_event_meal_plan" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'event_meal_plan_id' in params:
            query_params.append(('EventMealPlanID', params['event_meal_plan_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EventMealPlan', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventMealPlanItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_event_note(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EventNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event_note(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_note_id: ID of the EventNote you want to look up
        :return: list[EventNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_event_note_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_event_note_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_event_note_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EventNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event_note_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_note_id: ID of the EventNote you want to look up
        :return: list[EventNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_note_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_event_note" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'event_note_id' in params:
            query_params.append(('EventNoteID', params['event_note_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EventNote', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_event_quote(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EventQuote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event_quote(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_quote_id: ID of the EventQuote you want to look up
        :return: list[EventQuoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_event_quote_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_event_quote_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_event_quote_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EventQuote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event_quote_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_quote_id: ID of the EventQuote you want to look up
        :return: list[EventQuoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_quote_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_event_quote" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'event_quote_id' in params:
            query_params.append(('EventQuoteID', params['event_quote_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EventQuote', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventQuoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_event_registration_fee(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EventRegistrationFee in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event_registration_fee(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_registration_fee_id: ID of the EventRegistrationFee you want to look up
        :return: list[EventRegistrationFeeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_event_registration_fee_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_event_registration_fee_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_event_registration_fee_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EventRegistrationFee in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event_registration_fee_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_registration_fee_id: ID of the EventRegistrationFee you want to look up
        :return: list[EventRegistrationFeeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_registration_fee_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_event_registration_fee" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'event_registration_fee_id' in params:
            query_params.append(('EventRegistrationFeeID', params['event_registration_fee_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EventRegistrationFee', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventRegistrationFeeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_event_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EventType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_type_id: ID of the EventType you want to look up
        :return: list[EventTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_event_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_event_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_event_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a EventType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_event_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_type_id: ID of the EventType you want to look up
        :return: list[EventTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_event_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'event_type_id' in params:
            query_params.append(('EventTypeID', params['event_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/EventType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_extension(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Extension in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_extension(async=True)
        >>> result = thread.get()

        :param async bool
        :param int extension_id: ID of the Extension you want to look up
        :return: list[ExtensionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_extension_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_extension_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_extension_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Extension in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_extension_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int extension_id: ID of the Extension you want to look up
        :return: list[ExtensionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['extension_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_extension" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'extension_id' in params:
            query_params.append(('ExtensionID', params['extension_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Extension', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ExtensionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_field_default(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FieldDefault in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_field_default(async=True)
        >>> result = thread.get()

        :param async bool
        :param int field_default_id: ID of the FieldDefault you want to look up
        :return: list[FieldDefaultItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_field_default_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_field_default_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_field_default_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FieldDefault in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_field_default_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int field_default_id: ID of the FieldDefault you want to look up
        :return: list[FieldDefaultItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['field_default_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_field_default" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'field_default_id' in params:
            query_params.append(('FieldDefaultID', params['field_default_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FieldDefault', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FieldDefaultItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_financial_support(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FinancialSupport in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_financial_support(async=True)
        >>> result = thread.get()

        :param async bool
        :param int financial_support_id: ID of the FinancialSupport you want to look up
        :return: list[FinancialSupportItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_financial_support_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_financial_support_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_financial_support_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FinancialSupport in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_financial_support_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int financial_support_id: ID of the FinancialSupport you want to look up
        :return: list[FinancialSupportItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['financial_support_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_financial_support" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'financial_support_id' in params:
            query_params.append(('FinancialSupportID', params['financial_support_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FinancialSupport', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FinancialSupportItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_function_booking(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_booking(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_id: ID of the FunctionBooking you want to look up
        :return: list[FunctionBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_function_booking_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_function_booking_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_function_booking_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_booking_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_id: ID of the FunctionBooking you want to look up
        :return: list[FunctionBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_booking_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_function_booking" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'function_booking_id' in params:
            query_params.append(('FunctionBookingID', params['function_booking_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FunctionBooking', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionBookingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_function_booking_attendee(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionBookingAttendee in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_booking_attendee(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_attendee_id: ID of the FunctionBookingAttendee you want to look up
        :return: list[FunctionBookingAttendeeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_function_booking_attendee_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_function_booking_attendee_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_function_booking_attendee_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionBookingAttendee in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_booking_attendee_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_attendee_id: ID of the FunctionBookingAttendee you want to look up
        :return: list[FunctionBookingAttendeeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_booking_attendee_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_function_booking_attendee" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'function_booking_attendee_id' in params:
            query_params.append(('FunctionBookingAttendeeID', params['function_booking_attendee_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FunctionBookingAttendee', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionBookingAttendeeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_function_booking_catering(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionBookingCatering in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_booking_catering(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_catering_id: ID of the FunctionBookingCatering you want to look up
        :return: list[FunctionBookingCateringItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_function_booking_catering_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_function_booking_catering_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_function_booking_catering_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionBookingCatering in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_booking_catering_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_catering_id: ID of the FunctionBookingCatering you want to look up
        :return: list[FunctionBookingCateringItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_booking_catering_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_function_booking_catering" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'function_booking_catering_id' in params:
            query_params.append(('FunctionBookingCateringID', params['function_booking_catering_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FunctionBookingCatering', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionBookingCateringItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_function_booking_catering_item(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionBookingCateringItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_booking_catering_item(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_catering_item_id: ID of the FunctionBookingCateringItem you want to look up
        :return: list[FunctionBookingCateringItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_function_booking_catering_item_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_function_booking_catering_item_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_function_booking_catering_item_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionBookingCateringItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_booking_catering_item_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_catering_item_id: ID of the FunctionBookingCateringItem you want to look up
        :return: list[FunctionBookingCateringItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_booking_catering_item_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_function_booking_catering_item" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'function_booking_catering_item_id' in params:
            query_params.append(('FunctionBookingCateringItemID', params['function_booking_catering_item_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FunctionBookingCateringItem', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionBookingCateringItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_function_booking_charge(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionBookingCharge in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_booking_charge(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_charge_id: ID of the FunctionBookingCharge you want to look up
        :return: list[FunctionBookingChargeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_function_booking_charge_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_function_booking_charge_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_function_booking_charge_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionBookingCharge in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_booking_charge_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_charge_id: ID of the FunctionBookingCharge you want to look up
        :return: list[FunctionBookingChargeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_booking_charge_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_function_booking_charge" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'function_booking_charge_id' in params:
            query_params.append(('FunctionBookingChargeID', params['function_booking_charge_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FunctionBookingCharge', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionBookingChargeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_function_resource(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionResource in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_resource(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_resource_id: ID of the FunctionResource you want to look up
        :return: list[FunctionResourceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_function_resource_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_function_resource_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_function_resource_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionResource in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_resource_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_resource_id: ID of the FunctionResource you want to look up
        :return: list[FunctionResourceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_resource_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_function_resource" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'function_resource_id' in params:
            query_params.append(('FunctionResourceID', params['function_resource_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FunctionResource', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionResourceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_function_resource_booking(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionResourceBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_resource_booking(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_resource_booking_id: ID of the FunctionResourceBooking you want to look up
        :return: list[FunctionResourceBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_function_resource_booking_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_function_resource_booking_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_function_resource_booking_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionResourceBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_resource_booking_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_resource_booking_id: ID of the FunctionResourceBooking you want to look up
        :return: list[FunctionResourceBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_resource_booking_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_function_resource_booking" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'function_resource_booking_id' in params:
            query_params.append(('FunctionResourceBookingID', params['function_resource_booking_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FunctionResourceBooking', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionResourceBookingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_function_resource_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionResourceType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_resource_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_resource_type_id: ID of the FunctionResourceType you want to look up
        :return: list[FunctionResourceTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_function_resource_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_function_resource_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_function_resource_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionResourceType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_resource_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_resource_type_id: ID of the FunctionResourceType you want to look up
        :return: list[FunctionResourceTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_resource_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_function_resource_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'function_resource_type_id' in params:
            query_params.append(('FunctionResourceTypeID', params['function_resource_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FunctionResourceType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionResourceTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_function_room(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionRoom in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_room(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_id: ID of the FunctionRoom you want to look up
        :return: list[FunctionRoomItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_function_room_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_function_room_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_function_room_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionRoom in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_room_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_id: ID of the FunctionRoom you want to look up
        :return: list[FunctionRoomItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_room_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_function_room" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'function_room_id' in params:
            query_params.append(('FunctionRoomID', params['function_room_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FunctionRoom', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionRoomItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_function_room_booking(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionRoomBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_room_booking(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_booking_id: ID of the FunctionRoomBooking you want to look up
        :return: list[FunctionRoomBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_function_room_booking_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_function_room_booking_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_function_room_booking_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionRoomBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_room_booking_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_booking_id: ID of the FunctionRoomBooking you want to look up
        :return: list[FunctionRoomBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_room_booking_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_function_room_booking" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'function_room_booking_id' in params:
            query_params.append(('FunctionRoomBookingID', params['function_room_booking_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FunctionRoomBooking', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionRoomBookingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_function_room_closed(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionRoomClosed in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_room_closed(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_closed_id: ID of the FunctionRoomClosed you want to look up
        :return: list[FunctionRoomClosedItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_function_room_closed_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_function_room_closed_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_function_room_closed_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionRoomClosed in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_room_closed_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_closed_id: ID of the FunctionRoomClosed you want to look up
        :return: list[FunctionRoomClosedItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_room_closed_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_function_room_closed" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'function_room_closed_id' in params:
            query_params.append(('FunctionRoomClosedID', params['function_room_closed_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FunctionRoomClosed', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionRoomClosedItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_function_room_location(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionRoomLocation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_room_location(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_location_id: ID of the FunctionRoomLocation you want to look up
        :return: list[FunctionRoomLocationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_function_room_location_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_function_room_location_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_function_room_location_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionRoomLocation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_room_location_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_location_id: ID of the FunctionRoomLocation you want to look up
        :return: list[FunctionRoomLocationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_room_location_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_function_room_location" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'function_room_location_id' in params:
            query_params.append(('FunctionRoomLocationID', params['function_room_location_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FunctionRoomLocation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionRoomLocationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_function_room_rate(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionRoomRate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_room_rate(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_rate_id: ID of the FunctionRoomRate you want to look up
        :return: list[FunctionRoomRateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_function_room_rate_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_function_room_rate_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_function_room_rate_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionRoomRate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_room_rate_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_rate_id: ID of the FunctionRoomRate you want to look up
        :return: list[FunctionRoomRateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_room_rate_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_function_room_rate" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'function_room_rate_id' in params:
            query_params.append(('FunctionRoomRateID', params['function_room_rate_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FunctionRoomRate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionRoomRateItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_function_room_setup(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionRoomSetup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_room_setup(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_setup_id: ID of the FunctionRoomSetup you want to look up
        :return: list[FunctionRoomSetupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_function_room_setup_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_function_room_setup_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_function_room_setup_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionRoomSetup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_room_setup_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_setup_id: ID of the FunctionRoomSetup you want to look up
        :return: list[FunctionRoomSetupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_room_setup_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_function_room_setup" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'function_room_setup_id' in params:
            query_params.append(('FunctionRoomSetupID', params['function_room_setup_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FunctionRoomSetup', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionRoomSetupItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_function_room_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionRoomType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_room_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_type_id: ID of the FunctionRoomType you want to look up
        :return: list[FunctionRoomTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_function_room_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_function_room_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_function_room_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionRoomType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_room_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_type_id: ID of the FunctionRoomType you want to look up
        :return: list[FunctionRoomTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_room_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_function_room_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'function_room_type_id' in params:
            query_params.append(('FunctionRoomTypeID', params['function_room_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FunctionRoomType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionRoomTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_function_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_type_id: ID of the FunctionType you want to look up
        :return: list[FunctionTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_function_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_function_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_function_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a FunctionType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_function_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_type_id: ID of the FunctionType you want to look up
        :return: list[FunctionTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_function_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'function_type_id' in params:
            query_params.append(('FunctionTypeID', params['function_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/FunctionType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_generic_table_data(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GenericTableData in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_generic_table_data(async=True)
        >>> result = thread.get()

        :param async bool
        :param int generic_table_data_id: ID of the GenericTableData you want to look up
        :return: list[GenericTableDataItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_generic_table_data_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_generic_table_data_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_generic_table_data_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GenericTableData in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_generic_table_data_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int generic_table_data_id: ID of the GenericTableData you want to look up
        :return: list[GenericTableDataItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['generic_table_data_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_generic_table_data" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'generic_table_data_id' in params:
            query_params.append(('GenericTableDataID', params['generic_table_data_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/GenericTableData', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GenericTableDataItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_generic_table_data_field(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GenericTableDataField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_generic_table_data_field(async=True)
        >>> result = thread.get()

        :param async bool
        :param int generic_table_data_field_id: ID of the GenericTableDataField you want to look up
        :return: list[GenericTableDataFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_generic_table_data_field_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_generic_table_data_field_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_generic_table_data_field_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GenericTableDataField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_generic_table_data_field_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int generic_table_data_field_id: ID of the GenericTableDataField you want to look up
        :return: list[GenericTableDataFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['generic_table_data_field_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_generic_table_data_field" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'generic_table_data_field_id' in params:
            query_params.append(('GenericTableDataFieldID', params['generic_table_data_field_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/GenericTableDataField', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GenericTableDataFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_generic_table_definition(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GenericTableDefinition in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_generic_table_definition(async=True)
        >>> result = thread.get()

        :param async bool
        :param int generic_table_definition_id: ID of the GenericTableDefinition you want to look up
        :return: list[GenericTableDefinitionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_generic_table_definition_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_generic_table_definition_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_generic_table_definition_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GenericTableDefinition in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_generic_table_definition_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int generic_table_definition_id: ID of the GenericTableDefinition you want to look up
        :return: list[GenericTableDefinitionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['generic_table_definition_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_generic_table_definition" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'generic_table_definition_id' in params:
            query_params.append(('GenericTableDefinitionID', params['generic_table_definition_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/GenericTableDefinition', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GenericTableDefinitionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_generic_table_definition_field(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GenericTableDefinitionField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_generic_table_definition_field(async=True)
        >>> result = thread.get()

        :param async bool
        :param int generic_table_definition_field_id: ID of the GenericTableDefinitionField you want to look up
        :return: list[GenericTableDefinitionFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_generic_table_definition_field_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_generic_table_definition_field_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_generic_table_definition_field_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GenericTableDefinitionField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_generic_table_definition_field_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int generic_table_definition_field_id: ID of the GenericTableDefinitionField you want to look up
        :return: list[GenericTableDefinitionFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['generic_table_definition_field_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_generic_table_definition_field" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'generic_table_definition_field_id' in params:
            query_params.append(('GenericTableDefinitionFieldID', params['generic_table_definition_field_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/GenericTableDefinitionField', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GenericTableDefinitionFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_gl_posting(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GLPosting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_gl_posting(async=True)
        >>> result = thread.get()

        :param async bool
        :param int gl_posting_id: ID of the GLPosting you want to look up
        :return: list[GLPostingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_gl_posting_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_gl_posting_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_gl_posting_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GLPosting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_gl_posting_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int gl_posting_id: ID of the GLPosting you want to look up
        :return: list[GLPostingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gl_posting_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_gl_posting" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'gl_posting_id' in params:
            query_params.append(('GLPostingID', params['gl_posting_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/GLPosting', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GLPostingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_group(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Group in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_group(async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_id: ID of the Group you want to look up
        :return: list[GroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_group_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_group_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_group_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Group in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_group_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_id: ID of the Group you want to look up
        :return: list[GroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_group" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'group_id' in params:
            query_params.append(('GroupID', params['group_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Group', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GroupItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_group_contact_entry(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GroupContactEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_group_contact_entry(async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_contact_entry_id: ID of the GroupContactEntry you want to look up
        :return: list[GroupContactEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_group_contact_entry_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_group_contact_entry_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_group_contact_entry_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GroupContactEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_group_contact_entry_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_contact_entry_id: ID of the GroupContactEntry you want to look up
        :return: list[GroupContactEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_contact_entry_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_group_contact_entry" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'group_contact_entry_id' in params:
            query_params.append(('GroupContactEntryID', params['group_contact_entry_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/GroupContactEntry', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GroupContactEntryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_group_custom_field(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GroupCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_group_custom_field(async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_custom_field_id: ID of the GroupCustomField you want to look up
        :return: list[GroupCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_group_custom_field_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_group_custom_field_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_group_custom_field_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GroupCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_group_custom_field_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_custom_field_id: ID of the GroupCustomField you want to look up
        :return: list[GroupCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_custom_field_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_group_custom_field" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'group_custom_field_id' in params:
            query_params.append(('GroupCustomFieldID', params['group_custom_field_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/GroupCustomField', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GroupCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_group_meal_plan(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GroupMealPlan in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_group_meal_plan(async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_meal_plan_id: ID of the GroupMealPlan you want to look up
        :return: list[GroupMealPlanItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_group_meal_plan_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_group_meal_plan_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_group_meal_plan_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GroupMealPlan in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_group_meal_plan_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_meal_plan_id: ID of the GroupMealPlan you want to look up
        :return: list[GroupMealPlanItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_meal_plan_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_group_meal_plan" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'group_meal_plan_id' in params:
            query_params.append(('GroupMealPlanID', params['group_meal_plan_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/GroupMealPlan', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GroupMealPlanItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_group_room_space(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GroupRoomSpace in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_group_room_space(async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_room_space_id: ID of the GroupRoomSpace you want to look up
        :return: list[GroupRoomSpaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_group_room_space_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_group_room_space_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_group_room_space_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GroupRoomSpace in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_group_room_space_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_room_space_id: ID of the GroupRoomSpace you want to look up
        :return: list[GroupRoomSpaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_room_space_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_group_room_space" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'group_room_space_id' in params:
            query_params.append(('GroupRoomSpaceID', params['group_room_space_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/GroupRoomSpace', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GroupRoomSpaceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_group_room_type_and_rates(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GroupRoomTypeAndRates in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_group_room_type_and_rates(async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_room_type_and_rates_id: ID of the GroupRoomTypeAndRates you want to look up
        :return: list[GroupRoomTypeAndRatesItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_group_room_type_and_rates_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_group_room_type_and_rates_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_group_room_type_and_rates_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a GroupRoomTypeAndRates in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_group_room_type_and_rates_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_room_type_and_rates_id: ID of the GroupRoomTypeAndRates you want to look up
        :return: list[GroupRoomTypeAndRatesItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_room_type_and_rates_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_group_room_type_and_rates" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'group_room_type_and_rates_id' in params:
            query_params.append(('GroupRoomTypeAndRatesID', params['group_room_type_and_rates_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/GroupRoomTypeAndRates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GroupRoomTypeAndRatesItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_housekeeping(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Housekeeping in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_housekeeping(async=True)
        >>> result = thread.get()

        :param async bool
        :param int housekeeping_id: ID of the Housekeeping you want to look up
        :return: list[HousekeepingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_housekeeping_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_housekeeping_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_housekeeping_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Housekeeping in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_housekeeping_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int housekeeping_id: ID of the Housekeeping you want to look up
        :return: list[HousekeepingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['housekeeping_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_housekeeping" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'housekeeping_id' in params:
            query_params.append(('HousekeepingID', params['housekeeping_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Housekeeping', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[HousekeepingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_housekeeping_schedule(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a HousekeepingSchedule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_housekeeping_schedule(async=True)
        >>> result = thread.get()

        :param async bool
        :param int housekeeping_schedule_id: ID of the HousekeepingSchedule you want to look up
        :return: list[HousekeepingScheduleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_housekeeping_schedule_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_housekeeping_schedule_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_housekeeping_schedule_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a HousekeepingSchedule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_housekeeping_schedule_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int housekeeping_schedule_id: ID of the HousekeepingSchedule you want to look up
        :return: list[HousekeepingScheduleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['housekeeping_schedule_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_housekeeping_schedule" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'housekeeping_schedule_id' in params:
            query_params.append(('HousekeepingScheduleID', params['housekeeping_schedule_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/HousekeepingSchedule', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[HousekeepingScheduleItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_housekeeping_schedule_skip(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a HousekeepingScheduleSkip in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_housekeeping_schedule_skip(async=True)
        >>> result = thread.get()

        :param async bool
        :param int housekeeping_schedule_skip_id: ID of the HousekeepingScheduleSkip you want to look up
        :return: list[HousekeepingScheduleSkipItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_housekeeping_schedule_skip_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_housekeeping_schedule_skip_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_housekeeping_schedule_skip_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a HousekeepingScheduleSkip in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_housekeeping_schedule_skip_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int housekeeping_schedule_skip_id: ID of the HousekeepingScheduleSkip you want to look up
        :return: list[HousekeepingScheduleSkipItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['housekeeping_schedule_skip_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_housekeeping_schedule_skip" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'housekeeping_schedule_skip_id' in params:
            query_params.append(('HousekeepingScheduleSkipID', params['housekeeping_schedule_skip_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/HousekeepingScheduleSkip', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[HousekeepingScheduleSkipItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Incident in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_id: ID of the Incident you want to look up
        :return: list[IncidentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Incident in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_id: ID of the Incident you want to look up
        :return: list[IncidentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_id' in params:
            query_params.append(('IncidentID', params['incident_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Incident', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_action(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_action(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_action_id: ID of the IncidentAction you want to look up
        :return: list[IncidentActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_action_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_action_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_action_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_action_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_action_id: ID of the IncidentAction you want to look up
        :return: list[IncidentActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_action_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_action" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_action_id' in params:
            query_params.append(('IncidentActionID', params['incident_action_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentAction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentActionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_action_entry(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentActionEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_action_entry(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_action_entry_id: ID of the IncidentActionEntry you want to look up
        :return: list[IncidentActionEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_action_entry_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_action_entry_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_action_entry_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentActionEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_action_entry_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_action_entry_id: ID of the IncidentActionEntry you want to look up
        :return: list[IncidentActionEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_action_entry_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_action_entry" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_action_entry_id' in params:
            query_params.append(('IncidentActionEntryID', params['incident_action_entry_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentActionEntry', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentActionEntryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_action_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentActionType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_action_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_action_type_id: ID of the IncidentActionType you want to look up
        :return: list[IncidentActionTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_action_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_action_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_action_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentActionType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_action_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_action_type_id: ID of the IncidentActionType you want to look up
        :return: list[IncidentActionTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_action_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_action_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_action_type_id' in params:
            query_params.append(('IncidentActionTypeID', params['incident_action_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentActionType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentActionTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_appeal_decision(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentAppealDecision in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_appeal_decision(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_appeal_decision_id: ID of the IncidentAppealDecision you want to look up
        :return: list[IncidentAppealDecisionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_appeal_decision_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_appeal_decision_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_appeal_decision_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentAppealDecision in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_appeal_decision_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_appeal_decision_id: ID of the IncidentAppealDecision you want to look up
        :return: list[IncidentAppealDecisionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_appeal_decision_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_appeal_decision" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_appeal_decision_id' in params:
            query_params.append(('IncidentAppealDecisionID', params['incident_appeal_decision_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentAppealDecision', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentAppealDecisionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_appeal_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentAppealType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_appeal_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_appeal_type_id: ID of the IncidentAppealType you want to look up
        :return: list[IncidentAppealTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_appeal_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_appeal_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_appeal_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentAppealType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_appeal_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_appeal_type_id: ID of the IncidentAppealType you want to look up
        :return: list[IncidentAppealTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_appeal_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_appeal_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_appeal_type_id' in params:
            query_params.append(('IncidentAppealTypeID', params['incident_appeal_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentAppealType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentAppealTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_clery_geography(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentCleryGeography in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_clery_geography(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_clery_geography_id: ID of the IncidentCleryGeography you want to look up
        :return: list[IncidentCleryGeographyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_clery_geography_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_clery_geography_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_clery_geography_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentCleryGeography in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_clery_geography_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_clery_geography_id: ID of the IncidentCleryGeography you want to look up
        :return: list[IncidentCleryGeographyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_clery_geography_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_clery_geography" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_clery_geography_id' in params:
            query_params.append(('IncidentCleryGeographyID', params['incident_clery_geography_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentCleryGeography', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentCleryGeographyItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_custom_field(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_custom_field(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_custom_field_id: ID of the IncidentCustomField you want to look up
        :return: list[IncidentCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_custom_field_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_custom_field_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_custom_field_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_custom_field_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_custom_field_id: ID of the IncidentCustomField you want to look up
        :return: list[IncidentCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_custom_field_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_custom_field" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_custom_field_id' in params:
            query_params.append(('IncidentCustomFieldID', params['incident_custom_field_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentCustomField', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_entry(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_entry(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_id: ID of the IncidentEntry you want to look up
        :return: list[IncidentEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_entry_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_entry_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_entry_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_entry_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_id: ID of the IncidentEntry you want to look up
        :return: list[IncidentEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_entry_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_entry" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_entry_id' in params:
            query_params.append(('IncidentEntryID', params['incident_entry_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentEntry', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentEntryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_entry_appeal(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentEntryAppeal in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_entry_appeal(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_appeal_id: ID of the IncidentEntryAppeal you want to look up
        :return: list[IncidentEntryAppealItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_entry_appeal_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_entry_appeal_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_entry_appeal_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentEntryAppeal in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_entry_appeal_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_appeal_id: ID of the IncidentEntryAppeal you want to look up
        :return: list[IncidentEntryAppealItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_entry_appeal_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_entry_appeal" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_entry_appeal_id' in params:
            query_params.append(('IncidentEntryAppealID', params['incident_entry_appeal_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentEntryAppeal', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentEntryAppealItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_entry_correspondence(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentEntryCorrespondence in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_entry_correspondence(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_correspondence_id: ID of the IncidentEntryCorrespondence you want to look up
        :return: list[IncidentEntryCorrespondenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_entry_correspondence_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_entry_correspondence_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_entry_correspondence_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentEntryCorrespondence in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_entry_correspondence_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_correspondence_id: ID of the IncidentEntryCorrespondence you want to look up
        :return: list[IncidentEntryCorrespondenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_entry_correspondence_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_entry_correspondence" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_entry_correspondence_id' in params:
            query_params.append(('IncidentEntryCorrespondenceID', params['incident_entry_correspondence_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentEntryCorrespondence', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentEntryCorrespondenceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_entry_note(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentEntryNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_entry_note(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_note_id: ID of the IncidentEntryNote you want to look up
        :return: list[IncidentEntryNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_entry_note_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_entry_note_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_entry_note_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentEntryNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_entry_note_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_note_id: ID of the IncidentEntryNote you want to look up
        :return: list[IncidentEntryNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_entry_note_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_entry_note" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_entry_note_id' in params:
            query_params.append(('IncidentEntryNoteID', params['incident_entry_note_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentEntryNote', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentEntryNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_entry_sanction(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentEntrySanction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_entry_sanction(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_sanction_id: ID of the IncidentEntrySanction you want to look up
        :return: list[IncidentEntrySanctionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_entry_sanction_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_entry_sanction_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_entry_sanction_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentEntrySanction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_entry_sanction_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_sanction_id: ID of the IncidentEntrySanction you want to look up
        :return: list[IncidentEntrySanctionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_entry_sanction_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_entry_sanction" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_entry_sanction_id' in params:
            query_params.append(('IncidentEntrySanctionID', params['incident_entry_sanction_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentEntrySanction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentEntrySanctionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_entry_violation(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentEntryViolation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_entry_violation(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_violation_id: ID of the IncidentEntryViolation you want to look up
        :return: list[IncidentEntryViolationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_entry_violation_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_entry_violation_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_entry_violation_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentEntryViolation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_entry_violation_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_violation_id: ID of the IncidentEntryViolation you want to look up
        :return: list[IncidentEntryViolationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_entry_violation_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_entry_violation" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_entry_violation_id' in params:
            query_params.append(('IncidentEntryViolationID', params['incident_entry_violation_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentEntryViolation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentEntryViolationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_finding(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentFinding in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_finding(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_finding_id: ID of the IncidentFinding you want to look up
        :return: list[IncidentFindingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_finding_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_finding_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_finding_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentFinding in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_finding_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_finding_id: ID of the IncidentFinding you want to look up
        :return: list[IncidentFindingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_finding_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_finding" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_finding_id' in params:
            query_params.append(('IncidentFindingID', params['incident_finding_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentFinding', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentFindingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_involvement(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentInvolvement in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_involvement(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_involvement_id: ID of the IncidentInvolvement you want to look up
        :return: list[IncidentInvolvementItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_involvement_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_involvement_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_involvement_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentInvolvement in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_involvement_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_involvement_id: ID of the IncidentInvolvement you want to look up
        :return: list[IncidentInvolvementItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_involvement_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_involvement" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_involvement_id' in params:
            query_params.append(('IncidentInvolvementID', params['incident_involvement_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentInvolvement', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentInvolvementItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_note(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_note(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_note_id: ID of the IncidentNote you want to look up
        :return: list[IncidentNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_note_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_note_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_note_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_note_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_note_id: ID of the IncidentNote you want to look up
        :return: list[IncidentNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_note_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_note" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_note_id' in params:
            query_params.append(('IncidentNoteID', params['incident_note_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentNote', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_plea(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentPlea in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_plea(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_plea_id: ID of the IncidentPlea you want to look up
        :return: list[IncidentPleaItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_plea_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_plea_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_plea_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentPlea in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_plea_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_plea_id: ID of the IncidentPlea you want to look up
        :return: list[IncidentPleaItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_plea_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_plea" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_plea_id' in params:
            query_params.append(('IncidentPleaID', params['incident_plea_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentPlea', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentPleaItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_sanction_sub_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentSanctionSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_sanction_sub_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_sanction_sub_type_id: ID of the IncidentSanctionSubType you want to look up
        :return: list[IncidentSanctionSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_sanction_sub_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_sanction_sub_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_sanction_sub_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentSanctionSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_sanction_sub_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_sanction_sub_type_id: ID of the IncidentSanctionSubType you want to look up
        :return: list[IncidentSanctionSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_sanction_sub_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_sanction_sub_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_sanction_sub_type_id' in params:
            query_params.append(('IncidentSanctionSubTypeID', params['incident_sanction_sub_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentSanctionSubType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentSanctionSubTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_sanction_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentSanctionType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_sanction_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_sanction_type_id: ID of the IncidentSanctionType you want to look up
        :return: list[IncidentSanctionTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_sanction_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_sanction_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_sanction_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentSanctionType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_sanction_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_sanction_type_id: ID of the IncidentSanctionType you want to look up
        :return: list[IncidentSanctionTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_sanction_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_sanction_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_sanction_type_id' in params:
            query_params.append(('IncidentSanctionTypeID', params['incident_sanction_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentSanctionType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentSanctionTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_severity(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentSeverity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_severity(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_severity_id: ID of the IncidentSeverity you want to look up
        :return: list[IncidentSeverityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_severity_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_severity_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_severity_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentSeverity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_severity_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_severity_id: ID of the IncidentSeverity you want to look up
        :return: list[IncidentSeverityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_severity_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_severity" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_severity_id' in params:
            query_params.append(('IncidentSeverityID', params['incident_severity_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentSeverity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentSeverityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_status(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_status(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_status_id: ID of the IncidentStatus you want to look up
        :return: list[IncidentStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_status_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_status_id: ID of the IncidentStatus you want to look up
        :return: list[IncidentStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_status_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_status_id' in params:
            query_params.append(('IncidentStatusID', params['incident_status_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentStatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentStatusItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_sub_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_sub_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_sub_type_id: ID of the IncidentSubType you want to look up
        :return: list[IncidentSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_sub_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_sub_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_sub_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_sub_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_sub_type_id: ID of the IncidentSubType you want to look up
        :return: list[IncidentSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_sub_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_sub_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_sub_type_id' in params:
            query_params.append(('IncidentSubTypeID', params['incident_sub_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentSubType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentSubTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_type_id: ID of the IncidentType you want to look up
        :return: list[IncidentTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_type_id: ID of the IncidentType you want to look up
        :return: list[IncidentTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_type_id' in params:
            query_params.append(('IncidentTypeID', params['incident_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_incident_violation(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentViolation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_violation(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_violation_id: ID of the IncidentViolation you want to look up
        :return: list[IncidentViolationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_incident_violation_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_incident_violation_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_incident_violation_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a IncidentViolation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_incident_violation_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_violation_id: ID of the IncidentViolation you want to look up
        :return: list[IncidentViolationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_violation_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_incident_violation" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'incident_violation_id' in params:
            query_params.append(('IncidentViolationID', params['incident_violation_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/IncidentViolation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentViolationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_inspection_run_template(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a InspectionRunTemplate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_inspection_run_template(async=True)
        >>> result = thread.get()

        :param async bool
        :param int inspection_run_template_id: ID of the InspectionRunTemplate you want to look up
        :return: list[InspectionRunTemplateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_inspection_run_template_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_inspection_run_template_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_inspection_run_template_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a InspectionRunTemplate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_inspection_run_template_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int inspection_run_template_id: ID of the InspectionRunTemplate you want to look up
        :return: list[InspectionRunTemplateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['inspection_run_template_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_inspection_run_template" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'inspection_run_template_id' in params:
            query_params.append(('InspectionRunTemplateID', params['inspection_run_template_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/InspectionRunTemplate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InspectionRunTemplateItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_interface(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Interface in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_interface(async=True)
        >>> result = thread.get()

        :param async bool
        :param int interface_id: ID of the Interface you want to look up
        :return: list[InterfaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_interface_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_interface_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_interface_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Interface in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_interface_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int interface_id: ID of the Interface you want to look up
        :return: list[InterfaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interface_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_interface" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'interface_id' in params:
            query_params.append(('InterfaceID', params['interface_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Interface', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InterfaceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_interface_application(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a InterfaceApplication in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_interface_application(async=True)
        >>> result = thread.get()

        :param async bool
        :param int interface_application_id: ID of the InterfaceApplication you want to look up
        :return: list[InterfaceApplicationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_interface_application_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_interface_application_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_interface_application_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a InterfaceApplication in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_interface_application_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int interface_application_id: ID of the InterfaceApplication you want to look up
        :return: list[InterfaceApplicationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interface_application_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_interface_application" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'interface_application_id' in params:
            query_params.append(('InterfaceApplicationID', params['interface_application_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/InterfaceApplication', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InterfaceApplicationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_interface_subscribe(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a InterfaceSubscribe in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_interface_subscribe(async=True)
        >>> result = thread.get()

        :param async bool
        :param int interface_subscribe_id: ID of the InterfaceSubscribe you want to look up
        :return: list[InterfaceSubscribeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_interface_subscribe_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_interface_subscribe_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_interface_subscribe_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a InterfaceSubscribe in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_interface_subscribe_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int interface_subscribe_id: ID of the InterfaceSubscribe you want to look up
        :return: list[InterfaceSubscribeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interface_subscribe_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_interface_subscribe" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'interface_subscribe_id' in params:
            query_params.append(('InterfaceSubscribeID', params['interface_subscribe_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/InterfaceSubscribe', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InterfaceSubscribeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_invoice(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Invoice in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_invoice(async=True)
        >>> result = thread.get()

        :param async bool
        :param int invoice_id: ID of the Invoice you want to look up
        :return: list[InvoiceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_invoice_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_invoice_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_invoice_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Invoice in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_invoice_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int invoice_id: ID of the Invoice you want to look up
        :return: list[InvoiceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['invoice_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_invoice" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'invoice_id' in params:
            query_params.append(('InvoiceID', params['invoice_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Invoice', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InvoiceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_log_activity(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a LogActivity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_log_activity(async=True)
        >>> result = thread.get()

        :param async bool
        :param int log_activity_id: ID of the LogActivity you want to look up
        :return: list[LogActivityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_log_activity_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_log_activity_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_log_activity_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a LogActivity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_log_activity_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int log_activity_id: ID of the LogActivity you want to look up
        :return: list[LogActivityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['log_activity_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_log_activity" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'log_activity_id' in params:
            query_params.append(('LogActivityID', params['log_activity_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/LogActivity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LogActivityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_log_add_in(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a LogAddIn in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_log_add_in(async=True)
        >>> result = thread.get()

        :param async bool
        :param int log_add_in_id: ID of the LogAddIn you want to look up
        :return: list[LogAddInItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_log_add_in_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_log_add_in_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_log_add_in_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a LogAddIn in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_log_add_in_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int log_add_in_id: ID of the LogAddIn you want to look up
        :return: list[LogAddInItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['log_add_in_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_log_add_in" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'log_add_in_id' in params:
            query_params.append(('LogAddInID', params['log_add_in_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/LogAddIn', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LogAddInItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_log_interface(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a LogInterface in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_log_interface(async=True)
        >>> result = thread.get()

        :param async bool
        :param int log_interface_id: ID of the LogInterface you want to look up
        :return: list[LogInterfaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_log_interface_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_log_interface_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_log_interface_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a LogInterface in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_log_interface_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int log_interface_id: ID of the LogInterface you want to look up
        :return: list[LogInterfaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['log_interface_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_log_interface" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'log_interface_id' in params:
            query_params.append(('LogInterfaceID', params['log_interface_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/LogInterface', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LogInterfaceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_log_metric(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a LogMetric in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_log_metric(async=True)
        >>> result = thread.get()

        :param async bool
        :param int log_metric_id: ID of the LogMetric you want to look up
        :return: list[LogMetricItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_log_metric_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_log_metric_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_log_metric_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a LogMetric in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_log_metric_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int log_metric_id: ID of the LogMetric you want to look up
        :return: list[LogMetricItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['log_metric_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_log_metric" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'log_metric_id' in params:
            query_params.append(('LogMetricID', params['log_metric_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/LogMetric', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LogMetricItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_lookup(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Lookup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_lookup(async=True)
        >>> result = thread.get()

        :param async bool
        :param int lookup_id: ID of the Lookup you want to look up
        :return: list[LookupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_lookup_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_lookup_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_lookup_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Lookup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_lookup_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int lookup_id: ID of the Lookup you want to look up
        :return: list[LookupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lookup_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_lookup" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'lookup_id' in params:
            query_params.append(('LookupID', params['lookup_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Lookup', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LookupItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_lookup_text(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a LookupText in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_lookup_text(async=True)
        >>> result = thread.get()

        :param async bool
        :param int lookup_text_id: ID of the LookupText you want to look up
        :return: list[LookupTextItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_lookup_text_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_lookup_text_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_lookup_text_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a LookupText in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_lookup_text_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int lookup_text_id: ID of the LookupText you want to look up
        :return: list[LookupTextItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lookup_text_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_lookup_text" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'lookup_text_id' in params:
            query_params.append(('LookupTextID', params['lookup_text_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/LookupText', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LookupTextItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_mail_merge(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MailMerge in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_mail_merge(async=True)
        >>> result = thread.get()

        :param async bool
        :param int mail_merge_id: ID of the MailMerge you want to look up
        :return: list[MailMergeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_mail_merge_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_mail_merge_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_mail_merge_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MailMerge in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_mail_merge_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int mail_merge_id: ID of the MailMerge you want to look up
        :return: list[MailMergeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mail_merge_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_mail_merge" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'mail_merge_id' in params:
            query_params.append(('MailMergeID', params['mail_merge_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/MailMerge', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MailMergeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_meal_plan(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MealPlan in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_meal_plan(async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_id: ID of the MealPlan you want to look up
        :return: list[MealPlanItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_meal_plan_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_meal_plan_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_meal_plan_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MealPlan in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_meal_plan_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_id: ID of the MealPlan you want to look up
        :return: list[MealPlanItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meal_plan_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_meal_plan" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'meal_plan_id' in params:
            query_params.append(('MealPlanID', params['meal_plan_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/MealPlan', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MealPlanItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_meal_plan_detail(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MealPlanDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_meal_plan_detail(async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_detail_id: ID of the MealPlanDetail you want to look up
        :return: list[MealPlanDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_meal_plan_detail_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_meal_plan_detail_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_meal_plan_detail_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MealPlanDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_meal_plan_detail_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_detail_id: ID of the MealPlanDetail you want to look up
        :return: list[MealPlanDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meal_plan_detail_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_meal_plan_detail" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'meal_plan_detail_id' in params:
            query_params.append(('MealPlanDetailID', params['meal_plan_detail_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/MealPlanDetail', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MealPlanDetailItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_meal_plan_dining_hall(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MealPlanDiningHall in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_meal_plan_dining_hall(async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_dining_hall_id: ID of the MealPlanDiningHall you want to look up
        :return: list[MealPlanDiningHallItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_meal_plan_dining_hall_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_meal_plan_dining_hall_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_meal_plan_dining_hall_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MealPlanDiningHall in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_meal_plan_dining_hall_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_dining_hall_id: ID of the MealPlanDiningHall you want to look up
        :return: list[MealPlanDiningHallItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meal_plan_dining_hall_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_meal_plan_dining_hall" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'meal_plan_dining_hall_id' in params:
            query_params.append(('MealPlanDiningHallID', params['meal_plan_dining_hall_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/MealPlanDiningHall', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MealPlanDiningHallItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_meal_plan_free(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MealPlanFree in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_meal_plan_free(async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_free_id: ID of the MealPlanFree you want to look up
        :return: list[MealPlanFreeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_meal_plan_free_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_meal_plan_free_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_meal_plan_free_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MealPlanFree in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_meal_plan_free_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_free_id: ID of the MealPlanFree you want to look up
        :return: list[MealPlanFreeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meal_plan_free_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_meal_plan_free" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'meal_plan_free_id' in params:
            query_params.append(('MealPlanFreeID', params['meal_plan_free_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/MealPlanFree', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MealPlanFreeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_meal_plan_session(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MealPlanSession in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_meal_plan_session(async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_session_id: ID of the MealPlanSession you want to look up
        :return: list[MealPlanSessionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_meal_plan_session_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_meal_plan_session_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_meal_plan_session_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MealPlanSession in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_meal_plan_session_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_session_id: ID of the MealPlanSession you want to look up
        :return: list[MealPlanSessionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meal_plan_session_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_meal_plan_session" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'meal_plan_session_id' in params:
            query_params.append(('MealPlanSessionID', params['meal_plan_session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/MealPlanSession', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MealPlanSessionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_meal_pricing(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MealPricing in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_meal_pricing(async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_pricing_id: ID of the MealPricing you want to look up
        :return: list[MealPricingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_meal_pricing_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_meal_pricing_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_meal_pricing_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MealPricing in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_meal_pricing_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_pricing_id: ID of the MealPricing you want to look up
        :return: list[MealPricingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meal_pricing_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_meal_pricing" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'meal_pricing_id' in params:
            query_params.append(('MealPricingID', params['meal_pricing_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/MealPricing', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MealPricingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_membership_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MembershipType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_membership_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int membership_type_id: ID of the MembershipType you want to look up
        :return: list[MembershipTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_membership_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_membership_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_membership_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MembershipType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_membership_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int membership_type_id: ID of the MembershipType you want to look up
        :return: list[MembershipTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['membership_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_membership_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'membership_type_id' in params:
            query_params.append(('MembershipTypeID', params['membership_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/MembershipType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MembershipTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_message(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Message in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_message(async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_id: ID of the Message you want to look up
        :return: list[MessageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_message_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_message_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_message_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Message in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_message_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_id: ID of the Message you want to look up
        :return: list[MessageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['message_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_message" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'message_id' in params:
            query_params.append(('MessageID', params['message_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Message', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MessageItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_message_action(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MessageAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_message_action(async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_action_id: ID of the MessageAction you want to look up
        :return: list[MessageActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_message_action_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_message_action_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_message_action_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MessageAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_message_action_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_action_id: ID of the MessageAction you want to look up
        :return: list[MessageActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['message_action_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_message_action" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'message_action_id' in params:
            query_params.append(('MessageActionID', params['message_action_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/MessageAction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MessageActionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_message_subscriber(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MessageSubscriber in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_message_subscriber(async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_subscriber_id: ID of the MessageSubscriber you want to look up
        :return: list[MessageSubscriberItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_message_subscriber_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_message_subscriber_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_message_subscriber_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MessageSubscriber in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_message_subscriber_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_subscriber_id: ID of the MessageSubscriber you want to look up
        :return: list[MessageSubscriberItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['message_subscriber_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_message_subscriber" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'message_subscriber_id' in params:
            query_params.append(('MessageSubscriberID', params['message_subscriber_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/MessageSubscriber', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MessageSubscriberItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_message_subscription(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MessageSubscription in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_message_subscription(async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_subscription_id: ID of the MessageSubscription you want to look up
        :return: list[MessageSubscriptionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_message_subscription_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_message_subscription_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_message_subscription_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MessageSubscription in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_message_subscription_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_subscription_id: ID of the MessageSubscription you want to look up
        :return: list[MessageSubscriptionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['message_subscription_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_message_subscription" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'message_subscription_id' in params:
            query_params.append(('MessageSubscriptionID', params['message_subscription_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/MessageSubscription', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MessageSubscriptionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_message_subscription_settings(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MessageSubscriptionSettings in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_message_subscription_settings(async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_subscription_settings_id: ID of the MessageSubscriptionSettings you want to look up
        :return: list[MessageSubscriptionSettingsItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_message_subscription_settings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_message_subscription_settings_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_message_subscription_settings_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a MessageSubscriptionSettings in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_message_subscription_settings_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_subscription_settings_id: ID of the MessageSubscriptionSettings you want to look up
        :return: list[MessageSubscriptionSettingsItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['message_subscription_settings_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_message_subscription_settings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'message_subscription_settings_id' in params:
            query_params.append(('MessageSubscriptionSettingsID', params['message_subscription_settings_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/MessageSubscriptionSettings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MessageSubscriptionSettingsItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_nationality(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Nationality in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_nationality(async=True)
        >>> result = thread.get()

        :param async bool
        :param int nationality_id: ID of the Nationality you want to look up
        :return: list[NationalityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_nationality_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_nationality_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_nationality_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Nationality in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_nationality_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int nationality_id: ID of the Nationality you want to look up
        :return: list[NationalityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['nationality_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_nationality" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'nationality_id' in params:
            query_params.append(('NationalityID', params['nationality_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Nationality', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NationalityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_note_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a NoteType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_note_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int note_type_id: ID of the NoteType you want to look up
        :return: list[NoteTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_note_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_note_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_note_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a NoteType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_note_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int note_type_id: ID of the NoteType you want to look up
        :return: list[NoteTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['note_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_note_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'note_type_id' in params:
            query_params.append(('NoteTypeID', params['note_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/NoteType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NoteTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_parcel_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ParcelType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_parcel_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int parcel_type_id: ID of the ParcelType you want to look up
        :return: list[ParcelTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_parcel_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_parcel_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_parcel_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ParcelType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_parcel_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int parcel_type_id: ID of the ParcelType you want to look up
        :return: list[ParcelTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['parcel_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_parcel_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'parcel_type_id' in params:
            query_params.append(('ParcelTypeID', params['parcel_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ParcelType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ParcelTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_payment(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Payment in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_payment(async=True)
        >>> result = thread.get()

        :param async bool
        :param int payment_id: ID of the Payment you want to look up
        :return: list[PaymentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_payment_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_payment_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_payment_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Payment in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_payment_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int payment_id: ID of the Payment you want to look up
        :return: list[PaymentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payment_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_payment" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'payment_id' in params:
            query_params.append(('PaymentID', params['payment_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Payment', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PaymentItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_payment_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PaymentType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_payment_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int payment_type_id: ID of the PaymentType you want to look up
        :return: list[PaymentTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_payment_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_payment_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_payment_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PaymentType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_payment_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int payment_type_id: ID of the PaymentType you want to look up
        :return: list[PaymentTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payment_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_payment_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'payment_type_id' in params:
            query_params.append(('PaymentTypeID', params['payment_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PaymentType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PaymentTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_phone_charge_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PhoneChargeType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_phone_charge_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int phone_charge_type_id: ID of the PhoneChargeType you want to look up
        :return: list[PhoneChargeTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_phone_charge_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_phone_charge_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_phone_charge_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PhoneChargeType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_phone_charge_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int phone_charge_type_id: ID of the PhoneChargeType you want to look up
        :return: list[PhoneChargeTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['phone_charge_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_phone_charge_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'phone_charge_type_id' in params:
            query_params.append(('PhoneChargeTypeID', params['phone_charge_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PhoneChargeType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PhoneChargeTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_phone_charge_type_call_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PhoneChargeTypeCallType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_phone_charge_type_call_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int phone_charge_type_call_type_id: ID of the PhoneChargeTypeCallType you want to look up
        :return: list[PhoneChargeTypeCallTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_phone_charge_type_call_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_phone_charge_type_call_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_phone_charge_type_call_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PhoneChargeTypeCallType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_phone_charge_type_call_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int phone_charge_type_call_type_id: ID of the PhoneChargeTypeCallType you want to look up
        :return: list[PhoneChargeTypeCallTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['phone_charge_type_call_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_phone_charge_type_call_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'phone_charge_type_call_type_id' in params:
            query_params.append(('PhoneChargeTypeCallTypeID', params['phone_charge_type_call_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PhoneChargeTypeCallType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PhoneChargeTypeCallTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_portal_action(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_action(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_action_id: ID of the PortalAction you want to look up
        :return: list[PortalActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_portal_action_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_portal_action_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_portal_action_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_action_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_action_id: ID of the PortalAction you want to look up
        :return: list[PortalActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_action_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_portal_action" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'portal_action_id' in params:
            query_params.append(('PortalActionID', params['portal_action_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PortalAction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalActionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_portal_activity(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalActivity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_activity(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_activity_id: ID of the PortalActivity you want to look up
        :return: list[PortalActivityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_portal_activity_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_portal_activity_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_portal_activity_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalActivity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_activity_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_activity_id: ID of the PortalActivity you want to look up
        :return: list[PortalActivityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_activity_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_portal_activity" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'portal_activity_id' in params:
            query_params.append(('PortalActivityID', params['portal_activity_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PortalActivity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalActivityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_portal_choice(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalChoice in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_choice(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_choice_id: ID of the PortalChoice you want to look up
        :return: list[PortalChoiceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_portal_choice_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_portal_choice_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_portal_choice_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalChoice in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_choice_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_choice_id: ID of the PortalChoice you want to look up
        :return: list[PortalChoiceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_choice_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_portal_choice" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'portal_choice_id' in params:
            query_params.append(('PortalChoiceID', params['portal_choice_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PortalChoice', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalChoiceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_portal_page(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalPage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_page(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_page_id: ID of the PortalPage you want to look up
        :return: list[PortalPageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_portal_page_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_portal_page_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_portal_page_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalPage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_page_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_page_id: ID of the PortalPage you want to look up
        :return: list[PortalPageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_page_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_portal_page" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'portal_page_id' in params:
            query_params.append(('PortalPageID', params['portal_page_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PortalPage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalPageItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_portal_page_action(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalPageAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_page_action(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_page_action_id: ID of the PortalPageAction you want to look up
        :return: list[PortalPageActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_portal_page_action_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_portal_page_action_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_portal_page_action_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalPageAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_page_action_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_page_action_id: ID of the PortalPageAction you want to look up
        :return: list[PortalPageActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_page_action_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_portal_page_action" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'portal_page_action_id' in params:
            query_params.append(('PortalPageActionID', params['portal_page_action_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PortalPageAction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalPageActionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_portal_page_widget(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalPageWidget in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_page_widget(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_page_widget_id: ID of the PortalPageWidget you want to look up
        :return: list[PortalPageWidgetItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_portal_page_widget_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_portal_page_widget_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_portal_page_widget_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalPageWidget in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_page_widget_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_page_widget_id: ID of the PortalPageWidget you want to look up
        :return: list[PortalPageWidgetItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_page_widget_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_portal_page_widget" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'portal_page_widget_id' in params:
            query_params.append(('PortalPageWidgetID', params['portal_page_widget_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PortalPageWidget', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalPageWidgetItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_portal_process(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalProcess in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_process(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_process_id: ID of the PortalProcess you want to look up
        :return: list[PortalProcessItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_portal_process_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_portal_process_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_portal_process_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalProcess in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_process_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_process_id: ID of the PortalProcess you want to look up
        :return: list[PortalProcessItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_process_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_portal_process" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'portal_process_id' in params:
            query_params.append(('PortalProcessID', params['portal_process_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PortalProcess', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalProcessItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_portal_rule(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalRule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_rule(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_rule_id: ID of the PortalRule you want to look up
        :return: list[PortalRuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_portal_rule_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_portal_rule_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_portal_rule_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalRule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_rule_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_rule_id: ID of the PortalRule you want to look up
        :return: list[PortalRuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_rule_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_portal_rule" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'portal_rule_id' in params:
            query_params.append(('PortalRuleID', params['portal_rule_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PortalRule', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalRuleItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_portal_rule_link(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalRuleLink in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_rule_link(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_rule_link_id: ID of the PortalRuleLink you want to look up
        :return: list[PortalRuleLinkItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_portal_rule_link_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_portal_rule_link_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_portal_rule_link_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalRuleLink in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_rule_link_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_rule_link_id: ID of the PortalRuleLink you want to look up
        :return: list[PortalRuleLinkItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_rule_link_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_portal_rule_link" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'portal_rule_link_id' in params:
            query_params.append(('PortalRuleLinkID', params['portal_rule_link_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PortalRuleLink', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalRuleLinkItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_portal_setting(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalSetting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_setting(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_setting_id: ID of the PortalSetting you want to look up
        :return: list[PortalSettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_portal_setting_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_portal_setting_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_portal_setting_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalSetting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_setting_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_setting_id: ID of the PortalSetting you want to look up
        :return: list[PortalSettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_setting_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_portal_setting" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'portal_setting_id' in params:
            query_params.append(('PortalSettingID', params['portal_setting_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PortalSetting', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalSettingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_portal_site(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalSite in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_site(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_site_id: ID of the PortalSite you want to look up
        :return: list[PortalSiteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_portal_site_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_portal_site_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_portal_site_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalSite in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_site_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_site_id: ID of the PortalSite you want to look up
        :return: list[PortalSiteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_site_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_portal_site" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'portal_site_id' in params:
            query_params.append(('PortalSiteID', params['portal_site_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PortalSite', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalSiteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_portal_step(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalStep in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_step(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_step_id: ID of the PortalStep you want to look up
        :return: list[PortalStepItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_portal_step_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_portal_step_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_portal_step_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalStep in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_step_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_step_id: ID of the PortalStep you want to look up
        :return: list[PortalStepItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_step_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_portal_step" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'portal_step_id' in params:
            query_params.append(('PortalStepID', params['portal_step_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PortalStep', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalStepItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_portal_step_link(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalStepLink in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_step_link(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_step_link_id: ID of the PortalStepLink you want to look up
        :return: list[PortalStepLinkItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_portal_step_link_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_portal_step_link_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_portal_step_link_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalStepLink in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_step_link_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_step_link_id: ID of the PortalStepLink you want to look up
        :return: list[PortalStepLinkItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_step_link_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_portal_step_link" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'portal_step_link_id' in params:
            query_params.append(('PortalStepLinkID', params['portal_step_link_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PortalStepLink', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalStepLinkItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_portal_theme(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalTheme in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_theme(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_theme_id: ID of the PortalTheme you want to look up
        :return: list[PortalThemeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_portal_theme_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_portal_theme_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_portal_theme_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalTheme in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_theme_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_theme_id: ID of the PortalTheme you want to look up
        :return: list[PortalThemeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_theme_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_portal_theme" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'portal_theme_id' in params:
            query_params.append(('PortalThemeID', params['portal_theme_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PortalTheme', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalThemeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_portal_user_hold(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalUserHold in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_user_hold(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_user_hold_id: ID of the PortalUserHold you want to look up
        :return: list[PortalUserHoldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_portal_user_hold_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_portal_user_hold_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_portal_user_hold_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalUserHold in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_user_hold_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_user_hold_id: ID of the PortalUserHold you want to look up
        :return: list[PortalUserHoldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_user_hold_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_portal_user_hold" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'portal_user_hold_id' in params:
            query_params.append(('PortalUserHoldID', params['portal_user_hold_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PortalUserHold', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalUserHoldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_portal_user_signature(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalUserSignature in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_user_signature(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_user_signature_id: ID of the PortalUserSignature you want to look up
        :return: list[PortalUserSignatureItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_portal_user_signature_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_portal_user_signature_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_portal_user_signature_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalUserSignature in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_user_signature_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_user_signature_id: ID of the PortalUserSignature you want to look up
        :return: list[PortalUserSignatureItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_user_signature_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_portal_user_signature" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'portal_user_signature_id' in params:
            query_params.append(('PortalUserSignatureID', params['portal_user_signature_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PortalUserSignature', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalUserSignatureItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_portal_user_token(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalUserToken in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_user_token(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_user_token_id: ID of the PortalUserToken you want to look up
        :return: list[PortalUserTokenItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_portal_user_token_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_portal_user_token_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_portal_user_token_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PortalUserToken in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_portal_user_token_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_user_token_id: ID of the PortalUserToken you want to look up
        :return: list[PortalUserTokenItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_user_token_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_portal_user_token" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'portal_user_token_id' in params:
            query_params.append(('PortalUserTokenID', params['portal_user_token_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PortalUserToken', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalUserTokenItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_preference(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Preference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_preference(async=True)
        >>> result = thread.get()

        :param async bool
        :param int preference_id: ID of the Preference you want to look up
        :return: list[PreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_preference_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_preference_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_preference_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Preference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_preference_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int preference_id: ID of the Preference you want to look up
        :return: list[PreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['preference_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_preference" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'preference_id' in params:
            query_params.append(('PreferenceID', params['preference_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Preference', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PreferenceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_priority(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Priority in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_priority(async=True)
        >>> result = thread.get()

        :param async bool
        :param int priority_id: ID of the Priority you want to look up
        :return: list[PriorityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_priority_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_priority_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_priority_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Priority in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_priority_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int priority_id: ID of the Priority you want to look up
        :return: list[PriorityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['priority_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_priority" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'priority_id' in params:
            query_params.append(('PriorityID', params['priority_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Priority', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PriorityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_process(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Process in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_process(async=True)
        >>> result = thread.get()

        :param async bool
        :param int process_id: ID of the Process you want to look up
        :return: list[ProcessItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_process_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_process_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_process_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Process in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_process_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int process_id: ID of the Process you want to look up
        :return: list[ProcessItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['process_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_process" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'process_id' in params:
            query_params.append(('ProcessID', params['process_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Process', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProcessItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_profile_item(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ProfileItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_profile_item(async=True)
        >>> result = thread.get()

        :param async bool
        :param int profile_item_id: ID of the ProfileItem you want to look up
        :return: list[ProfileItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_profile_item_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_profile_item_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_profile_item_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ProfileItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_profile_item_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int profile_item_id: ID of the ProfileItem you want to look up
        :return: list[ProfileItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['profile_item_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_profile_item" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'profile_item_id' in params:
            query_params.append(('ProfileItemID', params['profile_item_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ProfileItem', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProfileItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_profile_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ProfileType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_profile_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int profile_type_id: ID of the ProfileType you want to look up
        :return: list[ProfileTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_profile_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_profile_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_profile_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ProfileType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_profile_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int profile_type_id: ID of the ProfileType you want to look up
        :return: list[ProfileTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['profile_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_profile_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'profile_type_id' in params:
            query_params.append(('ProfileTypeID', params['profile_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ProfileType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProfileTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_program(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Program in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_program(async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_id: ID of the Program you want to look up
        :return: list[ProgramItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_program_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_program_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_program_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Program in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_program_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_id: ID of the Program you want to look up
        :return: list[ProgramItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_program" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'program_id' in params:
            query_params.append(('ProgramID', params['program_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Program', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProgramItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_program_custom_field(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ProgramCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_program_custom_field(async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_custom_field_id: ID of the ProgramCustomField you want to look up
        :return: list[ProgramCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_program_custom_field_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_program_custom_field_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_program_custom_field_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ProgramCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_program_custom_field_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_custom_field_id: ID of the ProgramCustomField you want to look up
        :return: list[ProgramCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_custom_field_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_program_custom_field" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'program_custom_field_id' in params:
            query_params.append(('ProgramCustomFieldID', params['program_custom_field_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ProgramCustomField', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProgramCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_program_entry(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ProgramEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_program_entry(async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_entry_id: ID of the ProgramEntry you want to look up
        :return: list[ProgramEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_program_entry_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_program_entry_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_program_entry_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ProgramEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_program_entry_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_entry_id: ID of the ProgramEntry you want to look up
        :return: list[ProgramEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_entry_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_program_entry" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'program_entry_id' in params:
            query_params.append(('ProgramEntryID', params['program_entry_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ProgramEntry', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProgramEntryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_program_evaluation_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ProgramEvaluationType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_program_evaluation_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_evaluation_type_id: ID of the ProgramEvaluationType you want to look up
        :return: list[ProgramEvaluationTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_program_evaluation_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_program_evaluation_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_program_evaluation_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ProgramEvaluationType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_program_evaluation_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_evaluation_type_id: ID of the ProgramEvaluationType you want to look up
        :return: list[ProgramEvaluationTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_evaluation_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_program_evaluation_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'program_evaluation_type_id' in params:
            query_params.append(('ProgramEvaluationTypeID', params['program_evaluation_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ProgramEvaluationType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProgramEvaluationTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_program_note(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ProgramNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_program_note(async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_note_id: ID of the ProgramNote you want to look up
        :return: list[ProgramNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_program_note_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_program_note_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_program_note_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ProgramNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_program_note_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_note_id: ID of the ProgramNote you want to look up
        :return: list[ProgramNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_note_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_program_note" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'program_note_id' in params:
            query_params.append(('ProgramNoteID', params['program_note_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ProgramNote', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProgramNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_program_sub_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ProgramSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_program_sub_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_sub_type_id: ID of the ProgramSubType you want to look up
        :return: list[ProgramSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_program_sub_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_program_sub_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_program_sub_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ProgramSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_program_sub_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_sub_type_id: ID of the ProgramSubType you want to look up
        :return: list[ProgramSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_sub_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_program_sub_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'program_sub_type_id' in params:
            query_params.append(('ProgramSubTypeID', params['program_sub_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ProgramSubType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProgramSubTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_program_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ProgramType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_program_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_type_id: ID of the ProgramType you want to look up
        :return: list[ProgramTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_program_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_program_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_program_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ProgramType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_program_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_type_id: ID of the ProgramType you want to look up
        :return: list[ProgramTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_program_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'program_type_id' in params:
            query_params.append(('ProgramTypeID', params['program_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ProgramType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProgramTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_promo_code(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PromoCode in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_promo_code(async=True)
        >>> result = thread.get()

        :param async bool
        :param int promo_code_id: ID of the PromoCode you want to look up
        :return: list[PromoCodeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_promo_code_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_promo_code_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_promo_code_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PromoCode in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_promo_code_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int promo_code_id: ID of the PromoCode you want to look up
        :return: list[PromoCodeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['promo_code_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_promo_code" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'promo_code_id' in params:
            query_params.append(('PromoCodeID', params['promo_code_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PromoCode', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PromoCodeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_promo_code_record(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PromoCodeRecord in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_promo_code_record(async=True)
        >>> result = thread.get()

        :param async bool
        :param int promo_code_record_id: ID of the PromoCodeRecord you want to look up
        :return: list[PromoCodeRecordItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_promo_code_record_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_promo_code_record_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_promo_code_record_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PromoCodeRecord in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_promo_code_record_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int promo_code_record_id: ID of the PromoCodeRecord you want to look up
        :return: list[PromoCodeRecordItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['promo_code_record_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_promo_code_record" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'promo_code_record_id' in params:
            query_params.append(('PromoCodeRecordID', params['promo_code_record_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PromoCodeRecord', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PromoCodeRecordItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_promo_code_usage(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PromoCodeUsage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_promo_code_usage(async=True)
        >>> result = thread.get()

        :param async bool
        :param int promo_code_usage_id: ID of the PromoCodeUsage you want to look up
        :return: list[PromoCodeUsageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_promo_code_usage_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_promo_code_usage_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_promo_code_usage_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a PromoCodeUsage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_promo_code_usage_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int promo_code_usage_id: ID of the PromoCodeUsage you want to look up
        :return: list[PromoCodeUsageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['promo_code_usage_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_promo_code_usage" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'promo_code_usage_id' in params:
            query_params.append(('PromoCodeUsageID', params['promo_code_usage_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/PromoCodeUsage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PromoCodeUsageItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_record_attachment(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RecordAttachment in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_record_attachment(async=True)
        >>> result = thread.get()

        :param async bool
        :param int record_attachment_id: ID of the RecordAttachment you want to look up
        :return: list[RecordAttachmentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_record_attachment_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_record_attachment_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_record_attachment_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RecordAttachment in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_record_attachment_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int record_attachment_id: ID of the RecordAttachment you want to look up
        :return: list[RecordAttachmentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['record_attachment_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_record_attachment" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'record_attachment_id' in params:
            query_params.append(('RecordAttachmentID', params['record_attachment_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RecordAttachment', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RecordAttachmentItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_refund_request(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RefundRequest in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_refund_request(async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_id: ID of the RefundRequest you want to look up
        :return: list[RefundRequestItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_refund_request_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_refund_request_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_refund_request_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RefundRequest in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_refund_request_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_id: ID of the RefundRequest you want to look up
        :return: list[RefundRequestItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['refund_request_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_refund_request" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'refund_request_id' in params:
            query_params.append(('RefundRequestID', params['refund_request_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RefundRequest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RefundRequestItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_refund_request_batch_configuration(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RefundRequestBatchConfiguration in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_refund_request_batch_configuration(async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_batch_configuration_id: ID of the RefundRequestBatchConfiguration you want to look up
        :return: list[RefundRequestBatchConfigurationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_refund_request_batch_configuration_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_refund_request_batch_configuration_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_refund_request_batch_configuration_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RefundRequestBatchConfiguration in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_refund_request_batch_configuration_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_batch_configuration_id: ID of the RefundRequestBatchConfiguration you want to look up
        :return: list[RefundRequestBatchConfigurationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['refund_request_batch_configuration_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_refund_request_batch_configuration" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'refund_request_batch_configuration_id' in params:
            query_params.append(('RefundRequestBatchConfigurationID', params['refund_request_batch_configuration_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RefundRequestBatchConfiguration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RefundRequestBatchConfigurationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_refund_request_batch_configuration_item(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RefundRequestBatchConfigurationItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_refund_request_batch_configuration_item(async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_batch_configuration_item_id: ID of the RefundRequestBatchConfigurationItem you want to look up
        :return: list[RefundRequestBatchConfigurationItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_refund_request_batch_configuration_item_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_refund_request_batch_configuration_item_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_refund_request_batch_configuration_item_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RefundRequestBatchConfigurationItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_refund_request_batch_configuration_item_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_batch_configuration_item_id: ID of the RefundRequestBatchConfigurationItem you want to look up
        :return: list[RefundRequestBatchConfigurationItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['refund_request_batch_configuration_item_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_refund_request_batch_configuration_item" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'refund_request_batch_configuration_item_id' in params:
            query_params.append(('RefundRequestBatchConfigurationItemID', params['refund_request_batch_configuration_item_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RefundRequestBatchConfigurationItem', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RefundRequestBatchConfigurationItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_refund_request_break_up(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RefundRequestBreakUp in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_refund_request_break_up(async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_break_up_id: ID of the RefundRequestBreakUp you want to look up
        :return: list[RefundRequestBreakUpItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_refund_request_break_up_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_refund_request_break_up_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_refund_request_break_up_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RefundRequestBreakUp in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_refund_request_break_up_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_break_up_id: ID of the RefundRequestBreakUp you want to look up
        :return: list[RefundRequestBreakUpItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['refund_request_break_up_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_refund_request_break_up" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'refund_request_break_up_id' in params:
            query_params.append(('RefundRequestBreakUpID', params['refund_request_break_up_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RefundRequestBreakUp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RefundRequestBreakUpItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_refund_request_configuration(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RefundRequestConfiguration in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_refund_request_configuration(async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_configuration_id: ID of the RefundRequestConfiguration you want to look up
        :return: list[RefundRequestConfigurationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_refund_request_configuration_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_refund_request_configuration_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_refund_request_configuration_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RefundRequestConfiguration in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_refund_request_configuration_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_configuration_id: ID of the RefundRequestConfiguration you want to look up
        :return: list[RefundRequestConfigurationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['refund_request_configuration_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_refund_request_configuration" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'refund_request_configuration_id' in params:
            query_params.append(('RefundRequestConfigurationID', params['refund_request_configuration_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RefundRequestConfiguration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RefundRequestConfigurationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_refund_request_configuration_break_up(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RefundRequestConfigurationBreakUp in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_refund_request_configuration_break_up(async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_configuration_break_up_id: ID of the RefundRequestConfigurationBreakUp you want to look up
        :return: list[RefundRequestConfigurationBreakUpItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_refund_request_configuration_break_up_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_refund_request_configuration_break_up_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_refund_request_configuration_break_up_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RefundRequestConfigurationBreakUp in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_refund_request_configuration_break_up_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_configuration_break_up_id: ID of the RefundRequestConfigurationBreakUp you want to look up
        :return: list[RefundRequestConfigurationBreakUpItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['refund_request_configuration_break_up_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_refund_request_configuration_break_up" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'refund_request_configuration_break_up_id' in params:
            query_params.append(('RefundRequestConfigurationBreakUpID', params['refund_request_configuration_break_up_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RefundRequestConfigurationBreakUp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RefundRequestConfigurationBreakUpItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_region_of_birth(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RegionOfBirth in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_region_of_birth(async=True)
        >>> result = thread.get()

        :param async bool
        :param int region_of_birth_id: ID of the RegionOfBirth you want to look up
        :return: list[RegionOfBirthItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_region_of_birth_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_region_of_birth_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_region_of_birth_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RegionOfBirth in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_region_of_birth_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int region_of_birth_id: ID of the RegionOfBirth you want to look up
        :return: list[RegionOfBirthItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['region_of_birth_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_region_of_birth" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'region_of_birth_id' in params:
            query_params.append(('RegionOfBirthID', params['region_of_birth_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RegionOfBirth', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RegionOfBirthItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_report(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Report in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_report(async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_id: ID of the Report you want to look up
        :return: list[ReportItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_report_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_report_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_report_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Report in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_report_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_id: ID of the Report you want to look up
        :return: list[ReportItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['report_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_report" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'report_id' in params:
            query_params.append(('ReportID', params['report_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Report', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ReportItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_report_detail(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ReportDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_report_detail(async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_detail_id: ID of the ReportDetail you want to look up
        :return: list[ReportDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_report_detail_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_report_detail_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_report_detail_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ReportDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_report_detail_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_detail_id: ID of the ReportDetail you want to look up
        :return: list[ReportDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['report_detail_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_report_detail" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'report_detail_id' in params:
            query_params.append(('ReportDetailID', params['report_detail_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ReportDetail', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ReportDetailItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_report_permission(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ReportPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_report_permission(async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_permission_id: ID of the ReportPermission you want to look up
        :return: list[ReportPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_report_permission_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_report_permission_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_report_permission_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ReportPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_report_permission_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_permission_id: ID of the ReportPermission you want to look up
        :return: list[ReportPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['report_permission_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_report_permission" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'report_permission_id' in params:
            query_params.append(('ReportPermissionID', params['report_permission_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ReportPermission', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ReportPermissionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_report_schedule(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ReportSchedule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_report_schedule(async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_schedule_id: ID of the ReportSchedule you want to look up
        :return: list[ReportScheduleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_report_schedule_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_report_schedule_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_report_schedule_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ReportSchedule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_report_schedule_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_schedule_id: ID of the ReportSchedule you want to look up
        :return: list[ReportScheduleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['report_schedule_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_report_schedule" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'report_schedule_id' in params:
            query_params.append(('ReportScheduleID', params['report_schedule_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ReportSchedule', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ReportScheduleItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_report_setting(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ReportSetting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_report_setting(async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_setting_id: ID of the ReportSetting you want to look up
        :return: list[ReportSettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_report_setting_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_report_setting_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_report_setting_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ReportSetting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_report_setting_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_setting_id: ID of the ReportSetting you want to look up
        :return: list[ReportSettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['report_setting_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_report_setting" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'report_setting_id' in params:
            query_params.append(('ReportSettingID', params['report_setting_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ReportSetting', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ReportSettingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_resource(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Resource in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_resource(async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_id: ID of the Resource you want to look up
        :return: list[ResourceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_resource_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_resource_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_resource_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Resource in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_resource_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_id: ID of the Resource you want to look up
        :return: list[ResourceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_resource" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'resource_id' in params:
            query_params.append(('ResourceID', params['resource_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Resource', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ResourceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_resource_booking(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ResourceBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_resource_booking(async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_booking_id: ID of the ResourceBooking you want to look up
        :return: list[ResourceBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_resource_booking_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_resource_booking_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_resource_booking_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ResourceBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_resource_booking_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_booking_id: ID of the ResourceBooking you want to look up
        :return: list[ResourceBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_booking_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_resource_booking" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'resource_booking_id' in params:
            query_params.append(('ResourceBookingID', params['resource_booking_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ResourceBooking', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ResourceBookingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_resource_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ResourceType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_resource_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_type_id: ID of the ResourceType you want to look up
        :return: list[ResourceTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_resource_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_resource_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_resource_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ResourceType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_resource_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_type_id: ID of the ResourceType you want to look up
        :return: list[ResourceTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_resource_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'resource_type_id' in params:
            query_params.append(('ResourceTypeID', params['resource_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ResourceType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ResourceTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_response_status(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ResponseStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_response_status(async=True)
        >>> result = thread.get()

        :param async bool
        :param int response_status_id: ID of the ResponseStatus you want to look up
        :return: list[ResponseStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_response_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_response_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_response_status_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ResponseStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_response_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int response_status_id: ID of the ResponseStatus you want to look up
        :return: list[ResponseStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['response_status_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_response_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'response_status_id' in params:
            query_params.append(('ResponseStatusID', params['response_status_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ResponseStatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ResponseStatusItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Room in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_id: ID of the Room you want to look up
        :return: list[RoomItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Room in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_id: ID of the Room you want to look up
        :return: list[RoomItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_id' in params:
            query_params.append(('RoomID', params['room_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Room', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_attribute(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomAttribute in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_attribute(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_attribute_id: ID of the RoomAttribute you want to look up
        :return: list[RoomAttributeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_attribute_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_attribute_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_attribute_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomAttribute in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_attribute_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_attribute_id: ID of the RoomAttribute you want to look up
        :return: list[RoomAttributeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_attribute_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_attribute" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_attribute_id' in params:
            query_params.append(('RoomAttributeID', params['room_attribute_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomAttribute', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomAttributeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_base(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomBase in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_base(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_base_id: ID of the RoomBase you want to look up
        :return: list[RoomBaseItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_base_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_base_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_base_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomBase in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_base_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_base_id: ID of the RoomBase you want to look up
        :return: list[RoomBaseItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_base_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_base" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_base_id' in params:
            query_params.append(('RoomBaseID', params['room_base_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomBase', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomBaseItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_base_gender(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomBaseGender in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_base_gender(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_base_gender_id: ID of the RoomBaseGender you want to look up
        :return: list[RoomBaseGenderItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_base_gender_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_base_gender_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_base_gender_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomBaseGender in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_base_gender_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_base_gender_id: ID of the RoomBaseGender you want to look up
        :return: list[RoomBaseGenderItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_base_gender_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_base_gender" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_base_gender_id' in params:
            query_params.append(('RoomBaseGenderID', params['room_base_gender_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomBaseGender', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomBaseGenderItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_classification(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_classification(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_classification_id: ID of the RoomClassification you want to look up
        :return: list[RoomClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_classification_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_classification_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_classification_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_classification_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_classification_id: ID of the RoomClassification you want to look up
        :return: list[RoomClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_classification_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_classification" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_classification_id' in params:
            query_params.append(('RoomClassificationID', params['room_classification_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomClassification', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomClassificationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_configuration(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomConfiguration in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_configuration(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_id: ID of the RoomConfiguration you want to look up
        :return: list[RoomConfigurationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_configuration_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_configuration_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_configuration_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomConfiguration in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_configuration_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_id: ID of the RoomConfiguration you want to look up
        :return: list[RoomConfigurationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_configuration_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_configuration" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_configuration_id' in params:
            query_params.append(('RoomConfigurationID', params['room_configuration_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomConfiguration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomConfigurationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_configuration_attribute(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomConfigurationAttribute in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_configuration_attribute(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_attribute_id: ID of the RoomConfigurationAttribute you want to look up
        :return: list[RoomConfigurationAttributeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_configuration_attribute_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_configuration_attribute_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_configuration_attribute_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomConfigurationAttribute in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_configuration_attribute_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_attribute_id: ID of the RoomConfigurationAttribute you want to look up
        :return: list[RoomConfigurationAttributeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_configuration_attribute_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_configuration_attribute" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_configuration_attribute_id' in params:
            query_params.append(('RoomConfigurationAttributeID', params['room_configuration_attribute_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomConfigurationAttribute', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomConfigurationAttributeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_configuration_classification(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomConfigurationClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_configuration_classification(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_classification_id: ID of the RoomConfigurationClassification you want to look up
        :return: list[RoomConfigurationClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_configuration_classification_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_configuration_classification_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_configuration_classification_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomConfigurationClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_configuration_classification_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_classification_id: ID of the RoomConfigurationClassification you want to look up
        :return: list[RoomConfigurationClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_configuration_classification_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_configuration_classification" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_configuration_classification_id' in params:
            query_params.append(('RoomConfigurationClassificationID', params['room_configuration_classification_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomConfigurationClassification', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomConfigurationClassificationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_configuration_profile(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomConfigurationProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_configuration_profile(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_profile_id: ID of the RoomConfigurationProfile you want to look up
        :return: list[RoomConfigurationProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_configuration_profile_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_configuration_profile_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_configuration_profile_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomConfigurationProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_configuration_profile_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_profile_id: ID of the RoomConfigurationProfile you want to look up
        :return: list[RoomConfigurationProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_configuration_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_configuration_profile" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_configuration_profile_id' in params:
            query_params.append(('RoomConfigurationProfileID', params['room_configuration_profile_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomConfigurationProfile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomConfigurationProfileItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_configuration_room_sort(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomConfigurationRoomSort in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_configuration_room_sort(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_room_sort_id: ID of the RoomConfigurationRoomSort you want to look up
        :return: list[RoomConfigurationRoomSortItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_configuration_room_sort_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_configuration_room_sort_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_configuration_room_sort_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomConfigurationRoomSort in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_configuration_room_sort_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_room_sort_id: ID of the RoomConfigurationRoomSort you want to look up
        :return: list[RoomConfigurationRoomSortItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_configuration_room_sort_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_configuration_room_sort" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_configuration_room_sort_id' in params:
            query_params.append(('RoomConfigurationRoomSortID', params['room_configuration_room_sort_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomConfigurationRoomSort', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomConfigurationRoomSortItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_configuration_term_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomConfigurationTermType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_configuration_term_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_term_type_id: ID of the RoomConfigurationTermType you want to look up
        :return: list[RoomConfigurationTermTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_configuration_term_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_configuration_term_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_configuration_term_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomConfigurationTermType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_configuration_term_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_term_type_id: ID of the RoomConfigurationTermType you want to look up
        :return: list[RoomConfigurationTermTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_configuration_term_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_configuration_term_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_configuration_term_type_id' in params:
            query_params.append(('RoomConfigurationTermTypeID', params['room_configuration_term_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomConfigurationTermType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomConfigurationTermTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_location(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomLocation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_location(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_id: ID of the RoomLocation you want to look up
        :return: list[RoomLocationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_location_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_location_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_location_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomLocation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_location_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_id: ID of the RoomLocation you want to look up
        :return: list[RoomLocationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_location_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_location" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_location_id' in params:
            query_params.append(('RoomLocationID', params['room_location_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomLocation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomLocationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_location_area(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomLocationArea in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_location_area(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_area_id: ID of the RoomLocationArea you want to look up
        :return: list[RoomLocationAreaItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_location_area_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_location_area_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_location_area_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomLocationArea in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_location_area_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_area_id: ID of the RoomLocationArea you want to look up
        :return: list[RoomLocationAreaItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_location_area_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_location_area" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_location_area_id' in params:
            query_params.append(('RoomLocationAreaID', params['room_location_area_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomLocationArea', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomLocationAreaItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_location_classification(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomLocationClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_location_classification(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_classification_id: ID of the RoomLocationClassification you want to look up
        :return: list[RoomLocationClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_location_classification_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_location_classification_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_location_classification_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomLocationClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_location_classification_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_classification_id: ID of the RoomLocationClassification you want to look up
        :return: list[RoomLocationClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_location_classification_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_location_classification" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_location_classification_id' in params:
            query_params.append(('RoomLocationClassificationID', params['room_location_classification_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomLocationClassification', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomLocationClassificationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_location_floor_suite(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomLocationFloorSuite in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_location_floor_suite(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_floor_suite_id: ID of the RoomLocationFloorSuite you want to look up
        :return: list[RoomLocationFloorSuiteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_location_floor_suite_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_location_floor_suite_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_location_floor_suite_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomLocationFloorSuite in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_location_floor_suite_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_floor_suite_id: ID of the RoomLocationFloorSuite you want to look up
        :return: list[RoomLocationFloorSuiteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_location_floor_suite_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_location_floor_suite" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_location_floor_suite_id' in params:
            query_params.append(('RoomLocationFloorSuiteID', params['room_location_floor_suite_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomLocationFloorSuite', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomLocationFloorSuiteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_location_section(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomLocationSection in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_location_section(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_section_id: ID of the RoomLocationSection you want to look up
        :return: list[RoomLocationSectionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_location_section_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_location_section_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_location_section_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomLocationSection in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_location_section_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_section_id: ID of the RoomLocationSection you want to look up
        :return: list[RoomLocationSectionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_location_section_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_location_section" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_location_section_id' in params:
            query_params.append(('RoomLocationSectionID', params['room_location_section_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomLocationSection', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomLocationSectionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_manager(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomManager in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_manager(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_manager_id: ID of the RoomManager you want to look up
        :return: list[RoomManagerItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_manager_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_manager_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_manager_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomManager in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_manager_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_manager_id: ID of the RoomManager you want to look up
        :return: list[RoomManagerItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_manager_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_manager" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_manager_id' in params:
            query_params.append(('RoomManagerID', params['room_manager_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomManager', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomManagerItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_preference(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomPreference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_preference(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_preference_id: ID of the RoomPreference you want to look up
        :return: list[RoomPreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_preference_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_preference_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_preference_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomPreference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_preference_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_preference_id: ID of the RoomPreference you want to look up
        :return: list[RoomPreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_preference_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_preference" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_preference_id' in params:
            query_params.append(('RoomPreferenceID', params['room_preference_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomPreference', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomPreferenceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_profile(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_profile(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_profile_id: ID of the RoomProfile you want to look up
        :return: list[RoomProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_profile_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_profile_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_profile_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_profile_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_profile_id: ID of the RoomProfile you want to look up
        :return: list[RoomProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_profile" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_profile_id' in params:
            query_params.append(('RoomProfileID', params['room_profile_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomProfile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomProfileItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_rate(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomRate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_rate(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_rate_id: ID of the RoomRate you want to look up
        :return: list[RoomRateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_rate_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_rate_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_rate_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomRate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_rate_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_rate_id: ID of the RoomRate you want to look up
        :return: list[RoomRateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_rate_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_rate" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_rate_id' in params:
            query_params.append(('RoomRateID', params['room_rate_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomRate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomRateItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_rate_charge(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomRateCharge in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_rate_charge(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_rate_charge_id: ID of the RoomRateCharge you want to look up
        :return: list[RoomRateChargeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_rate_charge_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_rate_charge_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_rate_charge_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomRateCharge in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_rate_charge_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_rate_charge_id: ID of the RoomRateCharge you want to look up
        :return: list[RoomRateChargeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_rate_charge_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_rate_charge" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_rate_charge_id' in params:
            query_params.append(('RoomRateChargeID', params['room_rate_charge_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomRateCharge', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomRateChargeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_rate_room_type_location(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomRateRoomTypeLocation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_rate_room_type_location(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_rate_room_type_location_id: ID of the RoomRateRoomTypeLocation you want to look up
        :return: list[RoomRateRoomTypeLocationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_rate_room_type_location_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_rate_room_type_location_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_rate_room_type_location_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomRateRoomTypeLocation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_rate_room_type_location_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_rate_room_type_location_id: ID of the RoomRateRoomTypeLocation you want to look up
        :return: list[RoomRateRoomTypeLocationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_rate_room_type_location_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_rate_room_type_location" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_rate_room_type_location_id' in params:
            query_params.append(('RoomRateRoomTypeLocationID', params['room_rate_room_type_location_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomRateRoomTypeLocation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomRateRoomTypeLocationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_rate_session(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomRateSession in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_rate_session(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_rate_session_id: ID of the RoomRateSession you want to look up
        :return: list[RoomRateSessionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_rate_session_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_rate_session_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_rate_session_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomRateSession in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_rate_session_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_rate_session_id: ID of the RoomRateSession you want to look up
        :return: list[RoomRateSessionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_rate_session_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_rate_session" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_rate_session_id' in params:
            query_params.append(('RoomRateSessionID', params['room_rate_session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomRateSession', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomRateSessionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_sort_configuration(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSortConfiguration in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_sort_configuration(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_sort_configuration_id: ID of the RoomSortConfiguration you want to look up
        :return: list[RoomSortConfigurationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_sort_configuration_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_sort_configuration_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_sort_configuration_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSortConfiguration in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_sort_configuration_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_sort_configuration_id: ID of the RoomSortConfiguration you want to look up
        :return: list[RoomSortConfigurationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_sort_configuration_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_sort_configuration" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_sort_configuration_id' in params:
            query_params.append(('RoomSortConfigurationID', params['room_sort_configuration_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSortConfiguration', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSortConfigurationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_sort_profile(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSortProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_sort_profile(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_sort_profile_id: ID of the RoomSortProfile you want to look up
        :return: list[RoomSortProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_sort_profile_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_sort_profile_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_sort_profile_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSortProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_sort_profile_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_sort_profile_id: ID of the RoomSortProfile you want to look up
        :return: list[RoomSortProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_sort_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_sort_profile" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_sort_profile_id' in params:
            query_params.append(('RoomSortProfileID', params['room_sort_profile_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSortProfile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSortProfileItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_sort_profile_item(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSortProfileItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_sort_profile_item(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_sort_profile_item_id: ID of the RoomSortProfileItem you want to look up
        :return: list[RoomSortProfileItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_sort_profile_item_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_sort_profile_item_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_sort_profile_item_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSortProfileItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_sort_profile_item_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_sort_profile_item_id: ID of the RoomSortProfileItem you want to look up
        :return: list[RoomSortProfileItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_sort_profile_item_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_sort_profile_item" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_sort_profile_item_id' in params:
            query_params.append(('RoomSortProfileItemID', params['room_sort_profile_item_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSortProfileItem', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSortProfileItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpace in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_id: ID of the RoomSpace you want to look up
        :return: list[RoomSpaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpace in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_id: ID of the RoomSpace you want to look up
        :return: list[RoomSpaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_id' in params:
            query_params.append(('RoomSpaceID', params['room_space_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpace', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_closed(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceClosed in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_closed(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_closed_id: ID of the RoomSpaceClosed you want to look up
        :return: list[RoomSpaceClosedItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_closed_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_closed_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_closed_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceClosed in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_closed_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_closed_id: ID of the RoomSpaceClosed you want to look up
        :return: list[RoomSpaceClosedItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_closed_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_closed" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_closed_id' in params:
            query_params.append(('RoomSpaceClosedID', params['room_space_closed_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceClosed', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceClosedItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_detail(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_detail(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_detail_id: ID of the RoomSpaceDetail you want to look up
        :return: list[RoomSpaceDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_detail_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_detail_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_detail_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_detail_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_detail_id: ID of the RoomSpaceDetail you want to look up
        :return: list[RoomSpaceDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_detail_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_detail" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_detail_id' in params:
            query_params.append(('RoomSpaceDetailID', params['room_space_detail_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceDetail', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceDetailItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_inventory(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceInventory in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_inventory(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_id: ID of the RoomSpaceInventory you want to look up
        :return: list[RoomSpaceInventoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_inventory_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_inventory_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_inventory_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceInventory in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_inventory_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_id: ID of the RoomSpaceInventory you want to look up
        :return: list[RoomSpaceInventoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_inventory_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_inventory" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_inventory_id' in params:
            query_params.append(('RoomSpaceInventoryID', params['room_space_inventory_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceInventory', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceInventoryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_inventory_condition(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceInventoryCondition in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_inventory_condition(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_condition_id: ID of the RoomSpaceInventoryCondition you want to look up
        :return: list[RoomSpaceInventoryConditionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_inventory_condition_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_inventory_condition_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_inventory_condition_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceInventoryCondition in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_inventory_condition_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_condition_id: ID of the RoomSpaceInventoryCondition you want to look up
        :return: list[RoomSpaceInventoryConditionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_inventory_condition_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_inventory_condition" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_inventory_condition_id' in params:
            query_params.append(('RoomSpaceInventoryConditionID', params['room_space_inventory_condition_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceInventoryCondition', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceInventoryConditionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_inventory_inspection(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceInventoryInspection in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_inventory_inspection(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_inspection_id: ID of the RoomSpaceInventoryInspection you want to look up
        :return: list[RoomSpaceInventoryInspectionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_inventory_inspection_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_inventory_inspection_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_inventory_inspection_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceInventoryInspection in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_inventory_inspection_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_inspection_id: ID of the RoomSpaceInventoryInspection you want to look up
        :return: list[RoomSpaceInventoryInspectionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_inventory_inspection_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_inventory_inspection" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_inventory_inspection_id' in params:
            query_params.append(('RoomSpaceInventoryInspectionID', params['room_space_inventory_inspection_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceInventoryInspection', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceInventoryInspectionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_inventory_inspection_item(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceInventoryInspectionItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_inventory_inspection_item(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_inspection_item_id: ID of the RoomSpaceInventoryInspectionItem you want to look up
        :return: list[RoomSpaceInventoryInspectionItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_inventory_inspection_item_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_inventory_inspection_item_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_inventory_inspection_item_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceInventoryInspectionItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_inventory_inspection_item_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_inspection_item_id: ID of the RoomSpaceInventoryInspectionItem you want to look up
        :return: list[RoomSpaceInventoryInspectionItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_inventory_inspection_item_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_inventory_inspection_item" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_inventory_inspection_item_id' in params:
            query_params.append(('RoomSpaceInventoryInspectionItemID', params['room_space_inventory_inspection_item_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceInventoryInspectionItem', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceInventoryInspectionItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_inventory_inspection_run(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceInventoryInspectionRun in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_inventory_inspection_run(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_inspection_run_id: ID of the RoomSpaceInventoryInspectionRun you want to look up
        :return: list[RoomSpaceInventoryInspectionRunItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_inventory_inspection_run_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_inventory_inspection_run_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_inventory_inspection_run_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceInventoryInspectionRun in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_inventory_inspection_run_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_inspection_run_id: ID of the RoomSpaceInventoryInspectionRun you want to look up
        :return: list[RoomSpaceInventoryInspectionRunItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_inventory_inspection_run_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_inventory_inspection_run" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_inventory_inspection_run_id' in params:
            query_params.append(('RoomSpaceInventoryInspectionRunID', params['room_space_inventory_inspection_run_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceInventoryInspectionRun', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceInventoryInspectionRunItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_inventory_status(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceInventoryStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_inventory_status(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_status_id: ID of the RoomSpaceInventoryStatus you want to look up
        :return: list[RoomSpaceInventoryStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_inventory_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_inventory_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_inventory_status_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceInventoryStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_inventory_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_status_id: ID of the RoomSpaceInventoryStatus you want to look up
        :return: list[RoomSpaceInventoryStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_inventory_status_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_inventory_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_inventory_status_id' in params:
            query_params.append(('RoomSpaceInventoryStatusID', params['room_space_inventory_status_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceInventoryStatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceInventoryStatusItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_inventory_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceInventoryType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_inventory_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_type_id: ID of the RoomSpaceInventoryType you want to look up
        :return: list[RoomSpaceInventoryTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_inventory_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_inventory_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_inventory_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceInventoryType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_inventory_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_type_id: ID of the RoomSpaceInventoryType you want to look up
        :return: list[RoomSpaceInventoryTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_inventory_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_inventory_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_inventory_type_id' in params:
            query_params.append(('RoomSpaceInventoryTypeID', params['room_space_inventory_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceInventoryType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceInventoryTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_key(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceKey in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_key(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_key_id: ID of the RoomSpaceKey you want to look up
        :return: list[RoomSpaceKeyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_key_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_key_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_key_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceKey in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_key_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_key_id: ID of the RoomSpaceKey you want to look up
        :return: list[RoomSpaceKeyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_key_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_key" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_key_id' in params:
            query_params.append(('RoomSpaceKeyID', params['room_space_key_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceKey', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceKeyItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_key_booking(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceKeyBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_key_booking(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_key_booking_id: ID of the RoomSpaceKeyBooking you want to look up
        :return: list[RoomSpaceKeyBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_key_booking_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_key_booking_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_key_booking_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceKeyBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_key_booking_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_key_booking_id: ID of the RoomSpaceKeyBooking you want to look up
        :return: list[RoomSpaceKeyBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_key_booking_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_key_booking" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_key_booking_id' in params:
            query_params.append(('RoomSpaceKeyBookingID', params['room_space_key_booking_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceKeyBooking', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceKeyBookingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_key_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceKeyType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_key_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_key_type_id: ID of the RoomSpaceKeyType you want to look up
        :return: list[RoomSpaceKeyTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_key_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_key_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_key_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceKeyType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_key_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_key_type_id: ID of the RoomSpaceKeyType you want to look up
        :return: list[RoomSpaceKeyTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_key_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_key_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_key_type_id' in params:
            query_params.append(('RoomSpaceKeyTypeID', params['room_space_key_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceKeyType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceKeyTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_maintenance(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceMaintenance in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_maintenance(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_id: ID of the RoomSpaceMaintenance you want to look up
        :return: list[RoomSpaceMaintenanceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_maintenance_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_maintenance_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_maintenance_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceMaintenance in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_maintenance_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_id: ID of the RoomSpaceMaintenance you want to look up
        :return: list[RoomSpaceMaintenanceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_maintenance_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_maintenance" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_maintenance_id' in params:
            query_params.append(('RoomSpaceMaintenanceID', params['room_space_maintenance_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceMaintenance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceMaintenanceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_maintenance_category(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceMaintenanceCategory in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_maintenance_category(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_category_id: ID of the RoomSpaceMaintenanceCategory you want to look up
        :return: list[RoomSpaceMaintenanceCategoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_maintenance_category_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_maintenance_category_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_maintenance_category_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceMaintenanceCategory in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_maintenance_category_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_category_id: ID of the RoomSpaceMaintenanceCategory you want to look up
        :return: list[RoomSpaceMaintenanceCategoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_maintenance_category_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_maintenance_category" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_maintenance_category_id' in params:
            query_params.append(('RoomSpaceMaintenanceCategoryID', params['room_space_maintenance_category_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceMaintenanceCategory', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceMaintenanceCategoryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_maintenance_item(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceMaintenanceItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_maintenance_item(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_item_id: ID of the RoomSpaceMaintenanceItem you want to look up
        :return: list[RoomSpaceMaintenanceItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_maintenance_item_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_maintenance_item_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_maintenance_item_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceMaintenanceItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_maintenance_item_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_item_id: ID of the RoomSpaceMaintenanceItem you want to look up
        :return: list[RoomSpaceMaintenanceItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_maintenance_item_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_maintenance_item" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_maintenance_item_id' in params:
            query_params.append(('RoomSpaceMaintenanceItemID', params['room_space_maintenance_item_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceMaintenanceItem', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceMaintenanceItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_maintenance_job_action(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceMaintenanceJobAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_maintenance_job_action(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_job_action_id: ID of the RoomSpaceMaintenanceJobAction you want to look up
        :return: list[RoomSpaceMaintenanceJobActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_maintenance_job_action_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_maintenance_job_action_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_maintenance_job_action_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceMaintenanceJobAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_maintenance_job_action_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_job_action_id: ID of the RoomSpaceMaintenanceJobAction you want to look up
        :return: list[RoomSpaceMaintenanceJobActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_maintenance_job_action_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_maintenance_job_action" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_maintenance_job_action_id' in params:
            query_params.append(('RoomSpaceMaintenanceJobActionID', params['room_space_maintenance_job_action_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceMaintenanceJobAction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceMaintenanceJobActionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_maintenance_materials(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceMaintenanceMaterials in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_maintenance_materials(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_materials_id: ID of the RoomSpaceMaintenanceMaterials you want to look up
        :return: list[RoomSpaceMaintenanceMaterialsItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_maintenance_materials_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_maintenance_materials_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_maintenance_materials_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceMaintenanceMaterials in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_maintenance_materials_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_materials_id: ID of the RoomSpaceMaintenanceMaterials you want to look up
        :return: list[RoomSpaceMaintenanceMaterialsItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_maintenance_materials_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_maintenance_materials" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_maintenance_materials_id' in params:
            query_params.append(('RoomSpaceMaintenanceMaterialsID', params['room_space_maintenance_materials_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceMaintenanceMaterials', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceMaintenanceMaterialsItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_swap(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceSwap in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_swap(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_swap_id: ID of the RoomSpaceSwap you want to look up
        :return: list[RoomSpaceSwapItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_swap_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_swap_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_swap_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceSwap in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_swap_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_swap_id: ID of the RoomSpaceSwap you want to look up
        :return: list[RoomSpaceSwapItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_swap_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_swap" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_swap_id' in params:
            query_params.append(('RoomSpaceSwapID', params['room_space_swap_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceSwap', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceSwapItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_space_swap_preference(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceSwapPreference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_swap_preference(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_swap_preference_id: ID of the RoomSpaceSwapPreference you want to look up
        :return: list[RoomSpaceSwapPreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_space_swap_preference_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_space_swap_preference_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_space_swap_preference_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomSpaceSwapPreference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_space_swap_preference_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_swap_preference_id: ID of the RoomSpaceSwapPreference you want to look up
        :return: list[RoomSpaceSwapPreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_swap_preference_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_space_swap_preference" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_space_swap_preference_id' in params:
            query_params.append(('RoomSpaceSwapPreferenceID', params['room_space_swap_preference_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomSpaceSwapPreference', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceSwapPreferenceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_term_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomTermType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_term_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_term_type_id: ID of the RoomTermType you want to look up
        :return: list[RoomTermTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_term_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_term_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_term_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomTermType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_term_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_term_type_id: ID of the RoomTermType you want to look up
        :return: list[RoomTermTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_term_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_term_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_term_type_id' in params:
            query_params.append(('RoomTermTypeID', params['room_term_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomTermType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomTermTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_type_id: ID of the RoomType you want to look up
        :return: list[RoomTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_type_id: ID of the RoomType you want to look up
        :return: list[RoomTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_type_id' in params:
            query_params.append(('RoomTypeID', params['room_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_room_type_capacity(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomTypeCapacity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_type_capacity(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_type_capacity_id: ID of the RoomTypeCapacity you want to look up
        :return: list[RoomTypeCapacityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_room_type_capacity_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_room_type_capacity_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_room_type_capacity_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoomTypeCapacity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_room_type_capacity_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_type_capacity_id: ID of the RoomTypeCapacity you want to look up
        :return: list[RoomTypeCapacityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_type_capacity_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_room_type_capacity" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'room_type_capacity_id' in params:
            query_params.append(('RoomTypeCapacityID', params['room_type_capacity_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoomTypeCapacity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomTypeCapacityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_roommate_group(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoommateGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_roommate_group(async=True)
        >>> result = thread.get()

        :param async bool
        :param int roommate_group_id: ID of the RoommateGroup you want to look up
        :return: list[RoommateGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_roommate_group_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_roommate_group_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_roommate_group_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoommateGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_roommate_group_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int roommate_group_id: ID of the RoommateGroup you want to look up
        :return: list[RoommateGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['roommate_group_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_roommate_group" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'roommate_group_id' in params:
            query_params.append(('RoommateGroupID', params['roommate_group_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoommateGroup', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoommateGroupItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_roommate_group_mandatory_profile(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoommateGroupMandatoryProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_roommate_group_mandatory_profile(async=True)
        >>> result = thread.get()

        :param async bool
        :param int roommate_group_mandatory_profile_id: ID of the RoommateGroupMandatoryProfile you want to look up
        :return: list[RoommateGroupMandatoryProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_roommate_group_mandatory_profile_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_roommate_group_mandatory_profile_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_roommate_group_mandatory_profile_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoommateGroupMandatoryProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_roommate_group_mandatory_profile_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int roommate_group_mandatory_profile_id: ID of the RoommateGroupMandatoryProfile you want to look up
        :return: list[RoommateGroupMandatoryProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['roommate_group_mandatory_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_roommate_group_mandatory_profile" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'roommate_group_mandatory_profile_id' in params:
            query_params.append(('RoommateGroupMandatoryProfileID', params['roommate_group_mandatory_profile_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoommateGroupMandatoryProfile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoommateGroupMandatoryProfileItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_roommate_group_request(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoommateGroupRequest in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_roommate_group_request(async=True)
        >>> result = thread.get()

        :param async bool
        :param int roommate_group_request_id: ID of the RoommateGroupRequest you want to look up
        :return: list[RoommateGroupRequestItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_roommate_group_request_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_roommate_group_request_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_roommate_group_request_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a RoommateGroupRequest in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_roommate_group_request_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int roommate_group_request_id: ID of the RoommateGroupRequest you want to look up
        :return: list[RoommateGroupRequestItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['roommate_group_request_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_roommate_group_request" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'roommate_group_request_id' in params:
            query_params.append(('RoommateGroupRequestID', params['roommate_group_request_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/RoommateGroupRequest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoommateGroupRequestItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_saved_list(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SavedList in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_saved_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param int saved_list_id: ID of the SavedList you want to look up
        :return: list[SavedListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_saved_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_saved_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_saved_list_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SavedList in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_saved_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int saved_list_id: ID of the SavedList you want to look up
        :return: list[SavedListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['saved_list_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_saved_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'saved_list_id' in params:
            query_params.append(('SavedListID', params['saved_list_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/SavedList', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SavedListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_saved_list_item(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SavedListItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_saved_list_item(async=True)
        >>> result = thread.get()

        :param async bool
        :param int saved_list_item_id: ID of the SavedListItem you want to look up
        :return: list[SavedListItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_saved_list_item_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_saved_list_item_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_saved_list_item_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SavedListItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_saved_list_item_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int saved_list_item_id: ID of the SavedListItem you want to look up
        :return: list[SavedListItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['saved_list_item_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_saved_list_item" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'saved_list_item_id' in params:
            query_params.append(('SavedListItemID', params['saved_list_item_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/SavedListItem', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SavedListItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_school(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a School in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_school(async=True)
        >>> result = thread.get()

        :param async bool
        :param int school_id: ID of the School you want to look up
        :return: list[SchoolItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_school_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_school_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_school_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a School in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_school_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int school_id: ID of the School you want to look up
        :return: list[SchoolItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['school_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_school" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'school_id' in params:
            query_params.append(('SchoolID', params['school_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/School', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SchoolItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_sdas_charge_rate(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SDASChargeRate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_sdas_charge_rate(async=True)
        >>> result = thread.get()

        :param async bool
        :param int sdas_charge_rate_id: ID of the SDASChargeRate you want to look up
        :return: list[SDASChargeRateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_sdas_charge_rate_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_sdas_charge_rate_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_sdas_charge_rate_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SDASChargeRate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_sdas_charge_rate_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int sdas_charge_rate_id: ID of the SDASChargeRate you want to look up
        :return: list[SDASChargeRateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sdas_charge_rate_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_sdas_charge_rate" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sdas_charge_rate_id' in params:
            query_params.append(('SDASChargeRateID', params['sdas_charge_rate_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/SDASChargeRate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SDASChargeRateItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_sdas_data(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SDASData in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_sdas_data(async=True)
        >>> result = thread.get()

        :param async bool
        :param int sdas_data_id: ID of the SDASData you want to look up
        :return: list[SDASDataItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_sdas_data_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_sdas_data_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_sdas_data_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SDASData in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_sdas_data_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int sdas_data_id: ID of the SDASData you want to look up
        :return: list[SDASDataItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sdas_data_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_sdas_data" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sdas_data_id' in params:
            query_params.append(('SDASDataID', params['sdas_data_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/SDASData', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SDASDataItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_setting(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Setting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_setting(async=True)
        >>> result = thread.get()

        :param async bool
        :param int setting_id: ID of the Setting you want to look up
        :return: list[SettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_setting_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_setting_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_setting_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Setting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_setting_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int setting_id: ID of the Setting you want to look up
        :return: list[SettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['setting_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_setting" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'setting_id' in params:
            query_params.append(('SettingID', params['setting_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Setting', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SettingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_shipping_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ShippingType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_shipping_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int shipping_type_id: ID of the ShippingType you want to look up
        :return: list[ShippingTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_shipping_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_shipping_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_shipping_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ShippingType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_shipping_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int shipping_type_id: ID of the ShippingType you want to look up
        :return: list[ShippingTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['shipping_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_shipping_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'shipping_type_id' in params:
            query_params.append(('ShippingTypeID', params['shipping_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ShippingType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ShippingTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_shopping_cart_item(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ShoppingCartItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_shopping_cart_item(async=True)
        >>> result = thread.get()

        :param async bool
        :param int shopping_cart_item_id: ID of the ShoppingCartItem you want to look up
        :return: list[ShoppingCartItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_shopping_cart_item_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_shopping_cart_item_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_shopping_cart_item_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ShoppingCartItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_shopping_cart_item_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int shopping_cart_item_id: ID of the ShoppingCartItem you want to look up
        :return: list[ShoppingCartItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['shopping_cart_item_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_shopping_cart_item" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'shopping_cart_item_id' in params:
            query_params.append(('ShoppingCartItemID', params['shopping_cart_item_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ShoppingCartItem', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ShoppingCartItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_shopping_cart_item_hold(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ShoppingCartItemHold in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_shopping_cart_item_hold(async=True)
        >>> result = thread.get()

        :param async bool
        :param int shopping_cart_item_hold_id: ID of the ShoppingCartItemHold you want to look up
        :return: list[ShoppingCartItemHoldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_shopping_cart_item_hold_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_shopping_cart_item_hold_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_shopping_cart_item_hold_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ShoppingCartItemHold in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_shopping_cart_item_hold_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int shopping_cart_item_hold_id: ID of the ShoppingCartItemHold you want to look up
        :return: list[ShoppingCartItemHoldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['shopping_cart_item_hold_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_shopping_cart_item_hold" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'shopping_cart_item_hold_id' in params:
            query_params.append(('ShoppingCartItemHoldID', params['shopping_cart_item_hold_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ShoppingCartItemHold', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ShoppingCartItemHoldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_staff(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Staff in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_staff(async=True)
        >>> result = thread.get()

        :param async bool
        :param int staff_id: ID of the Staff you want to look up
        :return: list[StaffItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_staff_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_staff_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_staff_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Staff in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_staff_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int staff_id: ID of the Staff you want to look up
        :return: list[StaffItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['staff_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_staff" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'staff_id' in params:
            query_params.append(('StaffID', params['staff_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Staff', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StaffItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_survey(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Survey in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_survey(async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_id: ID of the Survey you want to look up
        :return: list[SurveyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_survey_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_survey_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_survey_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Survey in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_survey_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_id: ID of the Survey you want to look up
        :return: list[SurveyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['survey_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_survey" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'survey_id' in params:
            query_params.append(('SurveyID', params['survey_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Survey', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SurveyItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_survey_question(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SurveyQuestion in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_survey_question(async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_question_id: ID of the SurveyQuestion you want to look up
        :return: list[SurveyQuestionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_survey_question_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_survey_question_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_survey_question_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SurveyQuestion in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_survey_question_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_question_id: ID of the SurveyQuestion you want to look up
        :return: list[SurveyQuestionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['survey_question_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_survey_question" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'survey_question_id' in params:
            query_params.append(('SurveyQuestionID', params['survey_question_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/SurveyQuestion', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SurveyQuestionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_survey_question_response(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SurveyQuestionResponse in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_survey_question_response(async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_question_response_id: ID of the SurveyQuestionResponse you want to look up
        :return: list[SurveyQuestionResponseItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_survey_question_response_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_survey_question_response_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_survey_question_response_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SurveyQuestionResponse in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_survey_question_response_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_question_response_id: ID of the SurveyQuestionResponse you want to look up
        :return: list[SurveyQuestionResponseItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['survey_question_response_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_survey_question_response" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'survey_question_response_id' in params:
            query_params.append(('SurveyQuestionResponseID', params['survey_question_response_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/SurveyQuestionResponse', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SurveyQuestionResponseItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_survey_response(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SurveyResponse in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_survey_response(async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_response_id: ID of the SurveyResponse you want to look up
        :return: list[SurveyResponseItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_survey_response_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_survey_response_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_survey_response_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SurveyResponse in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_survey_response_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_response_id: ID of the SurveyResponse you want to look up
        :return: list[SurveyResponseItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['survey_response_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_survey_response" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'survey_response_id' in params:
            query_params.append(('SurveyResponseID', params['survey_response_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/SurveyResponse', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SurveyResponseItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_survey_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SurveyType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_survey_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_type_id: ID of the SurveyType you want to look up
        :return: list[SurveyTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_survey_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_survey_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_survey_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SurveyType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_survey_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_type_id: ID of the SurveyType you want to look up
        :return: list[SurveyTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['survey_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_survey_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'survey_type_id' in params:
            query_params.append(('SurveyTypeID', params['survey_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/SurveyType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SurveyTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_system_activity(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SystemActivity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_system_activity(async=True)
        >>> result = thread.get()

        :param async bool
        :param int system_activity_id: ID of the SystemActivity you want to look up
        :return: list[SystemActivityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_system_activity_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_system_activity_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_system_activity_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a SystemActivity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_system_activity_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int system_activity_id: ID of the SystemActivity you want to look up
        :return: list[SystemActivityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_activity_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_system_activity" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_activity_id' in params:
            query_params.append(('SystemActivityID', params['system_activity_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/SystemActivity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SystemActivityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_task(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Task in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_task(async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_id: ID of the Task you want to look up
        :return: list[TaskItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_task_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_task_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_task_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Task in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_task_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_id: ID of the Task you want to look up
        :return: list[TaskItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_task" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'task_id' in params:
            query_params.append(('TaskID', params['task_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Task', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TaskItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_task_runner_history(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TaskRunnerHistory in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_task_runner_history(async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_runner_history_id: ID of the TaskRunnerHistory you want to look up
        :return: list[TaskRunnerHistoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_task_runner_history_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_task_runner_history_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_task_runner_history_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TaskRunnerHistory in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_task_runner_history_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_runner_history_id: ID of the TaskRunnerHistory you want to look up
        :return: list[TaskRunnerHistoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_runner_history_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_task_runner_history" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'task_runner_history_id' in params:
            query_params.append(('TaskRunnerHistoryID', params['task_runner_history_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TaskRunnerHistory', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TaskRunnerHistoryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_task_status(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TaskStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_task_status(async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_status_id: ID of the TaskStatus you want to look up
        :return: list[TaskStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_task_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_task_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_task_status_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TaskStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_task_status_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_status_id: ID of the TaskStatus you want to look up
        :return: list[TaskStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_status_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_task_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'task_status_id' in params:
            query_params.append(('TaskStatusID', params['task_status_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TaskStatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TaskStatusItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_task_template(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TaskTemplate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_task_template(async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_template_id: ID of the TaskTemplate you want to look up
        :return: list[TaskTemplateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_task_template_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_task_template_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_task_template_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TaskTemplate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_task_template_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_template_id: ID of the TaskTemplate you want to look up
        :return: list[TaskTemplateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_template_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_task_template" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'task_template_id' in params:
            query_params.append(('TaskTemplateID', params['task_template_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TaskTemplate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TaskTemplateItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_task_template_item(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TaskTemplateItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_task_template_item(async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_template_item_id: ID of the TaskTemplateItem you want to look up
        :return: list[TaskTemplateItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_task_template_item_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_task_template_item_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_task_template_item_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TaskTemplateItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_task_template_item_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_template_item_id: ID of the TaskTemplateItem you want to look up
        :return: list[TaskTemplateItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_template_item_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_task_template_item" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'task_template_item_id' in params:
            query_params.append(('TaskTemplateItemID', params['task_template_item_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TaskTemplateItem', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TaskTemplateItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_task_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TaskType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_task_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_type_id: ID of the TaskType you want to look up
        :return: list[TaskTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_task_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_task_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_task_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TaskType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_task_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_type_id: ID of the TaskType you want to look up
        :return: list[TaskTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_task_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'task_type_id' in params:
            query_params.append(('TaskTypeID', params['task_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TaskType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TaskTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_template(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Template in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_template(async=True)
        >>> result = thread.get()

        :param async bool
        :param int template_id: ID of the Template you want to look up
        :return: list[TemplateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_template_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_template_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_template_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Template in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_template_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int template_id: ID of the Template you want to look up
        :return: list[TemplateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_template" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'template_id' in params:
            query_params.append(('TemplateID', params['template_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Template', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TemplateItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_template_permission(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TemplatePermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_template_permission(async=True)
        >>> result = thread.get()

        :param async bool
        :param int template_permission_id: ID of the TemplatePermission you want to look up
        :return: list[TemplatePermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_template_permission_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_template_permission_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_template_permission_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TemplatePermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_template_permission_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int template_permission_id: ID of the TemplatePermission you want to look up
        :return: list[TemplatePermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_permission_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_template_permission" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'template_permission_id' in params:
            query_params.append(('TemplatePermissionID', params['template_permission_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TemplatePermission', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TemplatePermissionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_term(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Term in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_term(async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_id: ID of the Term you want to look up
        :return: list[TermItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_term_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_term_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_term_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Term in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_term_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_id: ID of the Term you want to look up
        :return: list[TermItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['term_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_term" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'term_id' in params:
            query_params.append(('TermID', params['term_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Term', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TermItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_term_rule(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TermRule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_term_rule(async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_rule_id: ID of the TermRule you want to look up
        :return: list[TermRuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_term_rule_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_term_rule_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_term_rule_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TermRule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_term_rule_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_rule_id: ID of the TermRule you want to look up
        :return: list[TermRuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['term_rule_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_term_rule" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'term_rule_id' in params:
            query_params.append(('TermRuleID', params['term_rule_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TermRule', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TermRuleItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_term_session(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TermSession in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_term_session(async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_session_id: ID of the TermSession you want to look up
        :return: list[TermSessionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_term_session_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_term_session_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_term_session_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TermSession in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_term_session_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_session_id: ID of the TermSession you want to look up
        :return: list[TermSessionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['term_session_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_term_session" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'term_session_id' in params:
            query_params.append(('TermSessionID', params['term_session_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TermSession', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TermSessionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_term_session_free(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TermSessionFree in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_term_session_free(async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_session_free_id: ID of the TermSessionFree you want to look up
        :return: list[TermSessionFreeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_term_session_free_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_term_session_free_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_term_session_free_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TermSessionFree in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_term_session_free_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_session_free_id: ID of the TermSessionFree you want to look up
        :return: list[TermSessionFreeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['term_session_free_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_term_session_free" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'term_session_free_id' in params:
            query_params.append(('TermSessionFreeID', params['term_session_free_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TermSessionFree', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TermSessionFreeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_term_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TermType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_term_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_type_id: ID of the TermType you want to look up
        :return: list[TermTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_term_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_term_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_term_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TermType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_term_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_type_id: ID of the TermType you want to look up
        :return: list[TermTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['term_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_term_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'term_type_id' in params:
            query_params.append(('TermTypeID', params['term_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TermType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TermTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_time_slot(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TimeSlot in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_time_slot(async=True)
        >>> result = thread.get()

        :param async bool
        :param int time_slot_id: ID of the TimeSlot you want to look up
        :return: list[TimeSlotItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_time_slot_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_time_slot_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_time_slot_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TimeSlot in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_time_slot_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int time_slot_id: ID of the TimeSlot you want to look up
        :return: list[TimeSlotItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['time_slot_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_time_slot" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'time_slot_id' in params:
            query_params.append(('TimeSlotID', params['time_slot_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TimeSlot', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TimeSlotItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_title(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Title in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_title(async=True)
        >>> result = thread.get()

        :param async bool
        :param int title_id: ID of the Title you want to look up
        :return: list[TitleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_title_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_title_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_title_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Title in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_title_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int title_id: ID of the Title you want to look up
        :return: list[TitleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['title_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_title" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'title_id' in params:
            query_params.append(('TitleID', params['title_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Title', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TitleItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_total(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Total in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_total(async=True)
        >>> result = thread.get()

        :param async bool
        :param int total_id: ID of the Total you want to look up
        :return: list[TotalItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_total_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_total_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_total_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Total in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_total_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int total_id: ID of the Total you want to look up
        :return: list[TotalItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['total_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_total" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'total_id' in params:
            query_params.append(('TotalID', params['total_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Total', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TotalItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_transaction(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Transaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_id: ID of the Transaction you want to look up
        :return: list[TransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_transaction_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_transaction_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_transaction_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Transaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_id: ID of the Transaction you want to look up
        :return: list[TransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_transaction" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'transaction_id' in params:
            query_params.append(('TransactionID', params['transaction_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Transaction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_transaction_dispute(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TransactionDispute in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction_dispute(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_dispute_id: ID of the TransactionDispute you want to look up
        :return: list[TransactionDisputeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_transaction_dispute_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_transaction_dispute_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_transaction_dispute_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TransactionDispute in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction_dispute_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_dispute_id: ID of the TransactionDispute you want to look up
        :return: list[TransactionDisputeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_dispute_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_transaction_dispute" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'transaction_dispute_id' in params:
            query_params.append(('TransactionDisputeID', params['transaction_dispute_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TransactionDispute', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionDisputeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_transaction_dispute_custom_field(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TransactionDisputeCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction_dispute_custom_field(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_dispute_custom_field_id: ID of the TransactionDisputeCustomField you want to look up
        :return: list[TransactionDisputeCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_transaction_dispute_custom_field_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_transaction_dispute_custom_field_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_transaction_dispute_custom_field_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TransactionDisputeCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction_dispute_custom_field_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_dispute_custom_field_id: ID of the TransactionDisputeCustomField you want to look up
        :return: list[TransactionDisputeCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_dispute_custom_field_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_transaction_dispute_custom_field" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'transaction_dispute_custom_field_id' in params:
            query_params.append(('TransactionDisputeCustomFieldID', params['transaction_dispute_custom_field_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TransactionDisputeCustomField', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionDisputeCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_transaction_dispute_item(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TransactionDisputeItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction_dispute_item(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_dispute_item_id: ID of the TransactionDisputeItem you want to look up
        :return: list[TransactionDisputeItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_transaction_dispute_item_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_transaction_dispute_item_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_transaction_dispute_item_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TransactionDisputeItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction_dispute_item_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_dispute_item_id: ID of the TransactionDisputeItem you want to look up
        :return: list[TransactionDisputeItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_dispute_item_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_transaction_dispute_item" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'transaction_dispute_item_id' in params:
            query_params.append(('TransactionDisputeItemID', params['transaction_dispute_item_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TransactionDisputeItem', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionDisputeItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_transaction_link(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TransactionLink in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction_link(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_link_id: ID of the TransactionLink you want to look up
        :return: list[TransactionLinkItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_transaction_link_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_transaction_link_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_transaction_link_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TransactionLink in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction_link_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_link_id: ID of the TransactionLink you want to look up
        :return: list[TransactionLinkItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_link_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_transaction_link" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'transaction_link_id' in params:
            query_params.append(('TransactionLinkID', params['transaction_link_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TransactionLink', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionLinkItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_transaction_link_item(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TransactionLinkItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction_link_item(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_link_item_id: ID of the TransactionLinkItem you want to look up
        :return: list[TransactionLinkItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_transaction_link_item_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_transaction_link_item_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_transaction_link_item_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TransactionLinkItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction_link_item_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_link_item_id: ID of the TransactionLinkItem you want to look up
        :return: list[TransactionLinkItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_link_item_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_transaction_link_item" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'transaction_link_item_id' in params:
            query_params.append(('TransactionLinkItemID', params['transaction_link_item_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TransactionLinkItem', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionLinkItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_transaction_tag(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TransactionTag in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction_tag(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_tag_id: ID of the TransactionTag you want to look up
        :return: list[TransactionTagItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_transaction_tag_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_transaction_tag_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_transaction_tag_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TransactionTag in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction_tag_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_tag_id: ID of the TransactionTag you want to look up
        :return: list[TransactionTagItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_tag_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_transaction_tag" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'transaction_tag_id' in params:
            query_params.append(('TransactionTagID', params['transaction_tag_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TransactionTag', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionTagItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_transaction_template(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TransactionTemplate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction_template(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_template_id: ID of the TransactionTemplate you want to look up
        :return: list[TransactionTemplateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_transaction_template_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_transaction_template_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_transaction_template_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TransactionTemplate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction_template_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_template_id: ID of the TransactionTemplate you want to look up
        :return: list[TransactionTemplateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_template_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_transaction_template" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'transaction_template_id' in params:
            query_params.append(('TransactionTemplateID', params['transaction_template_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TransactionTemplate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionTemplateItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_transaction_template_item(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TransactionTemplateItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction_template_item(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_template_item_id: ID of the TransactionTemplateItem you want to look up
        :return: list[TransactionTemplateItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_transaction_template_item_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_transaction_template_item_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_transaction_template_item_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a TransactionTemplateItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_transaction_template_item_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_template_item_id: ID of the TransactionTemplateItem you want to look up
        :return: list[TransactionTemplateItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_template_item_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_transaction_template_item" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'transaction_template_item_id' in params:
            query_params.append(('TransactionTemplateItemID', params['transaction_template_item_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/TransactionTemplateItem', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionTemplateItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_visitor(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Visitor in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_visitor(async=True)
        >>> result = thread.get()

        :param async bool
        :param int visitor_id: ID of the Visitor you want to look up
        :return: list[VisitorItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_visitor_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_visitor_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_visitor_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Visitor in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_visitor_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int visitor_id: ID of the Visitor you want to look up
        :return: list[VisitorItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['visitor_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_visitor" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'visitor_id' in params:
            query_params.append(('VisitorID', params['visitor_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Visitor', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VisitorItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_visitor_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VisitorType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_visitor_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int visitor_type_id: ID of the VisitorType you want to look up
        :return: list[VisitorTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_visitor_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_visitor_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_visitor_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VisitorType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_visitor_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int visitor_type_id: ID of the VisitorType you want to look up
        :return: list[VisitorTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['visitor_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_visitor_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'visitor_type_id' in params:
            query_params.append(('VisitorTypeID', params['visitor_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/VisitorType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VisitorTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_vm_data(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMData in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_data(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_data_id: ID of the VMData you want to look up
        :return: list[VMDataItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_vm_data_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_vm_data_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_vm_data_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMData in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_data_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_data_id: ID of the VMData you want to look up
        :return: list[VMDataItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_data_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_vm_data" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'vm_data_id' in params:
            query_params.append(('VMDataID', params['vm_data_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/VMData', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMDataItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_vm_group(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_group(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_group_id: ID of the VMGroup you want to look up
        :return: list[VMGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_vm_group_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_vm_group_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_vm_group_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_group_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_group_id: ID of the VMGroup you want to look up
        :return: list[VMGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_group_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_vm_group" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'vm_group_id' in params:
            query_params.append(('VMGroupID', params['vm_group_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/VMGroup', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMGroupItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_vm_group_extension(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMGroupExtension in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_group_extension(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_group_extension_id: ID of the VMGroupExtension you want to look up
        :return: list[VMGroupExtensionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_vm_group_extension_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_vm_group_extension_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_vm_group_extension_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMGroupExtension in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_group_extension_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_group_extension_id: ID of the VMGroupExtension you want to look up
        :return: list[VMGroupExtensionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_group_extension_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_vm_group_extension" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'vm_group_extension_id' in params:
            query_params.append(('VMGroupExtensionID', params['vm_group_extension_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/VMGroupExtension', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMGroupExtensionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_vm_group_mail_box(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMGroupMailBox in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_group_mail_box(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_group_mail_box_id: ID of the VMGroupMailBox you want to look up
        :return: list[VMGroupMailBoxItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_vm_group_mail_box_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_vm_group_mail_box_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_vm_group_mail_box_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMGroupMailBox in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_group_mail_box_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_group_mail_box_id: ID of the VMGroupMailBox you want to look up
        :return: list[VMGroupMailBoxItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_group_mail_box_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_vm_group_mail_box" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'vm_group_mail_box_id' in params:
            query_params.append(('VMGroupMailBoxID', params['vm_group_mail_box_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/VMGroupMailBox', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMGroupMailBoxItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_vm_group_message(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMGroupMessage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_group_message(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_group_message_id: ID of the VMGroupMessage you want to look up
        :return: list[VMGroupMessageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_vm_group_message_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_vm_group_message_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_vm_group_message_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMGroupMessage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_group_message_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_group_message_id: ID of the VMGroupMessage you want to look up
        :return: list[VMGroupMessageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_group_message_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_vm_group_message" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'vm_group_message_id' in params:
            query_params.append(('VMGroupMessageID', params['vm_group_message_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/VMGroupMessage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMGroupMessageItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_vm_line_usage(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMLineUsage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_line_usage(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_line_usage_id: ID of the VMLineUsage you want to look up
        :return: list[VMLineUsageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_vm_line_usage_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_vm_line_usage_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_vm_line_usage_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMLineUsage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_line_usage_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_line_usage_id: ID of the VMLineUsage you want to look up
        :return: list[VMLineUsageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_line_usage_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_vm_line_usage" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'vm_line_usage_id' in params:
            query_params.append(('VMLineUsageID', params['vm_line_usage_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/VMLineUsage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMLineUsageItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_vm_mail_box(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMMailBox in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_mail_box(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_mail_box_id: ID of the VMMailBox you want to look up
        :return: list[VMMailBoxItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_vm_mail_box_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_vm_mail_box_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_vm_mail_box_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMMailBox in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_mail_box_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_mail_box_id: ID of the VMMailBox you want to look up
        :return: list[VMMailBoxItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_mail_box_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_vm_mail_box" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'vm_mail_box_id' in params:
            query_params.append(('VMMailBoxID', params['vm_mail_box_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/VMMailBox', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMMailBoxItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_vm_mail_box_type(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMMailBoxType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_mail_box_type(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_mail_box_type_id: ID of the VMMailBoxType you want to look up
        :return: list[VMMailBoxTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_vm_mail_box_type_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_vm_mail_box_type_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_vm_mail_box_type_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMMailBoxType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_mail_box_type_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_mail_box_type_id: ID of the VMMailBoxType you want to look up
        :return: list[VMMailBoxTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_mail_box_type_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_vm_mail_box_type" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'vm_mail_box_type_id' in params:
            query_params.append(('VMMailBoxTypeID', params['vm_mail_box_type_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/VMMailBoxType', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMMailBoxTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_vm_message(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMMessage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_message(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_message_id: ID of the VMMessage you want to look up
        :return: list[VMMessageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_vm_message_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_vm_message_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_vm_message_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMMessage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_message_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_message_id: ID of the VMMessage you want to look up
        :return: list[VMMessageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_message_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_vm_message" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'vm_message_id' in params:
            query_params.append(('VMMessageID', params['vm_message_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/VMMessage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMMessageItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_vm_message_lamp(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMMessageLamp in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_message_lamp(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_message_lamp_id: ID of the VMMessageLamp you want to look up
        :return: list[VMMessageLampItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_vm_message_lamp_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_vm_message_lamp_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_vm_message_lamp_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMMessageLamp in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vm_message_lamp_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_message_lamp_id: ID of the VMMessageLamp you want to look up
        :return: list[VMMessageLampItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_message_lamp_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_vm_message_lamp" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'vm_message_lamp_id' in params:
            query_params.append(('VMMessageLampID', params['vm_message_lamp_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/VMMessageLamp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMMessageLampItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_vmmci(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMMCI in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vmmci(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vmmciid: ID of the VMMCI you want to look up
        :return: list[VMMCIItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_vmmci_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_vmmci_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_vmmci_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a VMMCI in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_vmmci_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int vmmciid: ID of the VMMCI you want to look up
        :return: list[VMMCIItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vmmciid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_vmmci" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'vmmciid' in params:
            query_params.append(('VMMCIID', params['vmmciid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/VMMCI', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMMCIItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_wait_list(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WaitList in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_wait_list(async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_id: ID of the WaitList you want to look up
        :return: list[WaitListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_wait_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_wait_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_wait_list_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WaitList in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_wait_list_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_id: ID of the WaitList you want to look up
        :return: list[WaitListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wait_list_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_wait_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'wait_list_id' in params:
            query_params.append(('WaitListID', params['wait_list_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WaitList', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WaitListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_wait_list_classification(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WaitListClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_wait_list_classification(async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_classification_id: ID of the WaitListClassification you want to look up
        :return: list[WaitListClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_wait_list_classification_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_wait_list_classification_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_wait_list_classification_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WaitListClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_wait_list_classification_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_classification_id: ID of the WaitListClassification you want to look up
        :return: list[WaitListClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wait_list_classification_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_wait_list_classification" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'wait_list_classification_id' in params:
            query_params.append(('WaitListClassificationID', params['wait_list_classification_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WaitListClassification', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WaitListClassificationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_wait_list_entry_application(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WaitListEntryApplication in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_wait_list_entry_application(async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_entry_application_id: ID of the WaitListEntryApplication you want to look up
        :return: list[WaitListEntryApplicationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_wait_list_entry_application_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_wait_list_entry_application_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_wait_list_entry_application_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WaitListEntryApplication in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_wait_list_entry_application_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_entry_application_id: ID of the WaitListEntryApplication you want to look up
        :return: list[WaitListEntryApplicationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wait_list_entry_application_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_wait_list_entry_application" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'wait_list_entry_application_id' in params:
            query_params.append(('WaitListEntryApplicationID', params['wait_list_entry_application_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WaitListEntryApplication', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WaitListEntryApplicationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_wait_list_profile(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WaitListProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_wait_list_profile(async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_profile_id: ID of the WaitListProfile you want to look up
        :return: list[WaitListProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_wait_list_profile_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_wait_list_profile_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_wait_list_profile_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WaitListProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_wait_list_profile_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_profile_id: ID of the WaitListProfile you want to look up
        :return: list[WaitListProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wait_list_profile_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_wait_list_profile" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'wait_list_profile_id' in params:
            query_params.append(('WaitListProfileID', params['wait_list_profile_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WaitListProfile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WaitListProfileItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_wait_list_room_space(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WaitListRoomSpace in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_wait_list_room_space(async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_room_space_id: ID of the WaitListRoomSpace you want to look up
        :return: list[WaitListRoomSpaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_wait_list_room_space_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_wait_list_room_space_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_wait_list_room_space_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WaitListRoomSpace in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_wait_list_room_space_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_room_space_id: ID of the WaitListRoomSpace you want to look up
        :return: list[WaitListRoomSpaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wait_list_room_space_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_wait_list_room_space" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'wait_list_room_space_id' in params:
            query_params.append(('WaitListRoomSpaceID', params['wait_list_room_space_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WaitListRoomSpace', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WaitListRoomSpaceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_web_block(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebBlock in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_block(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_block_id: ID of the WebBlock you want to look up
        :return: list[WebBlockItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_web_block_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_web_block_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_web_block_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebBlock in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_block_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_block_id: ID of the WebBlock you want to look up
        :return: list[WebBlockItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_block_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_web_block" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'web_block_id' in params:
            query_params.append(('WebBlockID', params['web_block_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WebBlock', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebBlockItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_web_control(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebControl in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_control(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_control_id: ID of the WebControl you want to look up
        :return: list[WebControlItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_web_control_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_web_control_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_web_control_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebControl in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_control_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_control_id: ID of the WebControl you want to look up
        :return: list[WebControlItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_control_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_web_control" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'web_control_id' in params:
            query_params.append(('WebControlID', params['web_control_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WebControl', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebControlItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_web_email_text(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebEmailText in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_email_text(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_email_text_id: ID of the WebEmailText you want to look up
        :return: list[WebEmailTextItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_web_email_text_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_web_email_text_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_web_email_text_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebEmailText in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_email_text_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_email_text_id: ID of the WebEmailText you want to look up
        :return: list[WebEmailTextItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_email_text_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_web_email_text" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'web_email_text_id' in params:
            query_params.append(('WebEmailTextID', params['web_email_text_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WebEmailText', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebEmailTextItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_web_field(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_field(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_field_id: ID of the WebField you want to look up
        :return: list[WebFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_web_field_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_web_field_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_web_field_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_field_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_field_id: ID of the WebField you want to look up
        :return: list[WebFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_field_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_web_field" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'web_field_id' in params:
            query_params.append(('WebFieldID', params['web_field_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WebField', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_web_log(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebLog in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_log(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_log_id: ID of the WebLog you want to look up
        :return: list[WebLogItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_web_log_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_web_log_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_web_log_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebLog in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_log_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_log_id: ID of the WebLog you want to look up
        :return: list[WebLogItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_log_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_web_log" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'web_log_id' in params:
            query_params.append(('WebLogID', params['web_log_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WebLog', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebLogItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_web_menu(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebMenu in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_menu(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_menu_id: ID of the WebMenu you want to look up
        :return: list[WebMenuItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_web_menu_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_web_menu_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_web_menu_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebMenu in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_menu_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_menu_id: ID of the WebMenu you want to look up
        :return: list[WebMenuItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_menu_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_web_menu" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'web_menu_id' in params:
            query_params.append(('WebMenuID', params['web_menu_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WebMenu', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebMenuItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_web_menu_classification(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebMenuClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_menu_classification(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_menu_classification_id: ID of the WebMenuClassification you want to look up
        :return: list[WebMenuClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_web_menu_classification_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_web_menu_classification_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_web_menu_classification_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebMenuClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_menu_classification_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_menu_classification_id: ID of the WebMenuClassification you want to look up
        :return: list[WebMenuClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_menu_classification_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_web_menu_classification" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'web_menu_classification_id' in params:
            query_params.append(('WebMenuClassificationID', params['web_menu_classification_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WebMenuClassification', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebMenuClassificationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_web_module(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebModule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_module(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_module_id: ID of the WebModule you want to look up
        :return: list[WebModuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_web_module_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_web_module_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_web_module_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebModule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_module_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_module_id: ID of the WebModule you want to look up
        :return: list[WebModuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_module_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_web_module" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'web_module_id' in params:
            query_params.append(('WebModuleID', params['web_module_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WebModule', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebModuleItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_web_payment(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebPayment in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_payment(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_payment_id: ID of the WebPayment you want to look up
        :return: list[WebPaymentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_web_payment_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_web_payment_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_web_payment_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebPayment in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_payment_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_payment_id: ID of the WebPayment you want to look up
        :return: list[WebPaymentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_payment_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_web_payment" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'web_payment_id' in params:
            query_params.append(('WebPaymentID', params['web_payment_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WebPayment', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebPaymentItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_web_rule(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebRule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_rule(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_rule_id: ID of the WebRule you want to look up
        :return: list[WebRuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_web_rule_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_web_rule_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_web_rule_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebRule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_rule_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_rule_id: ID of the WebRule you want to look up
        :return: list[WebRuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_rule_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_web_rule" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'web_rule_id' in params:
            query_params.append(('WebRuleID', params['web_rule_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WebRule', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebRuleItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_web_rule_link(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebRuleLink in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_rule_link(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_rule_link_id: ID of the WebRuleLink you want to look up
        :return: list[WebRuleLinkItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_web_rule_link_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_web_rule_link_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_web_rule_link_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebRuleLink in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_rule_link_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_rule_link_id: ID of the WebRuleLink you want to look up
        :return: list[WebRuleLinkItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_rule_link_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_web_rule_link" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'web_rule_link_id' in params:
            query_params.append(('WebRuleLinkID', params['web_rule_link_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WebRuleLink', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebRuleLinkItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_web_section(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebSection in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_section(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_section_id: ID of the WebSection you want to look up
        :return: list[WebSectionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_web_section_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_web_section_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_web_section_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebSection in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_section_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_section_id: ID of the WebSection you want to look up
        :return: list[WebSectionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_section_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_web_section" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'web_section_id' in params:
            query_params.append(('WebSectionID', params['web_section_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WebSection', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebSectionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_web_section_text_block(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebSectionTextBlock in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_section_text_block(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_section_text_block_id: ID of the WebSectionTextBlock you want to look up
        :return: list[WebSectionTextBlockItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_web_section_text_block_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_web_section_text_block_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_web_section_text_block_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebSectionTextBlock in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_section_text_block_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_section_text_block_id: ID of the WebSectionTextBlock you want to look up
        :return: list[WebSectionTextBlockItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_section_text_block_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_web_section_text_block" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'web_section_text_block_id' in params:
            query_params.append(('WebSectionTextBlockID', params['web_section_text_block_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WebSectionTextBlock', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebSectionTextBlockItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_web_setting(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebSetting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_setting(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_setting_id: ID of the WebSetting you want to look up
        :return: list[WebSettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_web_setting_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_web_setting_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_web_setting_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebSetting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_setting_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_setting_id: ID of the WebSetting you want to look up
        :return: list[WebSettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_setting_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_web_setting" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'web_setting_id' in params:
            query_params.append(('WebSettingID', params['web_setting_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WebSetting', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebSettingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_web_site(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebSite in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_site(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_site_id: ID of the WebSite you want to look up
        :return: list[WebSiteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_web_site_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_web_site_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_web_site_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebSite in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_site_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_site_id: ID of the WebSite you want to look up
        :return: list[WebSiteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_site_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_web_site" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'web_site_id' in params:
            query_params.append(('WebSiteID', params['web_site_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WebSite', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebSiteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_web_transaction(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebTransaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_transaction(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_transaction_id: ID of the WebTransaction you want to look up
        :return: list[WebTransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_web_transaction_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_web_transaction_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_web_transaction_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WebTransaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_web_transaction_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_transaction_id: ID of the WebTransaction you want to look up
        :return: list[WebTransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_transaction_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_web_transaction" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'web_transaction_id' in params:
            query_params.append(('WebTransactionID', params['web_transaction_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WebTransaction', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebTransactionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_workflow(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Workflow in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_workflow(async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_id: ID of the Workflow you want to look up
        :return: list[WorkflowItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_workflow_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_workflow_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_workflow_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a Workflow in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_workflow_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_id: ID of the Workflow you want to look up
        :return: list[WorkflowItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['workflow_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_workflow" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'workflow_id' in params:
            query_params.append(('WorkflowID', params['workflow_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/Workflow', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WorkflowItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_workflow_history(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WorkflowHistory in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_workflow_history(async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_history_id: ID of the WorkflowHistory you want to look up
        :return: list[WorkflowHistoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_workflow_history_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_workflow_history_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_workflow_history_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WorkflowHistory in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_workflow_history_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_history_id: ID of the WorkflowHistory you want to look up
        :return: list[WorkflowHistoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['workflow_history_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_workflow_history" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'workflow_history_id' in params:
            query_params.append(('WorkflowHistoryID', params['workflow_history_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WorkflowHistory', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WorkflowHistoryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_workflow_permission(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WorkflowPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_workflow_permission(async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_permission_id: ID of the WorkflowPermission you want to look up
        :return: list[WorkflowPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_workflow_permission_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_workflow_permission_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_workflow_permission_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WorkflowPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_workflow_permission_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_permission_id: ID of the WorkflowPermission you want to look up
        :return: list[WorkflowPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['workflow_permission_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_workflow_permission" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'workflow_permission_id' in params:
            query_params.append(('WorkflowPermissionID', params['workflow_permission_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WorkflowPermission', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WorkflowPermissionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_workflow_step(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WorkflowStep in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_workflow_step(async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_step_id: ID of the WorkflowStep you want to look up
        :return: list[WorkflowStepItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_workflow_step_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_workflow_step_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_workflow_step_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WorkflowStep in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_workflow_step_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_step_id: ID of the WorkflowStep you want to look up
        :return: list[WorkflowStepItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['workflow_step_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_workflow_step" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'workflow_step_id' in params:
            query_params.append(('WorkflowStepID', params['workflow_step_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WorkflowStep', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WorkflowStepItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_workflow_step_permission(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WorkflowStepPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_workflow_step_permission(async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_step_permission_id: ID of the WorkflowStepPermission you want to look up
        :return: list[WorkflowStepPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_workflow_step_permission_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_workflow_step_permission_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_workflow_step_permission_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a WorkflowStepPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_workflow_step_permission_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_step_permission_id: ID of the WorkflowStepPermission you want to look up
        :return: list[WorkflowStepPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['workflow_step_permission_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_workflow_step_permission" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'workflow_step_permission_id' in params:
            query_params.append(('WorkflowStepPermissionID', params['workflow_step_permission_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/WorkflowStepPermission', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WorkflowStepPermissionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_zip_post_code(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ZipPostCode in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_zip_post_code(async=True)
        >>> result = thread.get()

        :param async bool
        :param int zip_post_code_id: ID of the ZipPostCode you want to look up
        :return: list[ZipPostCodeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_zip_post_code_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_zip_post_code_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_zip_post_code_with_http_info(self, **kwargs):  # noqa: E501
        """  # noqa: E501

        By passing in the appropriate options, you can search for a ZipPostCode in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_zip_post_code_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param int zip_post_code_id: ID of the ZipPostCode you want to look up
        :return: list[ZipPostCodeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['zip_post_code_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_zip_post_code" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'zip_post_code_id' in params:
            query_params.append(('ZipPostCodeID', params['zip_post_code_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'select/ZipPostCode', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ZipPostCodeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_address_type(self, address_type_id, address_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an AddressType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_address_type(address_type_id, address_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int address_type_id: Numeric value of the addresstypeID (required)
        :param AddressTypeItem address_type_item: AddressType to update (required)
        :return: list[AddressTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_address_type_with_http_info(address_type_id, address_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_address_type_with_http_info(address_type_id, address_type_item, **kwargs)  # noqa: E501
            return data

    def update_address_type_with_http_info(self, address_type_id, address_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an AddressType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_address_type_with_http_info(address_type_id, address_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int address_type_id: Numeric value of the addresstypeID (required)
        :param AddressTypeItem address_type_item: AddressType to update (required)
        :return: list[AddressTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address_type_id', 'address_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_address_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address_type_id' is set
        if ('address_type_id' not in params or
                params['address_type_id'] is None):
            raise ValueError("Missing the required parameter `address_type_id` when calling `update_address_type`")  # noqa: E501
        # verify the required parameter 'address_type_item' is set
        if ('address_type_item' not in params or
                params['address_type_item'] is None):
            raise ValueError("Missing the required parameter `address_type_item` when calling `update_address_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address_type_id' in params:
            path_params['AddressTypeID'] = params['address_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'address_type_item' in params:
            body_params = params['address_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/AddressType/{AddressTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AddressTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_application_status(self, application_status_id, application_status_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ApplicationStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_application_status(application_status_id, application_status_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int application_status_id: Numeric value of the applicationstatusID (required)
        :param ApplicationStatusItem application_status_item: ApplicationStatus to update (required)
        :return: list[ApplicationStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_application_status_with_http_info(application_status_id, application_status_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_application_status_with_http_info(application_status_id, application_status_item, **kwargs)  # noqa: E501
            return data

    def update_application_status_with_http_info(self, application_status_id, application_status_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ApplicationStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_application_status_with_http_info(application_status_id, application_status_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int application_status_id: Numeric value of the applicationstatusID (required)
        :param ApplicationStatusItem application_status_item: ApplicationStatus to update (required)
        :return: list[ApplicationStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_status_id', 'application_status_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_application_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_status_id' is set
        if ('application_status_id' not in params or
                params['application_status_id'] is None):
            raise ValueError("Missing the required parameter `application_status_id` when calling `update_application_status`")  # noqa: E501
        # verify the required parameter 'application_status_item' is set
        if ('application_status_item' not in params or
                params['application_status_item'] is None):
            raise ValueError("Missing the required parameter `application_status_item` when calling `update_application_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_status_id' in params:
            path_params['ApplicationStatusID'] = params['application_status_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'application_status_item' in params:
            body_params = params['application_status_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ApplicationStatus/{ApplicationStatusID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ApplicationStatusItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_auto_allocate_run(self, auto_allocate_run_id, auto_allocate_run_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an AutoAllocateRun in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_auto_allocate_run(auto_allocate_run_id, auto_allocate_run_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int auto_allocate_run_id: Numeric value of the autoallocaterunID (required)
        :param AutoAllocateRunItem auto_allocate_run_item: AutoAllocateRun to update (required)
        :return: list[AutoAllocateRunItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_auto_allocate_run_with_http_info(auto_allocate_run_id, auto_allocate_run_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_auto_allocate_run_with_http_info(auto_allocate_run_id, auto_allocate_run_item, **kwargs)  # noqa: E501
            return data

    def update_auto_allocate_run_with_http_info(self, auto_allocate_run_id, auto_allocate_run_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an AutoAllocateRun in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_auto_allocate_run_with_http_info(auto_allocate_run_id, auto_allocate_run_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int auto_allocate_run_id: Numeric value of the autoallocaterunID (required)
        :param AutoAllocateRunItem auto_allocate_run_item: AutoAllocateRun to update (required)
        :return: list[AutoAllocateRunItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['auto_allocate_run_id', 'auto_allocate_run_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_auto_allocate_run" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'auto_allocate_run_id' is set
        if ('auto_allocate_run_id' not in params or
                params['auto_allocate_run_id'] is None):
            raise ValueError("Missing the required parameter `auto_allocate_run_id` when calling `update_auto_allocate_run`")  # noqa: E501
        # verify the required parameter 'auto_allocate_run_item' is set
        if ('auto_allocate_run_item' not in params or
                params['auto_allocate_run_item'] is None):
            raise ValueError("Missing the required parameter `auto_allocate_run_item` when calling `update_auto_allocate_run`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'auto_allocate_run_id' in params:
            path_params['AutoAllocateRunID'] = params['auto_allocate_run_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'auto_allocate_run_item' in params:
            body_params = params['auto_allocate_run_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/AutoAllocateRun/{AutoAllocateRunID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AutoAllocateRunItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_booking(self, booking_id, booking_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Booking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_booking(booking_id, booking_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_id: Numeric value of the bookingID (required)
        :param BookingItem booking_item: Booking to update (required)
        :return: list[BookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_booking_with_http_info(booking_id, booking_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_booking_with_http_info(booking_id, booking_item, **kwargs)  # noqa: E501
            return data

    def update_booking_with_http_info(self, booking_id, booking_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Booking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_booking_with_http_info(booking_id, booking_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_id: Numeric value of the bookingID (required)
        :param BookingItem booking_item: Booking to update (required)
        :return: list[BookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['booking_id', 'booking_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_booking" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'booking_id' is set
        if ('booking_id' not in params or
                params['booking_id'] is None):
            raise ValueError("Missing the required parameter `booking_id` when calling `update_booking`")  # noqa: E501
        # verify the required parameter 'booking_item' is set
        if ('booking_item' not in params or
                params['booking_item'] is None):
            raise ValueError("Missing the required parameter `booking_item` when calling `update_booking`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'booking_id' in params:
            path_params['BookingID'] = params['booking_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'booking_item' in params:
            body_params = params['booking_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Booking/{BookingID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BookingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_booking_agreement(self, booking_agreement_id, booking_agreement_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an BookingAgreement in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_booking_agreement(booking_agreement_id, booking_agreement_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_agreement_id: Numeric value of the bookingagreementID (required)
        :param BookingAgreementItem booking_agreement_item: BookingAgreement to update (required)
        :return: list[BookingAgreementItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_booking_agreement_with_http_info(booking_agreement_id, booking_agreement_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_booking_agreement_with_http_info(booking_agreement_id, booking_agreement_item, **kwargs)  # noqa: E501
            return data

    def update_booking_agreement_with_http_info(self, booking_agreement_id, booking_agreement_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an BookingAgreement in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_booking_agreement_with_http_info(booking_agreement_id, booking_agreement_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_agreement_id: Numeric value of the bookingagreementID (required)
        :param BookingAgreementItem booking_agreement_item: BookingAgreement to update (required)
        :return: list[BookingAgreementItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['booking_agreement_id', 'booking_agreement_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_booking_agreement" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'booking_agreement_id' is set
        if ('booking_agreement_id' not in params or
                params['booking_agreement_id'] is None):
            raise ValueError("Missing the required parameter `booking_agreement_id` when calling `update_booking_agreement`")  # noqa: E501
        # verify the required parameter 'booking_agreement_item' is set
        if ('booking_agreement_item' not in params or
                params['booking_agreement_item'] is None):
            raise ValueError("Missing the required parameter `booking_agreement_item` when calling `update_booking_agreement`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'booking_agreement_id' in params:
            path_params['BookingAgreementID'] = params['booking_agreement_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'booking_agreement_item' in params:
            body_params = params['booking_agreement_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/BookingAgreement/{BookingAgreementID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BookingAgreementItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_booking_custom_field(self, booking_custom_field_id, booking_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an BookingCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_booking_custom_field(booking_custom_field_id, booking_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_custom_field_id: Numeric value of the bookingcustomfieldID (required)
        :param BookingCustomFieldItem booking_custom_field_item: BookingCustomField to update (required)
        :return: list[BookingCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_booking_custom_field_with_http_info(booking_custom_field_id, booking_custom_field_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_booking_custom_field_with_http_info(booking_custom_field_id, booking_custom_field_item, **kwargs)  # noqa: E501
            return data

    def update_booking_custom_field_with_http_info(self, booking_custom_field_id, booking_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an BookingCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_booking_custom_field_with_http_info(booking_custom_field_id, booking_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_custom_field_id: Numeric value of the bookingcustomfieldID (required)
        :param BookingCustomFieldItem booking_custom_field_item: BookingCustomField to update (required)
        :return: list[BookingCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['booking_custom_field_id', 'booking_custom_field_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_booking_custom_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'booking_custom_field_id' is set
        if ('booking_custom_field_id' not in params or
                params['booking_custom_field_id'] is None):
            raise ValueError("Missing the required parameter `booking_custom_field_id` when calling `update_booking_custom_field`")  # noqa: E501
        # verify the required parameter 'booking_custom_field_item' is set
        if ('booking_custom_field_item' not in params or
                params['booking_custom_field_item'] is None):
            raise ValueError("Missing the required parameter `booking_custom_field_item` when calling `update_booking_custom_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'booking_custom_field_id' in params:
            path_params['BookingCustomFieldID'] = params['booking_custom_field_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'booking_custom_field_item' in params:
            body_params = params['booking_custom_field_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/BookingCustomField/{BookingCustomFieldID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BookingCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_booking_linked(self, booking_linked_id, booking_linked_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an BookingLinked in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_booking_linked(booking_linked_id, booking_linked_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_linked_id: Numeric value of the bookinglinkedID (required)
        :param BookingLinkedItem booking_linked_item: BookingLinked to update (required)
        :return: list[BookingLinkedItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_booking_linked_with_http_info(booking_linked_id, booking_linked_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_booking_linked_with_http_info(booking_linked_id, booking_linked_item, **kwargs)  # noqa: E501
            return data

    def update_booking_linked_with_http_info(self, booking_linked_id, booking_linked_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an BookingLinked in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_booking_linked_with_http_info(booking_linked_id, booking_linked_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_linked_id: Numeric value of the bookinglinkedID (required)
        :param BookingLinkedItem booking_linked_item: BookingLinked to update (required)
        :return: list[BookingLinkedItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['booking_linked_id', 'booking_linked_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_booking_linked" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'booking_linked_id' is set
        if ('booking_linked_id' not in params or
                params['booking_linked_id'] is None):
            raise ValueError("Missing the required parameter `booking_linked_id` when calling `update_booking_linked`")  # noqa: E501
        # verify the required parameter 'booking_linked_item' is set
        if ('booking_linked_item' not in params or
                params['booking_linked_item'] is None):
            raise ValueError("Missing the required parameter `booking_linked_item` when calling `update_booking_linked`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'booking_linked_id' in params:
            path_params['BookingLinkedID'] = params['booking_linked_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'booking_linked_item' in params:
            body_params = params['booking_linked_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/BookingLinked/{BookingLinkedID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BookingLinkedItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_booking_occupant(self, booking_occupant_id, booking_occupant_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an BookingOccupant in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_booking_occupant(booking_occupant_id, booking_occupant_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_occupant_id: Numeric value of the bookingoccupantID (required)
        :param BookingOccupantItem booking_occupant_item: BookingOccupant to update (required)
        :return: list[BookingOccupantItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_booking_occupant_with_http_info(booking_occupant_id, booking_occupant_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_booking_occupant_with_http_info(booking_occupant_id, booking_occupant_item, **kwargs)  # noqa: E501
            return data

    def update_booking_occupant_with_http_info(self, booking_occupant_id, booking_occupant_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an BookingOccupant in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_booking_occupant_with_http_info(booking_occupant_id, booking_occupant_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_occupant_id: Numeric value of the bookingoccupantID (required)
        :param BookingOccupantItem booking_occupant_item: BookingOccupant to update (required)
        :return: list[BookingOccupantItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['booking_occupant_id', 'booking_occupant_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_booking_occupant" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'booking_occupant_id' is set
        if ('booking_occupant_id' not in params or
                params['booking_occupant_id'] is None):
            raise ValueError("Missing the required parameter `booking_occupant_id` when calling `update_booking_occupant`")  # noqa: E501
        # verify the required parameter 'booking_occupant_item' is set
        if ('booking_occupant_item' not in params or
                params['booking_occupant_item'] is None):
            raise ValueError("Missing the required parameter `booking_occupant_item` when calling `update_booking_occupant`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'booking_occupant_id' in params:
            path_params['BookingOccupantID'] = params['booking_occupant_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'booking_occupant_item' in params:
            body_params = params['booking_occupant_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/BookingOccupant/{BookingOccupantID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BookingOccupantItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_booking_reason(self, booking_reason_id, booking_reason_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an BookingReason in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_booking_reason(booking_reason_id, booking_reason_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_reason_id: Numeric value of the bookingreasonID (required)
        :param BookingReasonItem booking_reason_item: BookingReason to update (required)
        :return: list[BookingReasonItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_booking_reason_with_http_info(booking_reason_id, booking_reason_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_booking_reason_with_http_info(booking_reason_id, booking_reason_item, **kwargs)  # noqa: E501
            return data

    def update_booking_reason_with_http_info(self, booking_reason_id, booking_reason_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an BookingReason in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_booking_reason_with_http_info(booking_reason_id, booking_reason_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_reason_id: Numeric value of the bookingreasonID (required)
        :param BookingReasonItem booking_reason_item: BookingReason to update (required)
        :return: list[BookingReasonItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['booking_reason_id', 'booking_reason_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_booking_reason" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'booking_reason_id' is set
        if ('booking_reason_id' not in params or
                params['booking_reason_id'] is None):
            raise ValueError("Missing the required parameter `booking_reason_id` when calling `update_booking_reason`")  # noqa: E501
        # verify the required parameter 'booking_reason_item' is set
        if ('booking_reason_item' not in params or
                params['booking_reason_item'] is None):
            raise ValueError("Missing the required parameter `booking_reason_item` when calling `update_booking_reason`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'booking_reason_id' in params:
            path_params['BookingReasonID'] = params['booking_reason_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'booking_reason_item' in params:
            body_params = params['booking_reason_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/BookingReason/{BookingReasonID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BookingReasonItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_booking_tag(self, booking_tag_id, booking_tag_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an BookingTag in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_booking_tag(booking_tag_id, booking_tag_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_tag_id: Numeric value of the bookingtagID (required)
        :param BookingTagItem booking_tag_item: BookingTag to update (required)
        :return: list[BookingTagItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_booking_tag_with_http_info(booking_tag_id, booking_tag_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_booking_tag_with_http_info(booking_tag_id, booking_tag_item, **kwargs)  # noqa: E501
            return data

    def update_booking_tag_with_http_info(self, booking_tag_id, booking_tag_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an BookingTag in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_booking_tag_with_http_info(booking_tag_id, booking_tag_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_tag_id: Numeric value of the bookingtagID (required)
        :param BookingTagItem booking_tag_item: BookingTag to update (required)
        :return: list[BookingTagItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['booking_tag_id', 'booking_tag_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_booking_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'booking_tag_id' is set
        if ('booking_tag_id' not in params or
                params['booking_tag_id'] is None):
            raise ValueError("Missing the required parameter `booking_tag_id` when calling `update_booking_tag`")  # noqa: E501
        # verify the required parameter 'booking_tag_item' is set
        if ('booking_tag_item' not in params or
                params['booking_tag_item'] is None):
            raise ValueError("Missing the required parameter `booking_tag_item` when calling `update_booking_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'booking_tag_id' in params:
            path_params['BookingTagID'] = params['booking_tag_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'booking_tag_item' in params:
            body_params = params['booking_tag_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/BookingTag/{BookingTagID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BookingTagItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_booking_type(self, booking_type_id, booking_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an BookingType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_booking_type(booking_type_id, booking_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_type_id: Numeric value of the bookingtypeID (required)
        :param BookingTypeItem booking_type_item: BookingType to update (required)
        :return: list[BookingTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_booking_type_with_http_info(booking_type_id, booking_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_booking_type_with_http_info(booking_type_id, booking_type_item, **kwargs)  # noqa: E501
            return data

    def update_booking_type_with_http_info(self, booking_type_id, booking_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an BookingType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_booking_type_with_http_info(booking_type_id, booking_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int booking_type_id: Numeric value of the bookingtypeID (required)
        :param BookingTypeItem booking_type_item: BookingType to update (required)
        :return: list[BookingTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['booking_type_id', 'booking_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_booking_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'booking_type_id' is set
        if ('booking_type_id' not in params or
                params['booking_type_id'] is None):
            raise ValueError("Missing the required parameter `booking_type_id` when calling `update_booking_type`")  # noqa: E501
        # verify the required parameter 'booking_type_item' is set
        if ('booking_type_item' not in params or
                params['booking_type_item'] is None):
            raise ValueError("Missing the required parameter `booking_type_item` when calling `update_booking_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'booking_type_id' in params:
            path_params['BookingTypeID'] = params['booking_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'booking_type_item' in params:
            body_params = params['booking_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/BookingType/{BookingTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BookingTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_calendar(self, calendar_id, calendar_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Calendar in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_calendar(calendar_id, calendar_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int calendar_id: Numeric value of the calendarID (required)
        :param CalendarItem calendar_item: Calendar to update (required)
        :return: list[CalendarItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_calendar_with_http_info(calendar_id, calendar_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_calendar_with_http_info(calendar_id, calendar_item, **kwargs)  # noqa: E501
            return data

    def update_calendar_with_http_info(self, calendar_id, calendar_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Calendar in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_calendar_with_http_info(calendar_id, calendar_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int calendar_id: Numeric value of the calendarID (required)
        :param CalendarItem calendar_item: Calendar to update (required)
        :return: list[CalendarItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['calendar_id', 'calendar_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_calendar" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'calendar_id' is set
        if ('calendar_id' not in params or
                params['calendar_id'] is None):
            raise ValueError("Missing the required parameter `calendar_id` when calling `update_calendar`")  # noqa: E501
        # verify the required parameter 'calendar_item' is set
        if ('calendar_item' not in params or
                params['calendar_item'] is None):
            raise ValueError("Missing the required parameter `calendar_item` when calling `update_calendar`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'calendar_id' in params:
            path_params['CalendarID'] = params['calendar_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'calendar_item' in params:
            body_params = params['calendar_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Calendar/{CalendarID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CalendarItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_category(self, category_id, category_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Category in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_category(category_id, category_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_id: Numeric value of the categoryID (required)
        :param CategoryItem category_item: Category to update (required)
        :return: list[CategoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_category_with_http_info(category_id, category_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_category_with_http_info(category_id, category_item, **kwargs)  # noqa: E501
            return data

    def update_category_with_http_info(self, category_id, category_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Category in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_category_with_http_info(category_id, category_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_id: Numeric value of the categoryID (required)
        :param CategoryItem category_item: Category to update (required)
        :return: list[CategoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category_id', 'category_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_category" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'category_id' is set
        if ('category_id' not in params or
                params['category_id'] is None):
            raise ValueError("Missing the required parameter `category_id` when calling `update_category`")  # noqa: E501
        # verify the required parameter 'category_item' is set
        if ('category_item' not in params or
                params['category_item'] is None):
            raise ValueError("Missing the required parameter `category_item` when calling `update_category`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'category_id' in params:
            path_params['CategoryID'] = params['category_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'category_item' in params:
            body_params = params['category_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Category/{CategoryID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CategoryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_category_custom_field(self, category_custom_field_id, category_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CategoryCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_category_custom_field(category_custom_field_id, category_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_custom_field_id: Numeric value of the categorycustomfieldID (required)
        :param CategoryCustomFieldItem category_custom_field_item: CategoryCustomField to update (required)
        :return: list[CategoryCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_category_custom_field_with_http_info(category_custom_field_id, category_custom_field_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_category_custom_field_with_http_info(category_custom_field_id, category_custom_field_item, **kwargs)  # noqa: E501
            return data

    def update_category_custom_field_with_http_info(self, category_custom_field_id, category_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CategoryCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_category_custom_field_with_http_info(category_custom_field_id, category_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_custom_field_id: Numeric value of the categorycustomfieldID (required)
        :param CategoryCustomFieldItem category_custom_field_item: CategoryCustomField to update (required)
        :return: list[CategoryCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category_custom_field_id', 'category_custom_field_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_category_custom_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'category_custom_field_id' is set
        if ('category_custom_field_id' not in params or
                params['category_custom_field_id'] is None):
            raise ValueError("Missing the required parameter `category_custom_field_id` when calling `update_category_custom_field`")  # noqa: E501
        # verify the required parameter 'category_custom_field_item' is set
        if ('category_custom_field_item' not in params or
                params['category_custom_field_item'] is None):
            raise ValueError("Missing the required parameter `category_custom_field_item` when calling `update_category_custom_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'category_custom_field_id' in params:
            path_params['CategoryCustomFieldID'] = params['category_custom_field_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'category_custom_field_item' in params:
            body_params = params['category_custom_field_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/CategoryCustomField/{CategoryCustomFieldID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CategoryCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_category_level(self, category_level_id, category_level_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CategoryLevel in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_category_level(category_level_id, category_level_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_level_id: Numeric value of the categorylevelID (required)
        :param CategoryLevelItem category_level_item: CategoryLevel to update (required)
        :return: list[CategoryLevelItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_category_level_with_http_info(category_level_id, category_level_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_category_level_with_http_info(category_level_id, category_level_item, **kwargs)  # noqa: E501
            return data

    def update_category_level_with_http_info(self, category_level_id, category_level_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CategoryLevel in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_category_level_with_http_info(category_level_id, category_level_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_level_id: Numeric value of the categorylevelID (required)
        :param CategoryLevelItem category_level_item: CategoryLevel to update (required)
        :return: list[CategoryLevelItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category_level_id', 'category_level_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_category_level" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'category_level_id' is set
        if ('category_level_id' not in params or
                params['category_level_id'] is None):
            raise ValueError("Missing the required parameter `category_level_id` when calling `update_category_level`")  # noqa: E501
        # verify the required parameter 'category_level_item' is set
        if ('category_level_item' not in params or
                params['category_level_item'] is None):
            raise ValueError("Missing the required parameter `category_level_item` when calling `update_category_level`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'category_level_id' in params:
            path_params['CategoryLevelID'] = params['category_level_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'category_level_item' in params:
            body_params = params['category_level_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/CategoryLevel/{CategoryLevelID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CategoryLevelItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_category_permission(self, category_permission_id, category_permission_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CategoryPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_category_permission(category_permission_id, category_permission_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_permission_id: Numeric value of the categorypermissionID (required)
        :param CategoryPermissionItem category_permission_item: CategoryPermission to update (required)
        :return: list[CategoryPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_category_permission_with_http_info(category_permission_id, category_permission_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_category_permission_with_http_info(category_permission_id, category_permission_item, **kwargs)  # noqa: E501
            return data

    def update_category_permission_with_http_info(self, category_permission_id, category_permission_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CategoryPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_category_permission_with_http_info(category_permission_id, category_permission_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_permission_id: Numeric value of the categorypermissionID (required)
        :param CategoryPermissionItem category_permission_item: CategoryPermission to update (required)
        :return: list[CategoryPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category_permission_id', 'category_permission_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_category_permission" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'category_permission_id' is set
        if ('category_permission_id' not in params or
                params['category_permission_id'] is None):
            raise ValueError("Missing the required parameter `category_permission_id` when calling `update_category_permission`")  # noqa: E501
        # verify the required parameter 'category_permission_item' is set
        if ('category_permission_item' not in params or
                params['category_permission_item'] is None):
            raise ValueError("Missing the required parameter `category_permission_item` when calling `update_category_permission`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'category_permission_id' in params:
            path_params['CategoryPermissionID'] = params['category_permission_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'category_permission_item' in params:
            body_params = params['category_permission_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/CategoryPermission/{CategoryPermissionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CategoryPermissionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_category_schedule_transaction(self, category_schedule_transaction_id, category_schedule_transaction_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CategoryScheduleTransaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_category_schedule_transaction(category_schedule_transaction_id, category_schedule_transaction_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_schedule_transaction_id: Numeric value of the categoryscheduletransactionID (required)
        :param CategoryScheduleTransactionItem category_schedule_transaction_item: CategoryScheduleTransaction to update (required)
        :return: list[CategoryScheduleTransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_category_schedule_transaction_with_http_info(category_schedule_transaction_id, category_schedule_transaction_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_category_schedule_transaction_with_http_info(category_schedule_transaction_id, category_schedule_transaction_item, **kwargs)  # noqa: E501
            return data

    def update_category_schedule_transaction_with_http_info(self, category_schedule_transaction_id, category_schedule_transaction_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CategoryScheduleTransaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_category_schedule_transaction_with_http_info(category_schedule_transaction_id, category_schedule_transaction_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int category_schedule_transaction_id: Numeric value of the categoryscheduletransactionID (required)
        :param CategoryScheduleTransactionItem category_schedule_transaction_item: CategoryScheduleTransaction to update (required)
        :return: list[CategoryScheduleTransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['category_schedule_transaction_id', 'category_schedule_transaction_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_category_schedule_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'category_schedule_transaction_id' is set
        if ('category_schedule_transaction_id' not in params or
                params['category_schedule_transaction_id'] is None):
            raise ValueError("Missing the required parameter `category_schedule_transaction_id` when calling `update_category_schedule_transaction`")  # noqa: E501
        # verify the required parameter 'category_schedule_transaction_item' is set
        if ('category_schedule_transaction_item' not in params or
                params['category_schedule_transaction_item'] is None):
            raise ValueError("Missing the required parameter `category_schedule_transaction_item` when calling `update_category_schedule_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'category_schedule_transaction_id' in params:
            path_params['CategoryScheduleTransactionID'] = params['category_schedule_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'category_schedule_transaction_item' in params:
            body_params = params['category_schedule_transaction_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/CategoryScheduleTransaction/{CategoryScheduleTransactionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CategoryScheduleTransactionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_catering(self, catering_id, catering_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Catering in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_catering(catering_id, catering_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int catering_id: Numeric value of the cateringID (required)
        :param CateringItem catering_item: Catering to update (required)
        :return: list[CateringItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_catering_with_http_info(catering_id, catering_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_catering_with_http_info(catering_id, catering_item, **kwargs)  # noqa: E501
            return data

    def update_catering_with_http_info(self, catering_id, catering_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Catering in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_catering_with_http_info(catering_id, catering_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int catering_id: Numeric value of the cateringID (required)
        :param CateringItem catering_item: Catering to update (required)
        :return: list[CateringItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catering_id', 'catering_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_catering" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catering_id' is set
        if ('catering_id' not in params or
                params['catering_id'] is None):
            raise ValueError("Missing the required parameter `catering_id` when calling `update_catering`")  # noqa: E501
        # verify the required parameter 'catering_item' is set
        if ('catering_item' not in params or
                params['catering_item'] is None):
            raise ValueError("Missing the required parameter `catering_item` when calling `update_catering`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catering_id' in params:
            path_params['CateringID'] = params['catering_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'catering_item' in params:
            body_params = params['catering_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Catering/{CateringID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CateringItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_catering_item(self, catering_item_id, catering_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CateringItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_catering_item(catering_item_id, catering_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int catering_item_id: Numeric value of the cateringitemID (required)
        :param CateringItemItem catering_item_item: CateringItem to update (required)
        :return: list[CateringItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_catering_item_with_http_info(catering_item_id, catering_item_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_catering_item_with_http_info(catering_item_id, catering_item_item, **kwargs)  # noqa: E501
            return data

    def update_catering_item_with_http_info(self, catering_item_id, catering_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CateringItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_catering_item_with_http_info(catering_item_id, catering_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int catering_item_id: Numeric value of the cateringitemID (required)
        :param CateringItemItem catering_item_item: CateringItem to update (required)
        :return: list[CateringItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catering_item_id', 'catering_item_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_catering_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catering_item_id' is set
        if ('catering_item_id' not in params or
                params['catering_item_id'] is None):
            raise ValueError("Missing the required parameter `catering_item_id` when calling `update_catering_item`")  # noqa: E501
        # verify the required parameter 'catering_item_item' is set
        if ('catering_item_item' not in params or
                params['catering_item_item'] is None):
            raise ValueError("Missing the required parameter `catering_item_item` when calling `update_catering_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catering_item_id' in params:
            path_params['CateringItemID'] = params['catering_item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'catering_item_item' in params:
            body_params = params['catering_item_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/CateringItem/{CateringItemID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CateringItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_catering_type(self, catering_type_id, catering_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CateringType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_catering_type(catering_type_id, catering_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int catering_type_id: Numeric value of the cateringtypeID (required)
        :param CateringTypeItem catering_type_item: CateringType to update (required)
        :return: list[CateringTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_catering_type_with_http_info(catering_type_id, catering_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_catering_type_with_http_info(catering_type_id, catering_type_item, **kwargs)  # noqa: E501
            return data

    def update_catering_type_with_http_info(self, catering_type_id, catering_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CateringType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_catering_type_with_http_info(catering_type_id, catering_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int catering_type_id: Numeric value of the cateringtypeID (required)
        :param CateringTypeItem catering_type_item: CateringType to update (required)
        :return: list[CateringTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['catering_type_id', 'catering_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_catering_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'catering_type_id' is set
        if ('catering_type_id' not in params or
                params['catering_type_id'] is None):
            raise ValueError("Missing the required parameter `catering_type_id` when calling `update_catering_type`")  # noqa: E501
        # verify the required parameter 'catering_type_item' is set
        if ('catering_type_item' not in params or
                params['catering_type_item'] is None):
            raise ValueError("Missing the required parameter `catering_type_item` when calling `update_catering_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'catering_type_id' in params:
            path_params['CateringTypeID'] = params['catering_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'catering_type_item' in params:
            body_params = params['catering_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/CateringType/{CateringTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CateringTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_charge_group(self, charge_group_id, charge_group_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ChargeGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_charge_group(charge_group_id, charge_group_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int charge_group_id: Numeric value of the chargegroupID (required)
        :param ChargeGroupItem charge_group_item: ChargeGroup to update (required)
        :return: list[ChargeGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_charge_group_with_http_info(charge_group_id, charge_group_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_charge_group_with_http_info(charge_group_id, charge_group_item, **kwargs)  # noqa: E501
            return data

    def update_charge_group_with_http_info(self, charge_group_id, charge_group_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ChargeGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_charge_group_with_http_info(charge_group_id, charge_group_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int charge_group_id: Numeric value of the chargegroupID (required)
        :param ChargeGroupItem charge_group_item: ChargeGroup to update (required)
        :return: list[ChargeGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['charge_group_id', 'charge_group_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_charge_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'charge_group_id' is set
        if ('charge_group_id' not in params or
                params['charge_group_id'] is None):
            raise ValueError("Missing the required parameter `charge_group_id` when calling `update_charge_group`")  # noqa: E501
        # verify the required parameter 'charge_group_item' is set
        if ('charge_group_item' not in params or
                params['charge_group_item'] is None):
            raise ValueError("Missing the required parameter `charge_group_item` when calling `update_charge_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'charge_group_id' in params:
            path_params['ChargeGroupID'] = params['charge_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'charge_group_item' in params:
            body_params = params['charge_group_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ChargeGroup/{ChargeGroupID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ChargeGroupItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_charge_item(self, charge_item_id, charge_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ChargeItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_charge_item(charge_item_id, charge_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int charge_item_id: Numeric value of the chargeitemID (required)
        :param ChargeItemItem charge_item_item: ChargeItem to update (required)
        :return: list[ChargeItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_charge_item_with_http_info(charge_item_id, charge_item_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_charge_item_with_http_info(charge_item_id, charge_item_item, **kwargs)  # noqa: E501
            return data

    def update_charge_item_with_http_info(self, charge_item_id, charge_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ChargeItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_charge_item_with_http_info(charge_item_id, charge_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int charge_item_id: Numeric value of the chargeitemID (required)
        :param ChargeItemItem charge_item_item: ChargeItem to update (required)
        :return: list[ChargeItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['charge_item_id', 'charge_item_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_charge_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'charge_item_id' is set
        if ('charge_item_id' not in params or
                params['charge_item_id'] is None):
            raise ValueError("Missing the required parameter `charge_item_id` when calling `update_charge_item`")  # noqa: E501
        # verify the required parameter 'charge_item_item' is set
        if ('charge_item_item' not in params or
                params['charge_item_item'] is None):
            raise ValueError("Missing the required parameter `charge_item_item` when calling `update_charge_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'charge_item_id' in params:
            path_params['ChargeItemID'] = params['charge_item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'charge_item_item' in params:
            body_params = params['charge_item_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ChargeItem/{ChargeItemID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ChargeItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_classification(self, classification_id, classification_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Classification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_classification(classification_id, classification_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int classification_id: Numeric value of the classificationID (required)
        :param ClassificationItem classification_item: Classification to update (required)
        :return: list[ClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_classification_with_http_info(classification_id, classification_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_classification_with_http_info(classification_id, classification_item, **kwargs)  # noqa: E501
            return data

    def update_classification_with_http_info(self, classification_id, classification_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Classification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_classification_with_http_info(classification_id, classification_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int classification_id: Numeric value of the classificationID (required)
        :param ClassificationItem classification_item: Classification to update (required)
        :return: list[ClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['classification_id', 'classification_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_classification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'classification_id' is set
        if ('classification_id' not in params or
                params['classification_id'] is None):
            raise ValueError("Missing the required parameter `classification_id` when calling `update_classification`")  # noqa: E501
        # verify the required parameter 'classification_item' is set
        if ('classification_item' not in params or
                params['classification_item'] is None):
            raise ValueError("Missing the required parameter `classification_item` when calling `update_classification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'classification_id' in params:
            path_params['ClassificationID'] = params['classification_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'classification_item' in params:
            body_params = params['classification_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Classification/{ClassificationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ClassificationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_concern(self, concern_id, concern_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Concern in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_concern(concern_id, concern_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_id: Numeric value of the concernID (required)
        :param ConcernItem concern_item: Concern to update (required)
        :return: list[ConcernItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_concern_with_http_info(concern_id, concern_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_concern_with_http_info(concern_id, concern_item, **kwargs)  # noqa: E501
            return data

    def update_concern_with_http_info(self, concern_id, concern_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Concern in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_concern_with_http_info(concern_id, concern_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_id: Numeric value of the concernID (required)
        :param ConcernItem concern_item: Concern to update (required)
        :return: list[ConcernItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concern_id', 'concern_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_concern" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'concern_id' is set
        if ('concern_id' not in params or
                params['concern_id'] is None):
            raise ValueError("Missing the required parameter `concern_id` when calling `update_concern`")  # noqa: E501
        # verify the required parameter 'concern_item' is set
        if ('concern_item' not in params or
                params['concern_item'] is None):
            raise ValueError("Missing the required parameter `concern_item` when calling `update_concern`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'concern_id' in params:
            path_params['ConcernID'] = params['concern_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'concern_item' in params:
            body_params = params['concern_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Concern/{ConcernID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ConcernItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_concern_custom_field(self, concern_custom_field_id, concern_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ConcernCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_concern_custom_field(concern_custom_field_id, concern_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_custom_field_id: Numeric value of the concerncustomfieldID (required)
        :param ConcernCustomFieldItem concern_custom_field_item: ConcernCustomField to update (required)
        :return: list[ConcernCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_concern_custom_field_with_http_info(concern_custom_field_id, concern_custom_field_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_concern_custom_field_with_http_info(concern_custom_field_id, concern_custom_field_item, **kwargs)  # noqa: E501
            return data

    def update_concern_custom_field_with_http_info(self, concern_custom_field_id, concern_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ConcernCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_concern_custom_field_with_http_info(concern_custom_field_id, concern_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_custom_field_id: Numeric value of the concerncustomfieldID (required)
        :param ConcernCustomFieldItem concern_custom_field_item: ConcernCustomField to update (required)
        :return: list[ConcernCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concern_custom_field_id', 'concern_custom_field_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_concern_custom_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'concern_custom_field_id' is set
        if ('concern_custom_field_id' not in params or
                params['concern_custom_field_id'] is None):
            raise ValueError("Missing the required parameter `concern_custom_field_id` when calling `update_concern_custom_field`")  # noqa: E501
        # verify the required parameter 'concern_custom_field_item' is set
        if ('concern_custom_field_item' not in params or
                params['concern_custom_field_item'] is None):
            raise ValueError("Missing the required parameter `concern_custom_field_item` when calling `update_concern_custom_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'concern_custom_field_id' in params:
            path_params['ConcernCustomFieldID'] = params['concern_custom_field_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'concern_custom_field_item' in params:
            body_params = params['concern_custom_field_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ConcernCustomField/{ConcernCustomFieldID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ConcernCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_concern_entry(self, concern_entry_id, concern_entry_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ConcernEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_concern_entry(concern_entry_id, concern_entry_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_entry_id: Numeric value of the concernentryID (required)
        :param ConcernEntryItem concern_entry_item: ConcernEntry to update (required)
        :return: list[ConcernEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_concern_entry_with_http_info(concern_entry_id, concern_entry_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_concern_entry_with_http_info(concern_entry_id, concern_entry_item, **kwargs)  # noqa: E501
            return data

    def update_concern_entry_with_http_info(self, concern_entry_id, concern_entry_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ConcernEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_concern_entry_with_http_info(concern_entry_id, concern_entry_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_entry_id: Numeric value of the concernentryID (required)
        :param ConcernEntryItem concern_entry_item: ConcernEntry to update (required)
        :return: list[ConcernEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concern_entry_id', 'concern_entry_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_concern_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'concern_entry_id' is set
        if ('concern_entry_id' not in params or
                params['concern_entry_id'] is None):
            raise ValueError("Missing the required parameter `concern_entry_id` when calling `update_concern_entry`")  # noqa: E501
        # verify the required parameter 'concern_entry_item' is set
        if ('concern_entry_item' not in params or
                params['concern_entry_item'] is None):
            raise ValueError("Missing the required parameter `concern_entry_item` when calling `update_concern_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'concern_entry_id' in params:
            path_params['ConcernEntryID'] = params['concern_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'concern_entry_item' in params:
            body_params = params['concern_entry_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ConcernEntry/{ConcernEntryID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ConcernEntryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_concern_note(self, concern_note_id, concern_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ConcernNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_concern_note(concern_note_id, concern_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_note_id: Numeric value of the concernnoteID (required)
        :param ConcernNoteItem concern_note_item: ConcernNote to update (required)
        :return: list[ConcernNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_concern_note_with_http_info(concern_note_id, concern_note_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_concern_note_with_http_info(concern_note_id, concern_note_item, **kwargs)  # noqa: E501
            return data

    def update_concern_note_with_http_info(self, concern_note_id, concern_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ConcernNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_concern_note_with_http_info(concern_note_id, concern_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_note_id: Numeric value of the concernnoteID (required)
        :param ConcernNoteItem concern_note_item: ConcernNote to update (required)
        :return: list[ConcernNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concern_note_id', 'concern_note_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_concern_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'concern_note_id' is set
        if ('concern_note_id' not in params or
                params['concern_note_id'] is None):
            raise ValueError("Missing the required parameter `concern_note_id` when calling `update_concern_note`")  # noqa: E501
        # verify the required parameter 'concern_note_item' is set
        if ('concern_note_item' not in params or
                params['concern_note_item'] is None):
            raise ValueError("Missing the required parameter `concern_note_item` when calling `update_concern_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'concern_note_id' in params:
            path_params['ConcernNoteID'] = params['concern_note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'concern_note_item' in params:
            body_params = params['concern_note_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ConcernNote/{ConcernNoteID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ConcernNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_concern_sub_type(self, concern_sub_type_id, concern_sub_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ConcernSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_concern_sub_type(concern_sub_type_id, concern_sub_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_sub_type_id: Numeric value of the concernsubtypeID (required)
        :param ConcernSubTypeItem concern_sub_type_item: ConcernSubType to update (required)
        :return: list[ConcernSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_concern_sub_type_with_http_info(concern_sub_type_id, concern_sub_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_concern_sub_type_with_http_info(concern_sub_type_id, concern_sub_type_item, **kwargs)  # noqa: E501
            return data

    def update_concern_sub_type_with_http_info(self, concern_sub_type_id, concern_sub_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ConcernSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_concern_sub_type_with_http_info(concern_sub_type_id, concern_sub_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_sub_type_id: Numeric value of the concernsubtypeID (required)
        :param ConcernSubTypeItem concern_sub_type_item: ConcernSubType to update (required)
        :return: list[ConcernSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concern_sub_type_id', 'concern_sub_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_concern_sub_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'concern_sub_type_id' is set
        if ('concern_sub_type_id' not in params or
                params['concern_sub_type_id'] is None):
            raise ValueError("Missing the required parameter `concern_sub_type_id` when calling `update_concern_sub_type`")  # noqa: E501
        # verify the required parameter 'concern_sub_type_item' is set
        if ('concern_sub_type_item' not in params or
                params['concern_sub_type_item'] is None):
            raise ValueError("Missing the required parameter `concern_sub_type_item` when calling `update_concern_sub_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'concern_sub_type_id' in params:
            path_params['ConcernSubTypeID'] = params['concern_sub_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'concern_sub_type_item' in params:
            body_params = params['concern_sub_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ConcernSubType/{ConcernSubTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ConcernSubTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_concern_type(self, concern_type_id, concern_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ConcernType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_concern_type(concern_type_id, concern_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_type_id: Numeric value of the concerntypeID (required)
        :param ConcernTypeItem concern_type_item: ConcernType to update (required)
        :return: list[ConcernTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_concern_type_with_http_info(concern_type_id, concern_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_concern_type_with_http_info(concern_type_id, concern_type_item, **kwargs)  # noqa: E501
            return data

    def update_concern_type_with_http_info(self, concern_type_id, concern_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ConcernType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_concern_type_with_http_info(concern_type_id, concern_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int concern_type_id: Numeric value of the concerntypeID (required)
        :param ConcernTypeItem concern_type_item: ConcernType to update (required)
        :return: list[ConcernTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['concern_type_id', 'concern_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_concern_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'concern_type_id' is set
        if ('concern_type_id' not in params or
                params['concern_type_id'] is None):
            raise ValueError("Missing the required parameter `concern_type_id` when calling `update_concern_type`")  # noqa: E501
        # verify the required parameter 'concern_type_item' is set
        if ('concern_type_item' not in params or
                params['concern_type_item'] is None):
            raise ValueError("Missing the required parameter `concern_type_item` when calling `update_concern_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'concern_type_id' in params:
            path_params['ConcernTypeID'] = params['concern_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'concern_type_item' in params:
            body_params = params['concern_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ConcernType/{ConcernTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ConcernTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_contact(self, contact_id, contact_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Contact in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contact(contact_id, contact_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contact_id: Numeric value of the contactID (required)
        :param ContactItem contact_item: Contact to update (required)
        :return: list[ContactItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_contact_with_http_info(contact_id, contact_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_contact_with_http_info(contact_id, contact_item, **kwargs)  # noqa: E501
            return data

    def update_contact_with_http_info(self, contact_id, contact_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Contact in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contact_with_http_info(contact_id, contact_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contact_id: Numeric value of the contactID (required)
        :param ContactItem contact_item: Contact to update (required)
        :return: list[ContactItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'contact_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `update_contact`")  # noqa: E501
        # verify the required parameter 'contact_item' is set
        if ('contact_item' not in params or
                params['contact_item'] is None):
            raise ValueError("Missing the required parameter `contact_item` when calling `update_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['ContactID'] = params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'contact_item' in params:
            body_params = params['contact_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Contact/{ContactID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContactItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_contact_custom_field(self, contact_custom_field_id, contact_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ContactCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contact_custom_field(contact_custom_field_id, contact_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contact_custom_field_id: Numeric value of the contactcustomfieldID (required)
        :param ContactCustomFieldItem contact_custom_field_item: ContactCustomField to update (required)
        :return: list[ContactCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_contact_custom_field_with_http_info(contact_custom_field_id, contact_custom_field_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_contact_custom_field_with_http_info(contact_custom_field_id, contact_custom_field_item, **kwargs)  # noqa: E501
            return data

    def update_contact_custom_field_with_http_info(self, contact_custom_field_id, contact_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ContactCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contact_custom_field_with_http_info(contact_custom_field_id, contact_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contact_custom_field_id: Numeric value of the contactcustomfieldID (required)
        :param ContactCustomFieldItem contact_custom_field_item: ContactCustomField to update (required)
        :return: list[ContactCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_custom_field_id', 'contact_custom_field_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contact_custom_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_custom_field_id' is set
        if ('contact_custom_field_id' not in params or
                params['contact_custom_field_id'] is None):
            raise ValueError("Missing the required parameter `contact_custom_field_id` when calling `update_contact_custom_field`")  # noqa: E501
        # verify the required parameter 'contact_custom_field_item' is set
        if ('contact_custom_field_item' not in params or
                params['contact_custom_field_item'] is None):
            raise ValueError("Missing the required parameter `contact_custom_field_item` when calling `update_contact_custom_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_custom_field_id' in params:
            path_params['ContactCustomFieldID'] = params['contact_custom_field_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'contact_custom_field_item' in params:
            body_params = params['contact_custom_field_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ContactCustomField/{ContactCustomFieldID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContactCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_contact_note(self, contact_note_id, contact_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ContactNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contact_note(contact_note_id, contact_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contact_note_id: Numeric value of the contactnoteID (required)
        :param ContactNoteItem contact_note_item: ContactNote to update (required)
        :return: list[ContactNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_contact_note_with_http_info(contact_note_id, contact_note_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_contact_note_with_http_info(contact_note_id, contact_note_item, **kwargs)  # noqa: E501
            return data

    def update_contact_note_with_http_info(self, contact_note_id, contact_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ContactNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contact_note_with_http_info(contact_note_id, contact_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contact_note_id: Numeric value of the contactnoteID (required)
        :param ContactNoteItem contact_note_item: ContactNote to update (required)
        :return: list[ContactNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_note_id', 'contact_note_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contact_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_note_id' is set
        if ('contact_note_id' not in params or
                params['contact_note_id'] is None):
            raise ValueError("Missing the required parameter `contact_note_id` when calling `update_contact_note`")  # noqa: E501
        # verify the required parameter 'contact_note_item' is set
        if ('contact_note_item' not in params or
                params['contact_note_item'] is None):
            raise ValueError("Missing the required parameter `contact_note_item` when calling `update_contact_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_note_id' in params:
            path_params['ContactNoteID'] = params['contact_note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'contact_note_item' in params:
            body_params = params['contact_note_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ContactNote/{ContactNoteID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContactNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_contact_status(self, contact_status_id, contact_status_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ContactStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contact_status(contact_status_id, contact_status_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contact_status_id: Numeric value of the contactstatusID (required)
        :param ContactStatusItem contact_status_item: ContactStatus to update (required)
        :return: list[ContactStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_contact_status_with_http_info(contact_status_id, contact_status_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_contact_status_with_http_info(contact_status_id, contact_status_item, **kwargs)  # noqa: E501
            return data

    def update_contact_status_with_http_info(self, contact_status_id, contact_status_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ContactStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contact_status_with_http_info(contact_status_id, contact_status_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contact_status_id: Numeric value of the contactstatusID (required)
        :param ContactStatusItem contact_status_item: ContactStatus to update (required)
        :return: list[ContactStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_status_id', 'contact_status_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contact_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_status_id' is set
        if ('contact_status_id' not in params or
                params['contact_status_id'] is None):
            raise ValueError("Missing the required parameter `contact_status_id` when calling `update_contact_status`")  # noqa: E501
        # verify the required parameter 'contact_status_item' is set
        if ('contact_status_item' not in params or
                params['contact_status_item'] is None):
            raise ValueError("Missing the required parameter `contact_status_item` when calling `update_contact_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_status_id' in params:
            path_params['ContactStatusID'] = params['contact_status_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'contact_status_item' in params:
            body_params = params['contact_status_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ContactStatus/{ContactStatusID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContactStatusItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_contribution(self, contribution_id, contribution_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Contribution in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contribution(contribution_id, contribution_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_id: Numeric value of the contributionID (required)
        :param ContributionItem contribution_item: Contribution to update (required)
        :return: list[ContributionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_contribution_with_http_info(contribution_id, contribution_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_contribution_with_http_info(contribution_id, contribution_item, **kwargs)  # noqa: E501
            return data

    def update_contribution_with_http_info(self, contribution_id, contribution_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Contribution in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contribution_with_http_info(contribution_id, contribution_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_id: Numeric value of the contributionID (required)
        :param ContributionItem contribution_item: Contribution to update (required)
        :return: list[ContributionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contribution_id', 'contribution_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contribution" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contribution_id' is set
        if ('contribution_id' not in params or
                params['contribution_id'] is None):
            raise ValueError("Missing the required parameter `contribution_id` when calling `update_contribution`")  # noqa: E501
        # verify the required parameter 'contribution_item' is set
        if ('contribution_item' not in params or
                params['contribution_item'] is None):
            raise ValueError("Missing the required parameter `contribution_item` when calling `update_contribution`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contribution_id' in params:
            path_params['ContributionID'] = params['contribution_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'contribution_item' in params:
            body_params = params['contribution_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Contribution/{ContributionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContributionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_contribution_custom_field(self, contribution_custom_field_id, contribution_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ContributionCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contribution_custom_field(contribution_custom_field_id, contribution_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_custom_field_id: Numeric value of the contributioncustomfieldID (required)
        :param ContributionCustomFieldItem contribution_custom_field_item: ContributionCustomField to update (required)
        :return: list[ContributionCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_contribution_custom_field_with_http_info(contribution_custom_field_id, contribution_custom_field_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_contribution_custom_field_with_http_info(contribution_custom_field_id, contribution_custom_field_item, **kwargs)  # noqa: E501
            return data

    def update_contribution_custom_field_with_http_info(self, contribution_custom_field_id, contribution_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ContributionCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contribution_custom_field_with_http_info(contribution_custom_field_id, contribution_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_custom_field_id: Numeric value of the contributioncustomfieldID (required)
        :param ContributionCustomFieldItem contribution_custom_field_item: ContributionCustomField to update (required)
        :return: list[ContributionCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contribution_custom_field_id', 'contribution_custom_field_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contribution_custom_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contribution_custom_field_id' is set
        if ('contribution_custom_field_id' not in params or
                params['contribution_custom_field_id'] is None):
            raise ValueError("Missing the required parameter `contribution_custom_field_id` when calling `update_contribution_custom_field`")  # noqa: E501
        # verify the required parameter 'contribution_custom_field_item' is set
        if ('contribution_custom_field_item' not in params or
                params['contribution_custom_field_item'] is None):
            raise ValueError("Missing the required parameter `contribution_custom_field_item` when calling `update_contribution_custom_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contribution_custom_field_id' in params:
            path_params['ContributionCustomFieldID'] = params['contribution_custom_field_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'contribution_custom_field_item' in params:
            body_params = params['contribution_custom_field_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ContributionCustomField/{ContributionCustomFieldID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContributionCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_contribution_entry(self, contribution_entry_id, contribution_entry_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ContributionEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contribution_entry(contribution_entry_id, contribution_entry_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_entry_id: Numeric value of the contributionentryID (required)
        :param ContributionEntryItem contribution_entry_item: ContributionEntry to update (required)
        :return: list[ContributionEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_contribution_entry_with_http_info(contribution_entry_id, contribution_entry_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_contribution_entry_with_http_info(contribution_entry_id, contribution_entry_item, **kwargs)  # noqa: E501
            return data

    def update_contribution_entry_with_http_info(self, contribution_entry_id, contribution_entry_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ContributionEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contribution_entry_with_http_info(contribution_entry_id, contribution_entry_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_entry_id: Numeric value of the contributionentryID (required)
        :param ContributionEntryItem contribution_entry_item: ContributionEntry to update (required)
        :return: list[ContributionEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contribution_entry_id', 'contribution_entry_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contribution_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contribution_entry_id' is set
        if ('contribution_entry_id' not in params or
                params['contribution_entry_id'] is None):
            raise ValueError("Missing the required parameter `contribution_entry_id` when calling `update_contribution_entry`")  # noqa: E501
        # verify the required parameter 'contribution_entry_item' is set
        if ('contribution_entry_item' not in params or
                params['contribution_entry_item'] is None):
            raise ValueError("Missing the required parameter `contribution_entry_item` when calling `update_contribution_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contribution_entry_id' in params:
            path_params['ContributionEntryID'] = params['contribution_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'contribution_entry_item' in params:
            body_params = params['contribution_entry_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ContributionEntry/{ContributionEntryID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContributionEntryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_contribution_note(self, contribution_note_id, contribution_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ContributionNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contribution_note(contribution_note_id, contribution_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_note_id: Numeric value of the contributionnoteID (required)
        :param ContributionNoteItem contribution_note_item: ContributionNote to update (required)
        :return: list[ContributionNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_contribution_note_with_http_info(contribution_note_id, contribution_note_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_contribution_note_with_http_info(contribution_note_id, contribution_note_item, **kwargs)  # noqa: E501
            return data

    def update_contribution_note_with_http_info(self, contribution_note_id, contribution_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ContributionNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contribution_note_with_http_info(contribution_note_id, contribution_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_note_id: Numeric value of the contributionnoteID (required)
        :param ContributionNoteItem contribution_note_item: ContributionNote to update (required)
        :return: list[ContributionNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contribution_note_id', 'contribution_note_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contribution_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contribution_note_id' is set
        if ('contribution_note_id' not in params or
                params['contribution_note_id'] is None):
            raise ValueError("Missing the required parameter `contribution_note_id` when calling `update_contribution_note`")  # noqa: E501
        # verify the required parameter 'contribution_note_item' is set
        if ('contribution_note_item' not in params or
                params['contribution_note_item'] is None):
            raise ValueError("Missing the required parameter `contribution_note_item` when calling `update_contribution_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contribution_note_id' in params:
            path_params['ContributionNoteID'] = params['contribution_note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'contribution_note_item' in params:
            body_params = params['contribution_note_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ContributionNote/{ContributionNoteID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContributionNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_contribution_sub_type(self, contribution_sub_type_id, contribution_sub_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ContributionSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contribution_sub_type(contribution_sub_type_id, contribution_sub_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_sub_type_id: Numeric value of the contributionsubtypeID (required)
        :param ContributionSubTypeItem contribution_sub_type_item: ContributionSubType to update (required)
        :return: list[ContributionSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_contribution_sub_type_with_http_info(contribution_sub_type_id, contribution_sub_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_contribution_sub_type_with_http_info(contribution_sub_type_id, contribution_sub_type_item, **kwargs)  # noqa: E501
            return data

    def update_contribution_sub_type_with_http_info(self, contribution_sub_type_id, contribution_sub_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ContributionSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contribution_sub_type_with_http_info(contribution_sub_type_id, contribution_sub_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_sub_type_id: Numeric value of the contributionsubtypeID (required)
        :param ContributionSubTypeItem contribution_sub_type_item: ContributionSubType to update (required)
        :return: list[ContributionSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contribution_sub_type_id', 'contribution_sub_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contribution_sub_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contribution_sub_type_id' is set
        if ('contribution_sub_type_id' not in params or
                params['contribution_sub_type_id'] is None):
            raise ValueError("Missing the required parameter `contribution_sub_type_id` when calling `update_contribution_sub_type`")  # noqa: E501
        # verify the required parameter 'contribution_sub_type_item' is set
        if ('contribution_sub_type_item' not in params or
                params['contribution_sub_type_item'] is None):
            raise ValueError("Missing the required parameter `contribution_sub_type_item` when calling `update_contribution_sub_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contribution_sub_type_id' in params:
            path_params['ContributionSubTypeID'] = params['contribution_sub_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'contribution_sub_type_item' in params:
            body_params = params['contribution_sub_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ContributionSubType/{ContributionSubTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContributionSubTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_contribution_type(self, contribution_type_id, contribution_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ContributionType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contribution_type(contribution_type_id, contribution_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_type_id: Numeric value of the contributiontypeID (required)
        :param ContributionTypeItem contribution_type_item: ContributionType to update (required)
        :return: list[ContributionTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_contribution_type_with_http_info(contribution_type_id, contribution_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_contribution_type_with_http_info(contribution_type_id, contribution_type_item, **kwargs)  # noqa: E501
            return data

    def update_contribution_type_with_http_info(self, contribution_type_id, contribution_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ContributionType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_contribution_type_with_http_info(contribution_type_id, contribution_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int contribution_type_id: Numeric value of the contributiontypeID (required)
        :param ContributionTypeItem contribution_type_item: ContributionType to update (required)
        :return: list[ContributionTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contribution_type_id', 'contribution_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contribution_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contribution_type_id' is set
        if ('contribution_type_id' not in params or
                params['contribution_type_id'] is None):
            raise ValueError("Missing the required parameter `contribution_type_id` when calling `update_contribution_type`")  # noqa: E501
        # verify the required parameter 'contribution_type_item' is set
        if ('contribution_type_item' not in params or
                params['contribution_type_item'] is None):
            raise ValueError("Missing the required parameter `contribution_type_item` when calling `update_contribution_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contribution_type_id' in params:
            path_params['ContributionTypeID'] = params['contribution_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'contribution_type_item' in params:
            body_params = params['contribution_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ContributionType/{ContributionTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ContributionTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_correspondence_source(self, correspondence_source_id, correspondence_source_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CorrespondenceSource in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_correspondence_source(correspondence_source_id, correspondence_source_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int correspondence_source_id: Numeric value of the correspondencesourceID (required)
        :param CorrespondenceSourceItem correspondence_source_item: CorrespondenceSource to update (required)
        :return: list[CorrespondenceSourceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_correspondence_source_with_http_info(correspondence_source_id, correspondence_source_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_correspondence_source_with_http_info(correspondence_source_id, correspondence_source_item, **kwargs)  # noqa: E501
            return data

    def update_correspondence_source_with_http_info(self, correspondence_source_id, correspondence_source_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CorrespondenceSource in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_correspondence_source_with_http_info(correspondence_source_id, correspondence_source_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int correspondence_source_id: Numeric value of the correspondencesourceID (required)
        :param CorrespondenceSourceItem correspondence_source_item: CorrespondenceSource to update (required)
        :return: list[CorrespondenceSourceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['correspondence_source_id', 'correspondence_source_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_correspondence_source" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'correspondence_source_id' is set
        if ('correspondence_source_id' not in params or
                params['correspondence_source_id'] is None):
            raise ValueError("Missing the required parameter `correspondence_source_id` when calling `update_correspondence_source`")  # noqa: E501
        # verify the required parameter 'correspondence_source_item' is set
        if ('correspondence_source_item' not in params or
                params['correspondence_source_item'] is None):
            raise ValueError("Missing the required parameter `correspondence_source_item` when calling `update_correspondence_source`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'correspondence_source_id' in params:
            path_params['CorrespondenceSourceID'] = params['correspondence_source_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'correspondence_source_item' in params:
            body_params = params['correspondence_source_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/CorrespondenceSource/{CorrespondenceSourceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CorrespondenceSourceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_country(self, country_id, country_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Country in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_country(country_id, country_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int country_id: Numeric value of the countryID (required)
        :param CountryItem country_item: Country to update (required)
        :return: list[CountryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_country_with_http_info(country_id, country_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_country_with_http_info(country_id, country_item, **kwargs)  # noqa: E501
            return data

    def update_country_with_http_info(self, country_id, country_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Country in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_country_with_http_info(country_id, country_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int country_id: Numeric value of the countryID (required)
        :param CountryItem country_item: Country to update (required)
        :return: list[CountryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['country_id', 'country_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_country" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'country_id' is set
        if ('country_id' not in params or
                params['country_id'] is None):
            raise ValueError("Missing the required parameter `country_id` when calling `update_country`")  # noqa: E501
        # verify the required parameter 'country_item' is set
        if ('country_item' not in params or
                params['country_item'] is None):
            raise ValueError("Missing the required parameter `country_item` when calling `update_country`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'country_id' in params:
            path_params['CountryID'] = params['country_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'country_item' in params:
            body_params = params['country_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Country/{CountryID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CountryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_course(self, course_id, course_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Course in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_course(course_id, course_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int course_id: Numeric value of the courseID (required)
        :param CourseItem course_item: Course to update (required)
        :return: list[CourseItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_course_with_http_info(course_id, course_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_course_with_http_info(course_id, course_item, **kwargs)  # noqa: E501
            return data

    def update_course_with_http_info(self, course_id, course_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Course in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_course_with_http_info(course_id, course_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int course_id: Numeric value of the courseID (required)
        :param CourseItem course_item: Course to update (required)
        :return: list[CourseItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['course_id', 'course_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_course" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'course_id' is set
        if ('course_id' not in params or
                params['course_id'] is None):
            raise ValueError("Missing the required parameter `course_id` when calling `update_course`")  # noqa: E501
        # verify the required parameter 'course_item' is set
        if ('course_item' not in params or
                params['course_item'] is None):
            raise ValueError("Missing the required parameter `course_item` when calling `update_course`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'course_id' in params:
            path_params['CourseID'] = params['course_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'course_item' in params:
            body_params = params['course_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Course/{CourseID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CourseItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_currency_conversion(self, currency_conversion_id, currency_conversion_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CurrencyConversion in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_currency_conversion(currency_conversion_id, currency_conversion_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int currency_conversion_id: Numeric value of the currencyconversionID (required)
        :param CurrencyConversionItem currency_conversion_item: CurrencyConversion to update (required)
        :return: list[CurrencyConversionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_currency_conversion_with_http_info(currency_conversion_id, currency_conversion_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_currency_conversion_with_http_info(currency_conversion_id, currency_conversion_item, **kwargs)  # noqa: E501
            return data

    def update_currency_conversion_with_http_info(self, currency_conversion_id, currency_conversion_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CurrencyConversion in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_currency_conversion_with_http_info(currency_conversion_id, currency_conversion_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int currency_conversion_id: Numeric value of the currencyconversionID (required)
        :param CurrencyConversionItem currency_conversion_item: CurrencyConversion to update (required)
        :return: list[CurrencyConversionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['currency_conversion_id', 'currency_conversion_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_currency_conversion" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'currency_conversion_id' is set
        if ('currency_conversion_id' not in params or
                params['currency_conversion_id'] is None):
            raise ValueError("Missing the required parameter `currency_conversion_id` when calling `update_currency_conversion`")  # noqa: E501
        # verify the required parameter 'currency_conversion_item' is set
        if ('currency_conversion_item' not in params or
                params['currency_conversion_item'] is None):
            raise ValueError("Missing the required parameter `currency_conversion_item` when calling `update_currency_conversion`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'currency_conversion_id' in params:
            path_params['CurrencyConversionID'] = params['currency_conversion_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'currency_conversion_item' in params:
            body_params = params['currency_conversion_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/CurrencyConversion/{CurrencyConversionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CurrencyConversionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_custom_field_definition(self, custom_field_definition_id, custom_field_definition_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CustomFieldDefinition in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_custom_field_definition(custom_field_definition_id, custom_field_definition_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int custom_field_definition_id: Numeric value of the customfielddefinitionID (required)
        :param CustomFieldDefinitionItem custom_field_definition_item: CustomFieldDefinition to update (required)
        :return: list[CustomFieldDefinitionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_custom_field_definition_with_http_info(custom_field_definition_id, custom_field_definition_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_custom_field_definition_with_http_info(custom_field_definition_id, custom_field_definition_item, **kwargs)  # noqa: E501
            return data

    def update_custom_field_definition_with_http_info(self, custom_field_definition_id, custom_field_definition_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CustomFieldDefinition in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_custom_field_definition_with_http_info(custom_field_definition_id, custom_field_definition_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int custom_field_definition_id: Numeric value of the customfielddefinitionID (required)
        :param CustomFieldDefinitionItem custom_field_definition_item: CustomFieldDefinition to update (required)
        :return: list[CustomFieldDefinitionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['custom_field_definition_id', 'custom_field_definition_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_custom_field_definition" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'custom_field_definition_id' is set
        if ('custom_field_definition_id' not in params or
                params['custom_field_definition_id'] is None):
            raise ValueError("Missing the required parameter `custom_field_definition_id` when calling `update_custom_field_definition`")  # noqa: E501
        # verify the required parameter 'custom_field_definition_item' is set
        if ('custom_field_definition_item' not in params or
                params['custom_field_definition_item'] is None):
            raise ValueError("Missing the required parameter `custom_field_definition_item` when calling `update_custom_field_definition`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'custom_field_definition_id' in params:
            path_params['CustomFieldDefinitionID'] = params['custom_field_definition_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'custom_field_definition_item' in params:
            body_params = params['custom_field_definition_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/CustomFieldDefinition/{CustomFieldDefinitionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CustomFieldDefinitionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_custom_method_tag(self, custom_method_tag_id, custom_method_tag_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CustomMethodTag in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_custom_method_tag(custom_method_tag_id, custom_method_tag_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int custom_method_tag_id: Numeric value of the custommethodtagID (required)
        :param CustomMethodTagItem custom_method_tag_item: CustomMethodTag to update (required)
        :return: list[CustomMethodTagItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_custom_method_tag_with_http_info(custom_method_tag_id, custom_method_tag_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_custom_method_tag_with_http_info(custom_method_tag_id, custom_method_tag_item, **kwargs)  # noqa: E501
            return data

    def update_custom_method_tag_with_http_info(self, custom_method_tag_id, custom_method_tag_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an CustomMethodTag in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_custom_method_tag_with_http_info(custom_method_tag_id, custom_method_tag_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int custom_method_tag_id: Numeric value of the custommethodtagID (required)
        :param CustomMethodTagItem custom_method_tag_item: CustomMethodTag to update (required)
        :return: list[CustomMethodTagItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['custom_method_tag_id', 'custom_method_tag_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_custom_method_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'custom_method_tag_id' is set
        if ('custom_method_tag_id' not in params or
                params['custom_method_tag_id'] is None):
            raise ValueError("Missing the required parameter `custom_method_tag_id` when calling `update_custom_method_tag`")  # noqa: E501
        # verify the required parameter 'custom_method_tag_item' is set
        if ('custom_method_tag_item' not in params or
                params['custom_method_tag_item'] is None):
            raise ValueError("Missing the required parameter `custom_method_tag_item` when calling `update_custom_method_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'custom_method_tag_id' in params:
            path_params['CustomMethodTagID'] = params['custom_method_tag_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'custom_method_tag_item' in params:
            body_params = params['custom_method_tag_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/CustomMethodTag/{CustomMethodTagID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CustomMethodTagItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dashboard(self, dashboard_id, dashboard_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Dashboard in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dashboard(dashboard_id, dashboard_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dashboard_id: Numeric value of the dashboardID (required)
        :param DashboardItem dashboard_item: Dashboard to update (required)
        :return: list[DashboardItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dashboard_with_http_info(dashboard_id, dashboard_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dashboard_with_http_info(dashboard_id, dashboard_item, **kwargs)  # noqa: E501
            return data

    def update_dashboard_with_http_info(self, dashboard_id, dashboard_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Dashboard in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dashboard_with_http_info(dashboard_id, dashboard_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dashboard_id: Numeric value of the dashboardID (required)
        :param DashboardItem dashboard_item: Dashboard to update (required)
        :return: list[DashboardItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dashboard_id', 'dashboard_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dashboard" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dashboard_id' is set
        if ('dashboard_id' not in params or
                params['dashboard_id'] is None):
            raise ValueError("Missing the required parameter `dashboard_id` when calling `update_dashboard`")  # noqa: E501
        # verify the required parameter 'dashboard_item' is set
        if ('dashboard_item' not in params or
                params['dashboard_item'] is None):
            raise ValueError("Missing the required parameter `dashboard_item` when calling `update_dashboard`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_id' in params:
            path_params['DashboardID'] = params['dashboard_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_item' in params:
            body_params = params['dashboard_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Dashboard/{DashboardID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DashboardItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dashboard_panel(self, dashboard_panel_id, dashboard_panel_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an DashboardPanel in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dashboard_panel(dashboard_panel_id, dashboard_panel_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dashboard_panel_id: Numeric value of the dashboardpanelID (required)
        :param DashboardPanelItem dashboard_panel_item: DashboardPanel to update (required)
        :return: list[DashboardPanelItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dashboard_panel_with_http_info(dashboard_panel_id, dashboard_panel_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dashboard_panel_with_http_info(dashboard_panel_id, dashboard_panel_item, **kwargs)  # noqa: E501
            return data

    def update_dashboard_panel_with_http_info(self, dashboard_panel_id, dashboard_panel_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an DashboardPanel in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dashboard_panel_with_http_info(dashboard_panel_id, dashboard_panel_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dashboard_panel_id: Numeric value of the dashboardpanelID (required)
        :param DashboardPanelItem dashboard_panel_item: DashboardPanel to update (required)
        :return: list[DashboardPanelItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dashboard_panel_id', 'dashboard_panel_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dashboard_panel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dashboard_panel_id' is set
        if ('dashboard_panel_id' not in params or
                params['dashboard_panel_id'] is None):
            raise ValueError("Missing the required parameter `dashboard_panel_id` when calling `update_dashboard_panel`")  # noqa: E501
        # verify the required parameter 'dashboard_panel_item' is set
        if ('dashboard_panel_item' not in params or
                params['dashboard_panel_item'] is None):
            raise ValueError("Missing the required parameter `dashboard_panel_item` when calling `update_dashboard_panel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_panel_id' in params:
            path_params['DashboardPanelID'] = params['dashboard_panel_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_panel_item' in params:
            body_params = params['dashboard_panel_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/DashboardPanel/{DashboardPanelID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DashboardPanelItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dashboard_panel_setting(self, dashboard_panel_setting_id, dashboard_panel_setting_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an DashboardPanelSetting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dashboard_panel_setting(dashboard_panel_setting_id, dashboard_panel_setting_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dashboard_panel_setting_id: Numeric value of the dashboardpanelsettingID (required)
        :param DashboardPanelSettingItem dashboard_panel_setting_item: DashboardPanelSetting to update (required)
        :return: list[DashboardPanelSettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dashboard_panel_setting_with_http_info(dashboard_panel_setting_id, dashboard_panel_setting_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dashboard_panel_setting_with_http_info(dashboard_panel_setting_id, dashboard_panel_setting_item, **kwargs)  # noqa: E501
            return data

    def update_dashboard_panel_setting_with_http_info(self, dashboard_panel_setting_id, dashboard_panel_setting_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an DashboardPanelSetting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dashboard_panel_setting_with_http_info(dashboard_panel_setting_id, dashboard_panel_setting_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dashboard_panel_setting_id: Numeric value of the dashboardpanelsettingID (required)
        :param DashboardPanelSettingItem dashboard_panel_setting_item: DashboardPanelSetting to update (required)
        :return: list[DashboardPanelSettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dashboard_panel_setting_id', 'dashboard_panel_setting_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dashboard_panel_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dashboard_panel_setting_id' is set
        if ('dashboard_panel_setting_id' not in params or
                params['dashboard_panel_setting_id'] is None):
            raise ValueError("Missing the required parameter `dashboard_panel_setting_id` when calling `update_dashboard_panel_setting`")  # noqa: E501
        # verify the required parameter 'dashboard_panel_setting_item' is set
        if ('dashboard_panel_setting_item' not in params or
                params['dashboard_panel_setting_item'] is None):
            raise ValueError("Missing the required parameter `dashboard_panel_setting_item` when calling `update_dashboard_panel_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_panel_setting_id' in params:
            path_params['DashboardPanelSettingID'] = params['dashboard_panel_setting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_panel_setting_item' in params:
            body_params = params['dashboard_panel_setting_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/DashboardPanelSetting/{DashboardPanelSettingID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DashboardPanelSettingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dashboard_sharing(self, dashboard_sharing_id, dashboard_sharing_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an DashboardSharing in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dashboard_sharing(dashboard_sharing_id, dashboard_sharing_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dashboard_sharing_id: Numeric value of the dashboardsharingID (required)
        :param DashboardSharingItem dashboard_sharing_item: DashboardSharing to update (required)
        :return: list[DashboardSharingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dashboard_sharing_with_http_info(dashboard_sharing_id, dashboard_sharing_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dashboard_sharing_with_http_info(dashboard_sharing_id, dashboard_sharing_item, **kwargs)  # noqa: E501
            return data

    def update_dashboard_sharing_with_http_info(self, dashboard_sharing_id, dashboard_sharing_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an DashboardSharing in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dashboard_sharing_with_http_info(dashboard_sharing_id, dashboard_sharing_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dashboard_sharing_id: Numeric value of the dashboardsharingID (required)
        :param DashboardSharingItem dashboard_sharing_item: DashboardSharing to update (required)
        :return: list[DashboardSharingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dashboard_sharing_id', 'dashboard_sharing_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dashboard_sharing" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dashboard_sharing_id' is set
        if ('dashboard_sharing_id' not in params or
                params['dashboard_sharing_id'] is None):
            raise ValueError("Missing the required parameter `dashboard_sharing_id` when calling `update_dashboard_sharing`")  # noqa: E501
        # verify the required parameter 'dashboard_sharing_item' is set
        if ('dashboard_sharing_item' not in params or
                params['dashboard_sharing_item'] is None):
            raise ValueError("Missing the required parameter `dashboard_sharing_item` when calling `update_dashboard_sharing`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dashboard_sharing_id' in params:
            path_params['DashboardSharingID'] = params['dashboard_sharing_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dashboard_sharing_item' in params:
            body_params = params['dashboard_sharing_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/DashboardSharing/{DashboardSharingID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DashboardSharingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_deleted_transaction(self, deleted_transaction_id, deleted_transaction_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an DeletedTransaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_deleted_transaction(deleted_transaction_id, deleted_transaction_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int deleted_transaction_id: Numeric value of the deletedtransactionID (required)
        :param DeletedTransactionItem deleted_transaction_item: DeletedTransaction to update (required)
        :return: list[DeletedTransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_deleted_transaction_with_http_info(deleted_transaction_id, deleted_transaction_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_deleted_transaction_with_http_info(deleted_transaction_id, deleted_transaction_item, **kwargs)  # noqa: E501
            return data

    def update_deleted_transaction_with_http_info(self, deleted_transaction_id, deleted_transaction_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an DeletedTransaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_deleted_transaction_with_http_info(deleted_transaction_id, deleted_transaction_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int deleted_transaction_id: Numeric value of the deletedtransactionID (required)
        :param DeletedTransactionItem deleted_transaction_item: DeletedTransaction to update (required)
        :return: list[DeletedTransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['deleted_transaction_id', 'deleted_transaction_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_deleted_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'deleted_transaction_id' is set
        if ('deleted_transaction_id' not in params or
                params['deleted_transaction_id'] is None):
            raise ValueError("Missing the required parameter `deleted_transaction_id` when calling `update_deleted_transaction`")  # noqa: E501
        # verify the required parameter 'deleted_transaction_item' is set
        if ('deleted_transaction_item' not in params or
                params['deleted_transaction_item'] is None):
            raise ValueError("Missing the required parameter `deleted_transaction_item` when calling `update_deleted_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deleted_transaction_id' in params:
            path_params['DeletedTransactionID'] = params['deleted_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'deleted_transaction_item' in params:
            body_params = params['deleted_transaction_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/DeletedTransaction/{DeletedTransactionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DeletedTransactionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_document(self, document_id, document_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Document in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_document(document_id, document_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int document_id: Numeric value of the documentID (required)
        :param DocumentItem document_item: Document to update (required)
        :return: list[DocumentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_document_with_http_info(document_id, document_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_document_with_http_info(document_id, document_item, **kwargs)  # noqa: E501
            return data

    def update_document_with_http_info(self, document_id, document_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Document in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_document_with_http_info(document_id, document_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int document_id: Numeric value of the documentID (required)
        :param DocumentItem document_item: Document to update (required)
        :return: list[DocumentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['document_id', 'document_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `update_document`")  # noqa: E501
        # verify the required parameter 'document_item' is set
        if ('document_item' not in params or
                params['document_item'] is None):
            raise ValueError("Missing the required parameter `document_item` when calling `update_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'document_id' in params:
            path_params['DocumentID'] = params['document_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'document_item' in params:
            body_params = params['document_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Document/{DocumentID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DocumentItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dynamic_list(self, dynamic_list_id, dynamic_list_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an DynamicList in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dynamic_list(dynamic_list_id, dynamic_list_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dynamic_list_id: Numeric value of the dynamiclistID (required)
        :param DynamicListItem dynamic_list_item: DynamicList to update (required)
        :return: list[DynamicListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dynamic_list_with_http_info(dynamic_list_id, dynamic_list_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dynamic_list_with_http_info(dynamic_list_id, dynamic_list_item, **kwargs)  # noqa: E501
            return data

    def update_dynamic_list_with_http_info(self, dynamic_list_id, dynamic_list_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an DynamicList in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dynamic_list_with_http_info(dynamic_list_id, dynamic_list_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dynamic_list_id: Numeric value of the dynamiclistID (required)
        :param DynamicListItem dynamic_list_item: DynamicList to update (required)
        :return: list[DynamicListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dynamic_list_id', 'dynamic_list_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dynamic_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dynamic_list_id' is set
        if ('dynamic_list_id' not in params or
                params['dynamic_list_id'] is None):
            raise ValueError("Missing the required parameter `dynamic_list_id` when calling `update_dynamic_list`")  # noqa: E501
        # verify the required parameter 'dynamic_list_item' is set
        if ('dynamic_list_item' not in params or
                params['dynamic_list_item'] is None):
            raise ValueError("Missing the required parameter `dynamic_list_item` when calling `update_dynamic_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dynamic_list_id' in params:
            path_params['DynamicListID'] = params['dynamic_list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dynamic_list_item' in params:
            body_params = params['dynamic_list_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/DynamicList/{DynamicListID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DynamicListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dynamic_list_permission(self, dynamic_list_permission_id, dynamic_list_permission_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an DynamicListPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dynamic_list_permission(dynamic_list_permission_id, dynamic_list_permission_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dynamic_list_permission_id: Numeric value of the dynamiclistpermissionID (required)
        :param DynamicListPermissionItem dynamic_list_permission_item: DynamicListPermission to update (required)
        :return: list[DynamicListPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_dynamic_list_permission_with_http_info(dynamic_list_permission_id, dynamic_list_permission_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dynamic_list_permission_with_http_info(dynamic_list_permission_id, dynamic_list_permission_item, **kwargs)  # noqa: E501
            return data

    def update_dynamic_list_permission_with_http_info(self, dynamic_list_permission_id, dynamic_list_permission_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an DynamicListPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_dynamic_list_permission_with_http_info(dynamic_list_permission_id, dynamic_list_permission_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int dynamic_list_permission_id: Numeric value of the dynamiclistpermissionID (required)
        :param DynamicListPermissionItem dynamic_list_permission_item: DynamicListPermission to update (required)
        :return: list[DynamicListPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['dynamic_list_permission_id', 'dynamic_list_permission_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dynamic_list_permission" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'dynamic_list_permission_id' is set
        if ('dynamic_list_permission_id' not in params or
                params['dynamic_list_permission_id'] is None):
            raise ValueError("Missing the required parameter `dynamic_list_permission_id` when calling `update_dynamic_list_permission`")  # noqa: E501
        # verify the required parameter 'dynamic_list_permission_item' is set
        if ('dynamic_list_permission_item' not in params or
                params['dynamic_list_permission_item'] is None):
            raise ValueError("Missing the required parameter `dynamic_list_permission_item` when calling `update_dynamic_list_permission`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'dynamic_list_permission_id' in params:
            path_params['DynamicListPermissionID'] = params['dynamic_list_permission_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'dynamic_list_permission_item' in params:
            body_params = params['dynamic_list_permission_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/DynamicListPermission/{DynamicListPermissionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DynamicListPermissionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_electronic_identity_type(self, electronic_identity_type_id, electronic_identity_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ElectronicIdentityType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_electronic_identity_type(electronic_identity_type_id, electronic_identity_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int electronic_identity_type_id: Numeric value of the electronicidentitytypeID (required)
        :param ElectronicIdentityTypeItem electronic_identity_type_item: ElectronicIdentityType to update (required)
        :return: list[ElectronicIdentityTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_electronic_identity_type_with_http_info(electronic_identity_type_id, electronic_identity_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_electronic_identity_type_with_http_info(electronic_identity_type_id, electronic_identity_type_item, **kwargs)  # noqa: E501
            return data

    def update_electronic_identity_type_with_http_info(self, electronic_identity_type_id, electronic_identity_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ElectronicIdentityType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_electronic_identity_type_with_http_info(electronic_identity_type_id, electronic_identity_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int electronic_identity_type_id: Numeric value of the electronicidentitytypeID (required)
        :param ElectronicIdentityTypeItem electronic_identity_type_item: ElectronicIdentityType to update (required)
        :return: list[ElectronicIdentityTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['electronic_identity_type_id', 'electronic_identity_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_electronic_identity_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'electronic_identity_type_id' is set
        if ('electronic_identity_type_id' not in params or
                params['electronic_identity_type_id'] is None):
            raise ValueError("Missing the required parameter `electronic_identity_type_id` when calling `update_electronic_identity_type`")  # noqa: E501
        # verify the required parameter 'electronic_identity_type_item' is set
        if ('electronic_identity_type_item' not in params or
                params['electronic_identity_type_item'] is None):
            raise ValueError("Missing the required parameter `electronic_identity_type_item` when calling `update_electronic_identity_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'electronic_identity_type_id' in params:
            path_params['ElectronicIdentityTypeID'] = params['electronic_identity_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'electronic_identity_type_item' in params:
            body_params = params['electronic_identity_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ElectronicIdentityType/{ElectronicIdentityTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ElectronicIdentityTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_email_from_address(self, email_from_address_id, email_from_address_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EmailFromAddress in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_email_from_address(email_from_address_id, email_from_address_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int email_from_address_id: Numeric value of the emailfromaddressID (required)
        :param EmailFromAddressItem email_from_address_item: EmailFromAddress to update (required)
        :return: list[EmailFromAddressItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_email_from_address_with_http_info(email_from_address_id, email_from_address_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_email_from_address_with_http_info(email_from_address_id, email_from_address_item, **kwargs)  # noqa: E501
            return data

    def update_email_from_address_with_http_info(self, email_from_address_id, email_from_address_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EmailFromAddress in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_email_from_address_with_http_info(email_from_address_id, email_from_address_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int email_from_address_id: Numeric value of the emailfromaddressID (required)
        :param EmailFromAddressItem email_from_address_item: EmailFromAddress to update (required)
        :return: list[EmailFromAddressItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email_from_address_id', 'email_from_address_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_email_from_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email_from_address_id' is set
        if ('email_from_address_id' not in params or
                params['email_from_address_id'] is None):
            raise ValueError("Missing the required parameter `email_from_address_id` when calling `update_email_from_address`")  # noqa: E501
        # verify the required parameter 'email_from_address_item' is set
        if ('email_from_address_item' not in params or
                params['email_from_address_item'] is None):
            raise ValueError("Missing the required parameter `email_from_address_item` when calling `update_email_from_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email_from_address_id' in params:
            path_params['EmailFromAddressID'] = params['email_from_address_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'email_from_address_item' in params:
            body_params = params['email_from_address_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EmailFromAddress/{EmailFromAddressID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EmailFromAddressItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_email_from_address_permission(self, email_from_address_permission_id, email_from_address_permission_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EmailFromAddressPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_email_from_address_permission(email_from_address_permission_id, email_from_address_permission_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int email_from_address_permission_id: Numeric value of the emailfromaddresspermissionID (required)
        :param EmailFromAddressPermissionItem email_from_address_permission_item: EmailFromAddressPermission to update (required)
        :return: list[EmailFromAddressPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_email_from_address_permission_with_http_info(email_from_address_permission_id, email_from_address_permission_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_email_from_address_permission_with_http_info(email_from_address_permission_id, email_from_address_permission_item, **kwargs)  # noqa: E501
            return data

    def update_email_from_address_permission_with_http_info(self, email_from_address_permission_id, email_from_address_permission_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EmailFromAddressPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_email_from_address_permission_with_http_info(email_from_address_permission_id, email_from_address_permission_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int email_from_address_permission_id: Numeric value of the emailfromaddresspermissionID (required)
        :param EmailFromAddressPermissionItem email_from_address_permission_item: EmailFromAddressPermission to update (required)
        :return: list[EmailFromAddressPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email_from_address_permission_id', 'email_from_address_permission_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_email_from_address_permission" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email_from_address_permission_id' is set
        if ('email_from_address_permission_id' not in params or
                params['email_from_address_permission_id'] is None):
            raise ValueError("Missing the required parameter `email_from_address_permission_id` when calling `update_email_from_address_permission`")  # noqa: E501
        # verify the required parameter 'email_from_address_permission_item' is set
        if ('email_from_address_permission_item' not in params or
                params['email_from_address_permission_item'] is None):
            raise ValueError("Missing the required parameter `email_from_address_permission_item` when calling `update_email_from_address_permission`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email_from_address_permission_id' in params:
            path_params['EmailFromAddressPermissionID'] = params['email_from_address_permission_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'email_from_address_permission_item' in params:
            body_params = params['email_from_address_permission_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EmailFromAddressPermission/{EmailFromAddressPermissionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EmailFromAddressPermissionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_email_outbox(self, email_outbox_id, email_outbox_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EmailOutbox in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_email_outbox(email_outbox_id, email_outbox_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int email_outbox_id: Numeric value of the emailoutboxID (required)
        :param EmailOutboxItem email_outbox_item: EmailOutbox to update (required)
        :return: list[EmailOutboxItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_email_outbox_with_http_info(email_outbox_id, email_outbox_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_email_outbox_with_http_info(email_outbox_id, email_outbox_item, **kwargs)  # noqa: E501
            return data

    def update_email_outbox_with_http_info(self, email_outbox_id, email_outbox_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EmailOutbox in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_email_outbox_with_http_info(email_outbox_id, email_outbox_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int email_outbox_id: Numeric value of the emailoutboxID (required)
        :param EmailOutboxItem email_outbox_item: EmailOutbox to update (required)
        :return: list[EmailOutboxItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email_outbox_id', 'email_outbox_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_email_outbox" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email_outbox_id' is set
        if ('email_outbox_id' not in params or
                params['email_outbox_id'] is None):
            raise ValueError("Missing the required parameter `email_outbox_id` when calling `update_email_outbox`")  # noqa: E501
        # verify the required parameter 'email_outbox_item' is set
        if ('email_outbox_item' not in params or
                params['email_outbox_item'] is None):
            raise ValueError("Missing the required parameter `email_outbox_item` when calling `update_email_outbox`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email_outbox_id' in params:
            path_params['EmailOutboxID'] = params['email_outbox_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'email_outbox_item' in params:
            body_params = params['email_outbox_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EmailOutbox/{EmailOutboxID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EmailOutboxItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_end_of_session(self, end_of_session_id, end_of_session_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EndOfSession in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_end_of_session(end_of_session_id, end_of_session_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int end_of_session_id: Numeric value of the endofsessionID (required)
        :param EndOfSessionItem end_of_session_item: EndOfSession to update (required)
        :return: list[EndOfSessionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_end_of_session_with_http_info(end_of_session_id, end_of_session_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_end_of_session_with_http_info(end_of_session_id, end_of_session_item, **kwargs)  # noqa: E501
            return data

    def update_end_of_session_with_http_info(self, end_of_session_id, end_of_session_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EndOfSession in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_end_of_session_with_http_info(end_of_session_id, end_of_session_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int end_of_session_id: Numeric value of the endofsessionID (required)
        :param EndOfSessionItem end_of_session_item: EndOfSession to update (required)
        :return: list[EndOfSessionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['end_of_session_id', 'end_of_session_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_end_of_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'end_of_session_id' is set
        if ('end_of_session_id' not in params or
                params['end_of_session_id'] is None):
            raise ValueError("Missing the required parameter `end_of_session_id` when calling `update_end_of_session`")  # noqa: E501
        # verify the required parameter 'end_of_session_item' is set
        if ('end_of_session_item' not in params or
                params['end_of_session_item'] is None):
            raise ValueError("Missing the required parameter `end_of_session_item` when calling `update_end_of_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'end_of_session_id' in params:
            path_params['EndOfSessionID'] = params['end_of_session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'end_of_session_item' in params:
            body_params = params['end_of_session_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EndOfSession/{EndOfSessionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EndOfSessionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_end_of_session_charge_group(self, end_of_session_charge_group_id, end_of_session_charge_group_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EndOfSessionChargeGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_end_of_session_charge_group(end_of_session_charge_group_id, end_of_session_charge_group_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int end_of_session_charge_group_id: Numeric value of the endofsessionchargegroupID (required)
        :param EndOfSessionChargeGroupItem end_of_session_charge_group_item: EndOfSessionChargeGroup to update (required)
        :return: list[EndOfSessionChargeGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_end_of_session_charge_group_with_http_info(end_of_session_charge_group_id, end_of_session_charge_group_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_end_of_session_charge_group_with_http_info(end_of_session_charge_group_id, end_of_session_charge_group_item, **kwargs)  # noqa: E501
            return data

    def update_end_of_session_charge_group_with_http_info(self, end_of_session_charge_group_id, end_of_session_charge_group_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EndOfSessionChargeGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_end_of_session_charge_group_with_http_info(end_of_session_charge_group_id, end_of_session_charge_group_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int end_of_session_charge_group_id: Numeric value of the endofsessionchargegroupID (required)
        :param EndOfSessionChargeGroupItem end_of_session_charge_group_item: EndOfSessionChargeGroup to update (required)
        :return: list[EndOfSessionChargeGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['end_of_session_charge_group_id', 'end_of_session_charge_group_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_end_of_session_charge_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'end_of_session_charge_group_id' is set
        if ('end_of_session_charge_group_id' not in params or
                params['end_of_session_charge_group_id'] is None):
            raise ValueError("Missing the required parameter `end_of_session_charge_group_id` when calling `update_end_of_session_charge_group`")  # noqa: E501
        # verify the required parameter 'end_of_session_charge_group_item' is set
        if ('end_of_session_charge_group_item' not in params or
                params['end_of_session_charge_group_item'] is None):
            raise ValueError("Missing the required parameter `end_of_session_charge_group_item` when calling `update_end_of_session_charge_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'end_of_session_charge_group_id' in params:
            path_params['EndOfSessionChargeGroupID'] = params['end_of_session_charge_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'end_of_session_charge_group_item' in params:
            body_params = params['end_of_session_charge_group_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EndOfSessionChargeGroup/{EndOfSessionChargeGroupID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EndOfSessionChargeGroupItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry(self, entry_id, entry_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Entry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry(entry_id, entry_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_id: Numeric value of the entryID (required)
        :param EntryItem entry_item: Entry to update (required)
        :return: list[EntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_with_http_info(entry_id, entry_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_with_http_info(entry_id, entry_item, **kwargs)  # noqa: E501
            return data

    def update_entry_with_http_info(self, entry_id, entry_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Entry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_with_http_info(entry_id, entry_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_id: Numeric value of the entryID (required)
        :param EntryItem entry_item: Entry to update (required)
        :return: list[EntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_id', 'entry_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_id' is set
        if ('entry_id' not in params or
                params['entry_id'] is None):
            raise ValueError("Missing the required parameter `entry_id` when calling `update_entry`")  # noqa: E501
        # verify the required parameter 'entry_item' is set
        if ('entry_item' not in params or
                params['entry_item'] is None):
            raise ValueError("Missing the required parameter `entry_item` when calling `update_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_id' in params:
            path_params['EntryID'] = params['entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_item' in params:
            body_params = params['entry_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Entry/{EntryID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_address(self, entry_address_id, entry_address_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryAddress in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_address(entry_address_id, entry_address_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_address_id: Numeric value of the entryaddressID (required)
        :param EntryAddressItem entry_address_item: EntryAddress to update (required)
        :return: list[EntryAddressItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_address_with_http_info(entry_address_id, entry_address_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_address_with_http_info(entry_address_id, entry_address_item, **kwargs)  # noqa: E501
            return data

    def update_entry_address_with_http_info(self, entry_address_id, entry_address_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryAddress in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_address_with_http_info(entry_address_id, entry_address_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_address_id: Numeric value of the entryaddressID (required)
        :param EntryAddressItem entry_address_item: EntryAddress to update (required)
        :return: list[EntryAddressItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_address_id', 'entry_address_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_address" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_address_id' is set
        if ('entry_address_id' not in params or
                params['entry_address_id'] is None):
            raise ValueError("Missing the required parameter `entry_address_id` when calling `update_entry_address`")  # noqa: E501
        # verify the required parameter 'entry_address_item' is set
        if ('entry_address_item' not in params or
                params['entry_address_item'] is None):
            raise ValueError("Missing the required parameter `entry_address_item` when calling `update_entry_address`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_address_id' in params:
            path_params['EntryAddressID'] = params['entry_address_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_address_item' in params:
            body_params = params['entry_address_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryAddress/{EntryAddressID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryAddressItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_alumni(self, entry_alumni_id, entry_alumni_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryAlumni in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_alumni(entry_alumni_id, entry_alumni_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_alumni_id: Numeric value of the entryalumniID (required)
        :param EntryAlumniItem entry_alumni_item: EntryAlumni to update (required)
        :return: list[EntryAlumniItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_alumni_with_http_info(entry_alumni_id, entry_alumni_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_alumni_with_http_info(entry_alumni_id, entry_alumni_item, **kwargs)  # noqa: E501
            return data

    def update_entry_alumni_with_http_info(self, entry_alumni_id, entry_alumni_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryAlumni in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_alumni_with_http_info(entry_alumni_id, entry_alumni_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_alumni_id: Numeric value of the entryalumniID (required)
        :param EntryAlumniItem entry_alumni_item: EntryAlumni to update (required)
        :return: list[EntryAlumniItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_alumni_id', 'entry_alumni_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_alumni" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_alumni_id' is set
        if ('entry_alumni_id' not in params or
                params['entry_alumni_id'] is None):
            raise ValueError("Missing the required parameter `entry_alumni_id` when calling `update_entry_alumni`")  # noqa: E501
        # verify the required parameter 'entry_alumni_item' is set
        if ('entry_alumni_item' not in params or
                params['entry_alumni_item'] is None):
            raise ValueError("Missing the required parameter `entry_alumni_item` when calling `update_entry_alumni`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_alumni_id' in params:
            path_params['EntryAlumniID'] = params['entry_alumni_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_alumni_item' in params:
            body_params = params['entry_alumni_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryAlumni/{EntryAlumniID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryAlumniItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_alumni_status(self, entry_alumni_status_id, entry_alumni_status_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryAlumniStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_alumni_status(entry_alumni_status_id, entry_alumni_status_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_alumni_status_id: Numeric value of the entryalumnistatusID (required)
        :param EntryAlumniStatusItem entry_alumni_status_item: EntryAlumniStatus to update (required)
        :return: list[EntryAlumniStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_alumni_status_with_http_info(entry_alumni_status_id, entry_alumni_status_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_alumni_status_with_http_info(entry_alumni_status_id, entry_alumni_status_item, **kwargs)  # noqa: E501
            return data

    def update_entry_alumni_status_with_http_info(self, entry_alumni_status_id, entry_alumni_status_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryAlumniStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_alumni_status_with_http_info(entry_alumni_status_id, entry_alumni_status_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_alumni_status_id: Numeric value of the entryalumnistatusID (required)
        :param EntryAlumniStatusItem entry_alumni_status_item: EntryAlumniStatus to update (required)
        :return: list[EntryAlumniStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_alumni_status_id', 'entry_alumni_status_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_alumni_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_alumni_status_id' is set
        if ('entry_alumni_status_id' not in params or
                params['entry_alumni_status_id'] is None):
            raise ValueError("Missing the required parameter `entry_alumni_status_id` when calling `update_entry_alumni_status`")  # noqa: E501
        # verify the required parameter 'entry_alumni_status_item' is set
        if ('entry_alumni_status_item' not in params or
                params['entry_alumni_status_item'] is None):
            raise ValueError("Missing the required parameter `entry_alumni_status_item` when calling `update_entry_alumni_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_alumni_status_id' in params:
            path_params['EntryAlumniStatusID'] = params['entry_alumni_status_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_alumni_status_item' in params:
            body_params = params['entry_alumni_status_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryAlumniStatus/{EntryAlumniStatusID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryAlumniStatusItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_application(self, entry_application_id, entry_application_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryApplication in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_application(entry_application_id, entry_application_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_id: Numeric value of the entryapplicationID (required)
        :param EntryApplicationItem entry_application_item: EntryApplication to update (required)
        :return: list[EntryApplicationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_application_with_http_info(entry_application_id, entry_application_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_application_with_http_info(entry_application_id, entry_application_item, **kwargs)  # noqa: E501
            return data

    def update_entry_application_with_http_info(self, entry_application_id, entry_application_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryApplication in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_application_with_http_info(entry_application_id, entry_application_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_id: Numeric value of the entryapplicationID (required)
        :param EntryApplicationItem entry_application_item: EntryApplication to update (required)
        :return: list[EntryApplicationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_application_id', 'entry_application_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_application_id' is set
        if ('entry_application_id' not in params or
                params['entry_application_id'] is None):
            raise ValueError("Missing the required parameter `entry_application_id` when calling `update_entry_application`")  # noqa: E501
        # verify the required parameter 'entry_application_item' is set
        if ('entry_application_item' not in params or
                params['entry_application_item'] is None):
            raise ValueError("Missing the required parameter `entry_application_item` when calling `update_entry_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_application_id' in params:
            path_params['EntryApplicationID'] = params['entry_application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_application_item' in params:
            body_params = params['entry_application_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryApplication/{EntryApplicationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryApplicationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_application_custom_field(self, entry_application_custom_field_id, entry_application_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryApplicationCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_application_custom_field(entry_application_custom_field_id, entry_application_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_custom_field_id: Numeric value of the entryapplicationcustomfieldID (required)
        :param EntryApplicationCustomFieldItem entry_application_custom_field_item: EntryApplicationCustomField to update (required)
        :return: list[EntryApplicationCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_application_custom_field_with_http_info(entry_application_custom_field_id, entry_application_custom_field_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_application_custom_field_with_http_info(entry_application_custom_field_id, entry_application_custom_field_item, **kwargs)  # noqa: E501
            return data

    def update_entry_application_custom_field_with_http_info(self, entry_application_custom_field_id, entry_application_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryApplicationCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_application_custom_field_with_http_info(entry_application_custom_field_id, entry_application_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_custom_field_id: Numeric value of the entryapplicationcustomfieldID (required)
        :param EntryApplicationCustomFieldItem entry_application_custom_field_item: EntryApplicationCustomField to update (required)
        :return: list[EntryApplicationCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_application_custom_field_id', 'entry_application_custom_field_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_application_custom_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_application_custom_field_id' is set
        if ('entry_application_custom_field_id' not in params or
                params['entry_application_custom_field_id'] is None):
            raise ValueError("Missing the required parameter `entry_application_custom_field_id` when calling `update_entry_application_custom_field`")  # noqa: E501
        # verify the required parameter 'entry_application_custom_field_item' is set
        if ('entry_application_custom_field_item' not in params or
                params['entry_application_custom_field_item'] is None):
            raise ValueError("Missing the required parameter `entry_application_custom_field_item` when calling `update_entry_application_custom_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_application_custom_field_id' in params:
            path_params['EntryApplicationCustomFieldID'] = params['entry_application_custom_field_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_application_custom_field_item' in params:
            body_params = params['entry_application_custom_field_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryApplicationCustomField/{EntryApplicationCustomFieldID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryApplicationCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_application_note(self, entry_application_note_id, entry_application_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryApplicationNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_application_note(entry_application_note_id, entry_application_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_note_id: Numeric value of the entryapplicationnoteID (required)
        :param EntryApplicationNoteItem entry_application_note_item: EntryApplicationNote to update (required)
        :return: list[EntryApplicationNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_application_note_with_http_info(entry_application_note_id, entry_application_note_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_application_note_with_http_info(entry_application_note_id, entry_application_note_item, **kwargs)  # noqa: E501
            return data

    def update_entry_application_note_with_http_info(self, entry_application_note_id, entry_application_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryApplicationNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_application_note_with_http_info(entry_application_note_id, entry_application_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_note_id: Numeric value of the entryapplicationnoteID (required)
        :param EntryApplicationNoteItem entry_application_note_item: EntryApplicationNote to update (required)
        :return: list[EntryApplicationNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_application_note_id', 'entry_application_note_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_application_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_application_note_id' is set
        if ('entry_application_note_id' not in params or
                params['entry_application_note_id'] is None):
            raise ValueError("Missing the required parameter `entry_application_note_id` when calling `update_entry_application_note`")  # noqa: E501
        # verify the required parameter 'entry_application_note_item' is set
        if ('entry_application_note_item' not in params or
                params['entry_application_note_item'] is None):
            raise ValueError("Missing the required parameter `entry_application_note_item` when calling `update_entry_application_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_application_note_id' in params:
            path_params['EntryApplicationNoteID'] = params['entry_application_note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_application_note_item' in params:
            body_params = params['entry_application_note_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryApplicationNote/{EntryApplicationNoteID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryApplicationNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_application_portal_section(self, entry_application_portal_section_id, entry_application_portal_section_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryApplicationPortalSection in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_application_portal_section(entry_application_portal_section_id, entry_application_portal_section_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_portal_section_id: Numeric value of the entryapplicationportalsectionID (required)
        :param EntryApplicationPortalSectionItem entry_application_portal_section_item: EntryApplicationPortalSection to update (required)
        :return: list[EntryApplicationPortalSectionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_application_portal_section_with_http_info(entry_application_portal_section_id, entry_application_portal_section_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_application_portal_section_with_http_info(entry_application_portal_section_id, entry_application_portal_section_item, **kwargs)  # noqa: E501
            return data

    def update_entry_application_portal_section_with_http_info(self, entry_application_portal_section_id, entry_application_portal_section_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryApplicationPortalSection in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_application_portal_section_with_http_info(entry_application_portal_section_id, entry_application_portal_section_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_portal_section_id: Numeric value of the entryapplicationportalsectionID (required)
        :param EntryApplicationPortalSectionItem entry_application_portal_section_item: EntryApplicationPortalSection to update (required)
        :return: list[EntryApplicationPortalSectionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_application_portal_section_id', 'entry_application_portal_section_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_application_portal_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_application_portal_section_id' is set
        if ('entry_application_portal_section_id' not in params or
                params['entry_application_portal_section_id'] is None):
            raise ValueError("Missing the required parameter `entry_application_portal_section_id` when calling `update_entry_application_portal_section`")  # noqa: E501
        # verify the required parameter 'entry_application_portal_section_item' is set
        if ('entry_application_portal_section_item' not in params or
                params['entry_application_portal_section_item'] is None):
            raise ValueError("Missing the required parameter `entry_application_portal_section_item` when calling `update_entry_application_portal_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_application_portal_section_id' in params:
            path_params['EntryApplicationPortalSectionID'] = params['entry_application_portal_section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_application_portal_section_item' in params:
            body_params = params['entry_application_portal_section_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryApplicationPortalSection/{EntryApplicationPortalSectionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryApplicationPortalSectionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_application_preference(self, entry_application_preference_id, entry_application_preference_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryApplicationPreference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_application_preference(entry_application_preference_id, entry_application_preference_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_preference_id: Numeric value of the entryapplicationpreferenceID (required)
        :param EntryApplicationPreferenceItem entry_application_preference_item: EntryApplicationPreference to update (required)
        :return: list[EntryApplicationPreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_application_preference_with_http_info(entry_application_preference_id, entry_application_preference_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_application_preference_with_http_info(entry_application_preference_id, entry_application_preference_item, **kwargs)  # noqa: E501
            return data

    def update_entry_application_preference_with_http_info(self, entry_application_preference_id, entry_application_preference_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryApplicationPreference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_application_preference_with_http_info(entry_application_preference_id, entry_application_preference_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_preference_id: Numeric value of the entryapplicationpreferenceID (required)
        :param EntryApplicationPreferenceItem entry_application_preference_item: EntryApplicationPreference to update (required)
        :return: list[EntryApplicationPreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_application_preference_id', 'entry_application_preference_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_application_preference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_application_preference_id' is set
        if ('entry_application_preference_id' not in params or
                params['entry_application_preference_id'] is None):
            raise ValueError("Missing the required parameter `entry_application_preference_id` when calling `update_entry_application_preference`")  # noqa: E501
        # verify the required parameter 'entry_application_preference_item' is set
        if ('entry_application_preference_item' not in params or
                params['entry_application_preference_item'] is None):
            raise ValueError("Missing the required parameter `entry_application_preference_item` when calling `update_entry_application_preference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_application_preference_id' in params:
            path_params['EntryApplicationPreferenceID'] = params['entry_application_preference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_application_preference_item' in params:
            body_params = params['entry_application_preference_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryApplicationPreference/{EntryApplicationPreferenceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryApplicationPreferenceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_application_proxy(self, entry_application_proxy_id, entry_application_proxy_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryApplicationProxy in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_application_proxy(entry_application_proxy_id, entry_application_proxy_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_proxy_id: Numeric value of the entryapplicationproxyID (required)
        :param EntryApplicationProxyItem entry_application_proxy_item: EntryApplicationProxy to update (required)
        :return: list[EntryApplicationProxyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_application_proxy_with_http_info(entry_application_proxy_id, entry_application_proxy_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_application_proxy_with_http_info(entry_application_proxy_id, entry_application_proxy_item, **kwargs)  # noqa: E501
            return data

    def update_entry_application_proxy_with_http_info(self, entry_application_proxy_id, entry_application_proxy_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryApplicationProxy in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_application_proxy_with_http_info(entry_application_proxy_id, entry_application_proxy_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_proxy_id: Numeric value of the entryapplicationproxyID (required)
        :param EntryApplicationProxyItem entry_application_proxy_item: EntryApplicationProxy to update (required)
        :return: list[EntryApplicationProxyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_application_proxy_id', 'entry_application_proxy_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_application_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_application_proxy_id' is set
        if ('entry_application_proxy_id' not in params or
                params['entry_application_proxy_id'] is None):
            raise ValueError("Missing the required parameter `entry_application_proxy_id` when calling `update_entry_application_proxy`")  # noqa: E501
        # verify the required parameter 'entry_application_proxy_item' is set
        if ('entry_application_proxy_item' not in params or
                params['entry_application_proxy_item'] is None):
            raise ValueError("Missing the required parameter `entry_application_proxy_item` when calling `update_entry_application_proxy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_application_proxy_id' in params:
            path_params['EntryApplicationProxyID'] = params['entry_application_proxy_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_application_proxy_item' in params:
            body_params = params['entry_application_proxy_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryApplicationProxy/{EntryApplicationProxyID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryApplicationProxyItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_application_room_mate(self, entry_application_room_mate_id, entry_application_room_mate_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryApplicationRoomMate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_application_room_mate(entry_application_room_mate_id, entry_application_room_mate_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_room_mate_id: Numeric value of the entryapplicationroommateID (required)
        :param EntryApplicationRoomMateItem entry_application_room_mate_item: EntryApplicationRoomMate to update (required)
        :return: list[EntryApplicationRoomMateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_application_room_mate_with_http_info(entry_application_room_mate_id, entry_application_room_mate_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_application_room_mate_with_http_info(entry_application_room_mate_id, entry_application_room_mate_item, **kwargs)  # noqa: E501
            return data

    def update_entry_application_room_mate_with_http_info(self, entry_application_room_mate_id, entry_application_room_mate_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryApplicationRoomMate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_application_room_mate_with_http_info(entry_application_room_mate_id, entry_application_room_mate_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_room_mate_id: Numeric value of the entryapplicationroommateID (required)
        :param EntryApplicationRoomMateItem entry_application_room_mate_item: EntryApplicationRoomMate to update (required)
        :return: list[EntryApplicationRoomMateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_application_room_mate_id', 'entry_application_room_mate_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_application_room_mate" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_application_room_mate_id' is set
        if ('entry_application_room_mate_id' not in params or
                params['entry_application_room_mate_id'] is None):
            raise ValueError("Missing the required parameter `entry_application_room_mate_id` when calling `update_entry_application_room_mate`")  # noqa: E501
        # verify the required parameter 'entry_application_room_mate_item' is set
        if ('entry_application_room_mate_item' not in params or
                params['entry_application_room_mate_item'] is None):
            raise ValueError("Missing the required parameter `entry_application_room_mate_item` when calling `update_entry_application_room_mate`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_application_room_mate_id' in params:
            path_params['EntryApplicationRoomMateID'] = params['entry_application_room_mate_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_application_room_mate_item' in params:
            body_params = params['entry_application_room_mate_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryApplicationRoomMate/{EntryApplicationRoomMateID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryApplicationRoomMateItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_application_room_preference(self, entry_application_room_preference_id, entry_application_room_preference_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryApplicationRoomPreference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_application_room_preference(entry_application_room_preference_id, entry_application_room_preference_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_room_preference_id: Numeric value of the entryapplicationroompreferenceID (required)
        :param EntryApplicationRoomPreferenceItem entry_application_room_preference_item: EntryApplicationRoomPreference to update (required)
        :return: list[EntryApplicationRoomPreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_application_room_preference_with_http_info(entry_application_room_preference_id, entry_application_room_preference_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_application_room_preference_with_http_info(entry_application_room_preference_id, entry_application_room_preference_item, **kwargs)  # noqa: E501
            return data

    def update_entry_application_room_preference_with_http_info(self, entry_application_room_preference_id, entry_application_room_preference_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryApplicationRoomPreference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_application_room_preference_with_http_info(entry_application_room_preference_id, entry_application_room_preference_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_application_room_preference_id: Numeric value of the entryapplicationroompreferenceID (required)
        :param EntryApplicationRoomPreferenceItem entry_application_room_preference_item: EntryApplicationRoomPreference to update (required)
        :return: list[EntryApplicationRoomPreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_application_room_preference_id', 'entry_application_room_preference_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_application_room_preference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_application_room_preference_id' is set
        if ('entry_application_room_preference_id' not in params or
                params['entry_application_room_preference_id'] is None):
            raise ValueError("Missing the required parameter `entry_application_room_preference_id` when calling `update_entry_application_room_preference`")  # noqa: E501
        # verify the required parameter 'entry_application_room_preference_item' is set
        if ('entry_application_room_preference_item' not in params or
                params['entry_application_room_preference_item'] is None):
            raise ValueError("Missing the required parameter `entry_application_room_preference_item` when calling `update_entry_application_room_preference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_application_room_preference_id' in params:
            path_params['EntryApplicationRoomPreferenceID'] = params['entry_application_room_preference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_application_room_preference_item' in params:
            body_params = params['entry_application_room_preference_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryApplicationRoomPreference/{EntryApplicationRoomPreferenceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryApplicationRoomPreferenceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_correspondence(self, entry_correspondence_id, entry_correspondence_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryCorrespondence in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_correspondence(entry_correspondence_id, entry_correspondence_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_correspondence_id: Numeric value of the entrycorrespondenceID (required)
        :param EntryCorrespondenceItem entry_correspondence_item: EntryCorrespondence to update (required)
        :return: list[EntryCorrespondenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_correspondence_with_http_info(entry_correspondence_id, entry_correspondence_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_correspondence_with_http_info(entry_correspondence_id, entry_correspondence_item, **kwargs)  # noqa: E501
            return data

    def update_entry_correspondence_with_http_info(self, entry_correspondence_id, entry_correspondence_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryCorrespondence in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_correspondence_with_http_info(entry_correspondence_id, entry_correspondence_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_correspondence_id: Numeric value of the entrycorrespondenceID (required)
        :param EntryCorrespondenceItem entry_correspondence_item: EntryCorrespondence to update (required)
        :return: list[EntryCorrespondenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_correspondence_id', 'entry_correspondence_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_correspondence" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_correspondence_id' is set
        if ('entry_correspondence_id' not in params or
                params['entry_correspondence_id'] is None):
            raise ValueError("Missing the required parameter `entry_correspondence_id` when calling `update_entry_correspondence`")  # noqa: E501
        # verify the required parameter 'entry_correspondence_item' is set
        if ('entry_correspondence_item' not in params or
                params['entry_correspondence_item'] is None):
            raise ValueError("Missing the required parameter `entry_correspondence_item` when calling `update_entry_correspondence`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_correspondence_id' in params:
            path_params['EntryCorrespondenceID'] = params['entry_correspondence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_correspondence_item' in params:
            body_params = params['entry_correspondence_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryCorrespondence/{EntryCorrespondenceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryCorrespondenceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_custom_field(self, entry_custom_field_id, entry_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_custom_field(entry_custom_field_id, entry_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_custom_field_id: Numeric value of the entrycustomfieldID (required)
        :param EntryCustomFieldItem entry_custom_field_item: EntryCustomField to update (required)
        :return: list[EntryCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_custom_field_with_http_info(entry_custom_field_id, entry_custom_field_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_custom_field_with_http_info(entry_custom_field_id, entry_custom_field_item, **kwargs)  # noqa: E501
            return data

    def update_entry_custom_field_with_http_info(self, entry_custom_field_id, entry_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_custom_field_with_http_info(entry_custom_field_id, entry_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_custom_field_id: Numeric value of the entrycustomfieldID (required)
        :param EntryCustomFieldItem entry_custom_field_item: EntryCustomField to update (required)
        :return: list[EntryCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_custom_field_id', 'entry_custom_field_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_custom_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_custom_field_id' is set
        if ('entry_custom_field_id' not in params or
                params['entry_custom_field_id'] is None):
            raise ValueError("Missing the required parameter `entry_custom_field_id` when calling `update_entry_custom_field`")  # noqa: E501
        # verify the required parameter 'entry_custom_field_item' is set
        if ('entry_custom_field_item' not in params or
                params['entry_custom_field_item'] is None):
            raise ValueError("Missing the required parameter `entry_custom_field_item` when calling `update_entry_custom_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_custom_field_id' in params:
            path_params['EntryCustomFieldID'] = params['entry_custom_field_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_custom_field_item' in params:
            body_params = params['entry_custom_field_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryCustomField/{EntryCustomFieldID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_detail(self, entry_detail_id, entry_detail_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_detail(entry_detail_id, entry_detail_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_detail_id: Numeric value of the entrydetailID (required)
        :param EntryDetailItem entry_detail_item: EntryDetail to update (required)
        :return: list[EntryDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_detail_with_http_info(entry_detail_id, entry_detail_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_detail_with_http_info(entry_detail_id, entry_detail_item, **kwargs)  # noqa: E501
            return data

    def update_entry_detail_with_http_info(self, entry_detail_id, entry_detail_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_detail_with_http_info(entry_detail_id, entry_detail_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_detail_id: Numeric value of the entrydetailID (required)
        :param EntryDetailItem entry_detail_item: EntryDetail to update (required)
        :return: list[EntryDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_detail_id', 'entry_detail_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_detail" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_detail_id' is set
        if ('entry_detail_id' not in params or
                params['entry_detail_id'] is None):
            raise ValueError("Missing the required parameter `entry_detail_id` when calling `update_entry_detail`")  # noqa: E501
        # verify the required parameter 'entry_detail_item' is set
        if ('entry_detail_item' not in params or
                params['entry_detail_item'] is None):
            raise ValueError("Missing the required parameter `entry_detail_item` when calling `update_entry_detail`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_detail_id' in params:
            path_params['EntryDetailID'] = params['entry_detail_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_detail_item' in params:
            body_params = params['entry_detail_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryDetail/{EntryDetailID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryDetailItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_electronic_identity(self, entry_electronic_identity_id, entry_electronic_identity_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryElectronicIdentity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_electronic_identity(entry_electronic_identity_id, entry_electronic_identity_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_electronic_identity_id: Numeric value of the entryelectronicidentityID (required)
        :param EntryElectronicIdentityItem entry_electronic_identity_item: EntryElectronicIdentity to update (required)
        :return: list[EntryElectronicIdentityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_electronic_identity_with_http_info(entry_electronic_identity_id, entry_electronic_identity_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_electronic_identity_with_http_info(entry_electronic_identity_id, entry_electronic_identity_item, **kwargs)  # noqa: E501
            return data

    def update_entry_electronic_identity_with_http_info(self, entry_electronic_identity_id, entry_electronic_identity_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryElectronicIdentity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_electronic_identity_with_http_info(entry_electronic_identity_id, entry_electronic_identity_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_electronic_identity_id: Numeric value of the entryelectronicidentityID (required)
        :param EntryElectronicIdentityItem entry_electronic_identity_item: EntryElectronicIdentity to update (required)
        :return: list[EntryElectronicIdentityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_electronic_identity_id', 'entry_electronic_identity_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_electronic_identity" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_electronic_identity_id' is set
        if ('entry_electronic_identity_id' not in params or
                params['entry_electronic_identity_id'] is None):
            raise ValueError("Missing the required parameter `entry_electronic_identity_id` when calling `update_entry_electronic_identity`")  # noqa: E501
        # verify the required parameter 'entry_electronic_identity_item' is set
        if ('entry_electronic_identity_item' not in params or
                params['entry_electronic_identity_item'] is None):
            raise ValueError("Missing the required parameter `entry_electronic_identity_item` when calling `update_entry_electronic_identity`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_electronic_identity_id' in params:
            path_params['EntryElectronicIdentityID'] = params['entry_electronic_identity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_electronic_identity_item' in params:
            body_params = params['entry_electronic_identity_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryElectronicIdentity/{EntryElectronicIdentityID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryElectronicIdentityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_enrollment(self, entry_enrollment_id, entry_enrollment_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryEnrollment in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_enrollment(entry_enrollment_id, entry_enrollment_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_enrollment_id: Numeric value of the entryenrollmentID (required)
        :param EntryEnrollmentItem entry_enrollment_item: EntryEnrollment to update (required)
        :return: list[EntryEnrollmentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_enrollment_with_http_info(entry_enrollment_id, entry_enrollment_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_enrollment_with_http_info(entry_enrollment_id, entry_enrollment_item, **kwargs)  # noqa: E501
            return data

    def update_entry_enrollment_with_http_info(self, entry_enrollment_id, entry_enrollment_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryEnrollment in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_enrollment_with_http_info(entry_enrollment_id, entry_enrollment_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_enrollment_id: Numeric value of the entryenrollmentID (required)
        :param EntryEnrollmentItem entry_enrollment_item: EntryEnrollment to update (required)
        :return: list[EntryEnrollmentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_enrollment_id', 'entry_enrollment_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_enrollment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_enrollment_id' is set
        if ('entry_enrollment_id' not in params or
                params['entry_enrollment_id'] is None):
            raise ValueError("Missing the required parameter `entry_enrollment_id` when calling `update_entry_enrollment`")  # noqa: E501
        # verify the required parameter 'entry_enrollment_item' is set
        if ('entry_enrollment_item' not in params or
                params['entry_enrollment_item'] is None):
            raise ValueError("Missing the required parameter `entry_enrollment_item` when calling `update_entry_enrollment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_enrollment_id' in params:
            path_params['EntryEnrollmentID'] = params['entry_enrollment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_enrollment_item' in params:
            body_params = params['entry_enrollment_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryEnrollment/{EntryEnrollmentID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryEnrollmentItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_event(self, entry_event_id, entry_event_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryEvent in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_event(entry_event_id, entry_event_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_event_id: Numeric value of the entryeventID (required)
        :param EntryEventItem entry_event_item: EntryEvent to update (required)
        :return: list[EntryEventItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_event_with_http_info(entry_event_id, entry_event_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_event_with_http_info(entry_event_id, entry_event_item, **kwargs)  # noqa: E501
            return data

    def update_entry_event_with_http_info(self, entry_event_id, entry_event_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryEvent in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_event_with_http_info(entry_event_id, entry_event_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_event_id: Numeric value of the entryeventID (required)
        :param EntryEventItem entry_event_item: EntryEvent to update (required)
        :return: list[EntryEventItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_event_id', 'entry_event_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_event_id' is set
        if ('entry_event_id' not in params or
                params['entry_event_id'] is None):
            raise ValueError("Missing the required parameter `entry_event_id` when calling `update_entry_event`")  # noqa: E501
        # verify the required parameter 'entry_event_item' is set
        if ('entry_event_item' not in params or
                params['entry_event_item'] is None):
            raise ValueError("Missing the required parameter `entry_event_item` when calling `update_entry_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_event_id' in params:
            path_params['EntryEventID'] = params['entry_event_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_event_item' in params:
            body_params = params['entry_event_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryEvent/{EntryEventID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryEventItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_family(self, entry_family_id, entry_family_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryFamily in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_family(entry_family_id, entry_family_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_family_id: Numeric value of the entryfamilyID (required)
        :param EntryFamilyItem entry_family_item: EntryFamily to update (required)
        :return: list[EntryFamilyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_family_with_http_info(entry_family_id, entry_family_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_family_with_http_info(entry_family_id, entry_family_item, **kwargs)  # noqa: E501
            return data

    def update_entry_family_with_http_info(self, entry_family_id, entry_family_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryFamily in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_family_with_http_info(entry_family_id, entry_family_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_family_id: Numeric value of the entryfamilyID (required)
        :param EntryFamilyItem entry_family_item: EntryFamily to update (required)
        :return: list[EntryFamilyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_family_id', 'entry_family_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_family" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_family_id' is set
        if ('entry_family_id' not in params or
                params['entry_family_id'] is None):
            raise ValueError("Missing the required parameter `entry_family_id` when calling `update_entry_family`")  # noqa: E501
        # verify the required parameter 'entry_family_item' is set
        if ('entry_family_item' not in params or
                params['entry_family_item'] is None):
            raise ValueError("Missing the required parameter `entry_family_item` when calling `update_entry_family`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_family_id' in params:
            path_params['EntryFamilyID'] = params['entry_family_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_family_item' in params:
            body_params = params['entry_family_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryFamily/{EntryFamilyID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryFamilyItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_group(self, entry_group_id, entry_group_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_group(entry_group_id, entry_group_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_group_id: Numeric value of the entrygroupID (required)
        :param EntryGroupItem entry_group_item: EntryGroup to update (required)
        :return: list[EntryGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_group_with_http_info(entry_group_id, entry_group_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_group_with_http_info(entry_group_id, entry_group_item, **kwargs)  # noqa: E501
            return data

    def update_entry_group_with_http_info(self, entry_group_id, entry_group_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_group_with_http_info(entry_group_id, entry_group_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_group_id: Numeric value of the entrygroupID (required)
        :param EntryGroupItem entry_group_item: EntryGroup to update (required)
        :return: list[EntryGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_group_id', 'entry_group_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_group_id' is set
        if ('entry_group_id' not in params or
                params['entry_group_id'] is None):
            raise ValueError("Missing the required parameter `entry_group_id` when calling `update_entry_group`")  # noqa: E501
        # verify the required parameter 'entry_group_item' is set
        if ('entry_group_item' not in params or
                params['entry_group_item'] is None):
            raise ValueError("Missing the required parameter `entry_group_item` when calling `update_entry_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_group_id' in params:
            path_params['EntryGroupID'] = params['entry_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_group_item' in params:
            body_params = params['entry_group_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryGroup/{EntryGroupID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryGroupItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_invitation(self, entry_invitation_id, entry_invitation_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryInvitation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_invitation(entry_invitation_id, entry_invitation_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_invitation_id: Numeric value of the entryinvitationID (required)
        :param EntryInvitationItem entry_invitation_item: EntryInvitation to update (required)
        :return: list[EntryInvitationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_invitation_with_http_info(entry_invitation_id, entry_invitation_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_invitation_with_http_info(entry_invitation_id, entry_invitation_item, **kwargs)  # noqa: E501
            return data

    def update_entry_invitation_with_http_info(self, entry_invitation_id, entry_invitation_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryInvitation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_invitation_with_http_info(entry_invitation_id, entry_invitation_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_invitation_id: Numeric value of the entryinvitationID (required)
        :param EntryInvitationItem entry_invitation_item: EntryInvitation to update (required)
        :return: list[EntryInvitationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_invitation_id', 'entry_invitation_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_invitation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_invitation_id' is set
        if ('entry_invitation_id' not in params or
                params['entry_invitation_id'] is None):
            raise ValueError("Missing the required parameter `entry_invitation_id` when calling `update_entry_invitation`")  # noqa: E501
        # verify the required parameter 'entry_invitation_item' is set
        if ('entry_invitation_item' not in params or
                params['entry_invitation_item'] is None):
            raise ValueError("Missing the required parameter `entry_invitation_item` when calling `update_entry_invitation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_invitation_id' in params:
            path_params['EntryInvitationID'] = params['entry_invitation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_invitation_item' in params:
            body_params = params['entry_invitation_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryInvitation/{EntryInvitationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryInvitationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_meal(self, entry_meal_id, entry_meal_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryMeal in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_meal(entry_meal_id, entry_meal_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_meal_id: Numeric value of the entrymealID (required)
        :param EntryMealItem entry_meal_item: EntryMeal to update (required)
        :return: list[EntryMealItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_meal_with_http_info(entry_meal_id, entry_meal_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_meal_with_http_info(entry_meal_id, entry_meal_item, **kwargs)  # noqa: E501
            return data

    def update_entry_meal_with_http_info(self, entry_meal_id, entry_meal_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryMeal in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_meal_with_http_info(entry_meal_id, entry_meal_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_meal_id: Numeric value of the entrymealID (required)
        :param EntryMealItem entry_meal_item: EntryMeal to update (required)
        :return: list[EntryMealItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_meal_id', 'entry_meal_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_meal" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_meal_id' is set
        if ('entry_meal_id' not in params or
                params['entry_meal_id'] is None):
            raise ValueError("Missing the required parameter `entry_meal_id` when calling `update_entry_meal`")  # noqa: E501
        # verify the required parameter 'entry_meal_item' is set
        if ('entry_meal_item' not in params or
                params['entry_meal_item'] is None):
            raise ValueError("Missing the required parameter `entry_meal_item` when calling `update_entry_meal`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_meal_id' in params:
            path_params['EntryMealID'] = params['entry_meal_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_meal_item' in params:
            body_params = params['entry_meal_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryMeal/{EntryMealID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryMealItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_meal_plan_detail(self, entry_meal_plan_detail_id, entry_meal_plan_detail_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryMealPlanDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_meal_plan_detail(entry_meal_plan_detail_id, entry_meal_plan_detail_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_meal_plan_detail_id: Numeric value of the entrymealplandetailID (required)
        :param EntryMealPlanDetailItem entry_meal_plan_detail_item: EntryMealPlanDetail to update (required)
        :return: list[EntryMealPlanDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_meal_plan_detail_with_http_info(entry_meal_plan_detail_id, entry_meal_plan_detail_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_meal_plan_detail_with_http_info(entry_meal_plan_detail_id, entry_meal_plan_detail_item, **kwargs)  # noqa: E501
            return data

    def update_entry_meal_plan_detail_with_http_info(self, entry_meal_plan_detail_id, entry_meal_plan_detail_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryMealPlanDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_meal_plan_detail_with_http_info(entry_meal_plan_detail_id, entry_meal_plan_detail_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_meal_plan_detail_id: Numeric value of the entrymealplandetailID (required)
        :param EntryMealPlanDetailItem entry_meal_plan_detail_item: EntryMealPlanDetail to update (required)
        :return: list[EntryMealPlanDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_meal_plan_detail_id', 'entry_meal_plan_detail_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_meal_plan_detail" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_meal_plan_detail_id' is set
        if ('entry_meal_plan_detail_id' not in params or
                params['entry_meal_plan_detail_id'] is None):
            raise ValueError("Missing the required parameter `entry_meal_plan_detail_id` when calling `update_entry_meal_plan_detail`")  # noqa: E501
        # verify the required parameter 'entry_meal_plan_detail_item' is set
        if ('entry_meal_plan_detail_item' not in params or
                params['entry_meal_plan_detail_item'] is None):
            raise ValueError("Missing the required parameter `entry_meal_plan_detail_item` when calling `update_entry_meal_plan_detail`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_meal_plan_detail_id' in params:
            path_params['EntryMealPlanDetailID'] = params['entry_meal_plan_detail_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_meal_plan_detail_item' in params:
            body_params = params['entry_meal_plan_detail_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryMealPlanDetail/{EntryMealPlanDetailID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryMealPlanDetailItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_meal_tag(self, entry_meal_tag_id, entry_meal_tag_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryMealTag in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_meal_tag(entry_meal_tag_id, entry_meal_tag_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_meal_tag_id: Numeric value of the entrymealtagID (required)
        :param EntryMealTagItem entry_meal_tag_item: EntryMealTag to update (required)
        :return: list[EntryMealTagItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_meal_tag_with_http_info(entry_meal_tag_id, entry_meal_tag_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_meal_tag_with_http_info(entry_meal_tag_id, entry_meal_tag_item, **kwargs)  # noqa: E501
            return data

    def update_entry_meal_tag_with_http_info(self, entry_meal_tag_id, entry_meal_tag_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryMealTag in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_meal_tag_with_http_info(entry_meal_tag_id, entry_meal_tag_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_meal_tag_id: Numeric value of the entrymealtagID (required)
        :param EntryMealTagItem entry_meal_tag_item: EntryMealTag to update (required)
        :return: list[EntryMealTagItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_meal_tag_id', 'entry_meal_tag_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_meal_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_meal_tag_id' is set
        if ('entry_meal_tag_id' not in params or
                params['entry_meal_tag_id'] is None):
            raise ValueError("Missing the required parameter `entry_meal_tag_id` when calling `update_entry_meal_tag`")  # noqa: E501
        # verify the required parameter 'entry_meal_tag_item' is set
        if ('entry_meal_tag_item' not in params or
                params['entry_meal_tag_item'] is None):
            raise ValueError("Missing the required parameter `entry_meal_tag_item` when calling `update_entry_meal_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_meal_tag_id' in params:
            path_params['EntryMealTagID'] = params['entry_meal_tag_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_meal_tag_item' in params:
            body_params = params['entry_meal_tag_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryMealTag/{EntryMealTagID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryMealTagItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_membership(self, entry_membership_id, entry_membership_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryMembership in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_membership(entry_membership_id, entry_membership_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_membership_id: Numeric value of the entrymembershipID (required)
        :param EntryMembershipItem entry_membership_item: EntryMembership to update (required)
        :return: list[EntryMembershipItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_membership_with_http_info(entry_membership_id, entry_membership_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_membership_with_http_info(entry_membership_id, entry_membership_item, **kwargs)  # noqa: E501
            return data

    def update_entry_membership_with_http_info(self, entry_membership_id, entry_membership_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryMembership in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_membership_with_http_info(entry_membership_id, entry_membership_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_membership_id: Numeric value of the entrymembershipID (required)
        :param EntryMembershipItem entry_membership_item: EntryMembership to update (required)
        :return: list[EntryMembershipItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_membership_id', 'entry_membership_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_membership" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_membership_id' is set
        if ('entry_membership_id' not in params or
                params['entry_membership_id'] is None):
            raise ValueError("Missing the required parameter `entry_membership_id` when calling `update_entry_membership`")  # noqa: E501
        # verify the required parameter 'entry_membership_item' is set
        if ('entry_membership_item' not in params or
                params['entry_membership_item'] is None):
            raise ValueError("Missing the required parameter `entry_membership_item` when calling `update_entry_membership`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_membership_id' in params:
            path_params['EntryMembershipID'] = params['entry_membership_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_membership_item' in params:
            body_params = params['entry_membership_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryMembership/{EntryMembershipID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryMembershipItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_note(self, entry_note_id, entry_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_note(entry_note_id, entry_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_note_id: Numeric value of the entrynoteID (required)
        :param EntryNoteItem entry_note_item: EntryNote to update (required)
        :return: list[EntryNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_note_with_http_info(entry_note_id, entry_note_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_note_with_http_info(entry_note_id, entry_note_item, **kwargs)  # noqa: E501
            return data

    def update_entry_note_with_http_info(self, entry_note_id, entry_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_note_with_http_info(entry_note_id, entry_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_note_id: Numeric value of the entrynoteID (required)
        :param EntryNoteItem entry_note_item: EntryNote to update (required)
        :return: list[EntryNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_note_id', 'entry_note_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_note_id' is set
        if ('entry_note_id' not in params or
                params['entry_note_id'] is None):
            raise ValueError("Missing the required parameter `entry_note_id` when calling `update_entry_note`")  # noqa: E501
        # verify the required parameter 'entry_note_item' is set
        if ('entry_note_item' not in params or
                params['entry_note_item'] is None):
            raise ValueError("Missing the required parameter `entry_note_item` when calling `update_entry_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_note_id' in params:
            path_params['EntryNoteID'] = params['entry_note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_note_item' in params:
            body_params = params['entry_note_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryNote/{EntryNoteID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_parcel(self, entry_parcel_id, entry_parcel_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryParcel in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_parcel(entry_parcel_id, entry_parcel_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_parcel_id: Numeric value of the entryparcelID (required)
        :param EntryParcelItem entry_parcel_item: EntryParcel to update (required)
        :return: list[EntryParcelItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_parcel_with_http_info(entry_parcel_id, entry_parcel_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_parcel_with_http_info(entry_parcel_id, entry_parcel_item, **kwargs)  # noqa: E501
            return data

    def update_entry_parcel_with_http_info(self, entry_parcel_id, entry_parcel_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryParcel in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_parcel_with_http_info(entry_parcel_id, entry_parcel_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_parcel_id: Numeric value of the entryparcelID (required)
        :param EntryParcelItem entry_parcel_item: EntryParcel to update (required)
        :return: list[EntryParcelItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_parcel_id', 'entry_parcel_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_parcel" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_parcel_id' is set
        if ('entry_parcel_id' not in params or
                params['entry_parcel_id'] is None):
            raise ValueError("Missing the required parameter `entry_parcel_id` when calling `update_entry_parcel`")  # noqa: E501
        # verify the required parameter 'entry_parcel_item' is set
        if ('entry_parcel_item' not in params or
                params['entry_parcel_item'] is None):
            raise ValueError("Missing the required parameter `entry_parcel_item` when calling `update_entry_parcel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_parcel_id' in params:
            path_params['EntryParcelID'] = params['entry_parcel_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_parcel_item' in params:
            body_params = params['entry_parcel_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryParcel/{EntryParcelID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryParcelItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_portal_activity(self, entry_portal_activity_id, entry_portal_activity_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryPortalActivity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_portal_activity(entry_portal_activity_id, entry_portal_activity_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_portal_activity_id: Numeric value of the entryportalactivityID (required)
        :param EntryPortalActivityItem entry_portal_activity_item: EntryPortalActivity to update (required)
        :return: list[EntryPortalActivityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_portal_activity_with_http_info(entry_portal_activity_id, entry_portal_activity_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_portal_activity_with_http_info(entry_portal_activity_id, entry_portal_activity_item, **kwargs)  # noqa: E501
            return data

    def update_entry_portal_activity_with_http_info(self, entry_portal_activity_id, entry_portal_activity_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryPortalActivity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_portal_activity_with_http_info(entry_portal_activity_id, entry_portal_activity_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_portal_activity_id: Numeric value of the entryportalactivityID (required)
        :param EntryPortalActivityItem entry_portal_activity_item: EntryPortalActivity to update (required)
        :return: list[EntryPortalActivityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_portal_activity_id', 'entry_portal_activity_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_portal_activity" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_portal_activity_id' is set
        if ('entry_portal_activity_id' not in params or
                params['entry_portal_activity_id'] is None):
            raise ValueError("Missing the required parameter `entry_portal_activity_id` when calling `update_entry_portal_activity`")  # noqa: E501
        # verify the required parameter 'entry_portal_activity_item' is set
        if ('entry_portal_activity_item' not in params or
                params['entry_portal_activity_item'] is None):
            raise ValueError("Missing the required parameter `entry_portal_activity_item` when calling `update_entry_portal_activity`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_portal_activity_id' in params:
            path_params['EntryPortalActivityID'] = params['entry_portal_activity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_portal_activity_item' in params:
            body_params = params['entry_portal_activity_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryPortalActivity/{EntryPortalActivityID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryPortalActivityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_position(self, entry_position_id, entry_position_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryPosition in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_position(entry_position_id, entry_position_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_position_id: Numeric value of the entrypositionID (required)
        :param EntryPositionItem entry_position_item: EntryPosition to update (required)
        :return: list[EntryPositionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_position_with_http_info(entry_position_id, entry_position_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_position_with_http_info(entry_position_id, entry_position_item, **kwargs)  # noqa: E501
            return data

    def update_entry_position_with_http_info(self, entry_position_id, entry_position_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryPosition in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_position_with_http_info(entry_position_id, entry_position_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_position_id: Numeric value of the entrypositionID (required)
        :param EntryPositionItem entry_position_item: EntryPosition to update (required)
        :return: list[EntryPositionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_position_id', 'entry_position_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_position" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_position_id' is set
        if ('entry_position_id' not in params or
                params['entry_position_id'] is None):
            raise ValueError("Missing the required parameter `entry_position_id` when calling `update_entry_position`")  # noqa: E501
        # verify the required parameter 'entry_position_item' is set
        if ('entry_position_item' not in params or
                params['entry_position_item'] is None):
            raise ValueError("Missing the required parameter `entry_position_item` when calling `update_entry_position`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_position_id' in params:
            path_params['EntryPositionID'] = params['entry_position_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_position_item' in params:
            body_params = params['entry_position_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryPosition/{EntryPositionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryPositionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_profile(self, entry_profile_id, entry_profile_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_profile(entry_profile_id, entry_profile_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_profile_id: Numeric value of the entryprofileID (required)
        :param EntryProfileItem entry_profile_item: EntryProfile to update (required)
        :return: list[EntryProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_profile_with_http_info(entry_profile_id, entry_profile_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_profile_with_http_info(entry_profile_id, entry_profile_item, **kwargs)  # noqa: E501
            return data

    def update_entry_profile_with_http_info(self, entry_profile_id, entry_profile_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_profile_with_http_info(entry_profile_id, entry_profile_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_profile_id: Numeric value of the entryprofileID (required)
        :param EntryProfileItem entry_profile_item: EntryProfile to update (required)
        :return: list[EntryProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_profile_id', 'entry_profile_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_profile_id' is set
        if ('entry_profile_id' not in params or
                params['entry_profile_id'] is None):
            raise ValueError("Missing the required parameter `entry_profile_id` when calling `update_entry_profile`")  # noqa: E501
        # verify the required parameter 'entry_profile_item' is set
        if ('entry_profile_item' not in params or
                params['entry_profile_item'] is None):
            raise ValueError("Missing the required parameter `entry_profile_item` when calling `update_entry_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_profile_id' in params:
            path_params['EntryProfileID'] = params['entry_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_profile_item' in params:
            body_params = params['entry_profile_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryProfile/{EntryProfileID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryProfileItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_result(self, entry_result_id, entry_result_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryResult in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_result(entry_result_id, entry_result_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_result_id: Numeric value of the entryresultID (required)
        :param EntryResultItem entry_result_item: EntryResult to update (required)
        :return: list[EntryResultItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_result_with_http_info(entry_result_id, entry_result_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_result_with_http_info(entry_result_id, entry_result_item, **kwargs)  # noqa: E501
            return data

    def update_entry_result_with_http_info(self, entry_result_id, entry_result_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryResult in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_result_with_http_info(entry_result_id, entry_result_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_result_id: Numeric value of the entryresultID (required)
        :param EntryResultItem entry_result_item: EntryResult to update (required)
        :return: list[EntryResultItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_result_id', 'entry_result_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_result" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_result_id' is set
        if ('entry_result_id' not in params or
                params['entry_result_id'] is None):
            raise ValueError("Missing the required parameter `entry_result_id` when calling `update_entry_result`")  # noqa: E501
        # verify the required parameter 'entry_result_item' is set
        if ('entry_result_item' not in params or
                params['entry_result_item'] is None):
            raise ValueError("Missing the required parameter `entry_result_item` when calling `update_entry_result`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_result_id' in params:
            path_params['EntryResultID'] = params['entry_result_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_result_item' in params:
            body_params = params['entry_result_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryResult/{EntryResultID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryResultItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_schedule_transaction(self, entry_schedule_transaction_id, entry_schedule_transaction_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryScheduleTransaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_schedule_transaction(entry_schedule_transaction_id, entry_schedule_transaction_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_schedule_transaction_id: Numeric value of the entryscheduletransactionID (required)
        :param EntryScheduleTransactionItem entry_schedule_transaction_item: EntryScheduleTransaction to update (required)
        :return: list[EntryScheduleTransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_schedule_transaction_with_http_info(entry_schedule_transaction_id, entry_schedule_transaction_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_schedule_transaction_with_http_info(entry_schedule_transaction_id, entry_schedule_transaction_item, **kwargs)  # noqa: E501
            return data

    def update_entry_schedule_transaction_with_http_info(self, entry_schedule_transaction_id, entry_schedule_transaction_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryScheduleTransaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_schedule_transaction_with_http_info(entry_schedule_transaction_id, entry_schedule_transaction_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_schedule_transaction_id: Numeric value of the entryscheduletransactionID (required)
        :param EntryScheduleTransactionItem entry_schedule_transaction_item: EntryScheduleTransaction to update (required)
        :return: list[EntryScheduleTransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_schedule_transaction_id', 'entry_schedule_transaction_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_schedule_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_schedule_transaction_id' is set
        if ('entry_schedule_transaction_id' not in params or
                params['entry_schedule_transaction_id'] is None):
            raise ValueError("Missing the required parameter `entry_schedule_transaction_id` when calling `update_entry_schedule_transaction`")  # noqa: E501
        # verify the required parameter 'entry_schedule_transaction_item' is set
        if ('entry_schedule_transaction_item' not in params or
                params['entry_schedule_transaction_item'] is None):
            raise ValueError("Missing the required parameter `entry_schedule_transaction_item` when calling `update_entry_schedule_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_schedule_transaction_id' in params:
            path_params['EntryScheduleTransactionID'] = params['entry_schedule_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_schedule_transaction_item' in params:
            body_params = params['entry_schedule_transaction_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryScheduleTransaction/{EntryScheduleTransactionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryScheduleTransactionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_scholarship(self, entry_scholarship_id, entry_scholarship_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryScholarship in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_scholarship(entry_scholarship_id, entry_scholarship_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_scholarship_id: Numeric value of the entryscholarshipID (required)
        :param EntryScholarshipItem entry_scholarship_item: EntryScholarship to update (required)
        :return: list[EntryScholarshipItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_scholarship_with_http_info(entry_scholarship_id, entry_scholarship_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_scholarship_with_http_info(entry_scholarship_id, entry_scholarship_item, **kwargs)  # noqa: E501
            return data

    def update_entry_scholarship_with_http_info(self, entry_scholarship_id, entry_scholarship_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryScholarship in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_scholarship_with_http_info(entry_scholarship_id, entry_scholarship_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_scholarship_id: Numeric value of the entryscholarshipID (required)
        :param EntryScholarshipItem entry_scholarship_item: EntryScholarship to update (required)
        :return: list[EntryScholarshipItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_scholarship_id', 'entry_scholarship_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_scholarship" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_scholarship_id' is set
        if ('entry_scholarship_id' not in params or
                params['entry_scholarship_id'] is None):
            raise ValueError("Missing the required parameter `entry_scholarship_id` when calling `update_entry_scholarship`")  # noqa: E501
        # verify the required parameter 'entry_scholarship_item' is set
        if ('entry_scholarship_item' not in params or
                params['entry_scholarship_item'] is None):
            raise ValueError("Missing the required parameter `entry_scholarship_item` when calling `update_entry_scholarship`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_scholarship_id' in params:
            path_params['EntryScholarshipID'] = params['entry_scholarship_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_scholarship_item' in params:
            body_params = params['entry_scholarship_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryScholarship/{EntryScholarshipID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryScholarshipItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_school(self, entry_school_id, entry_school_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntrySchool in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_school(entry_school_id, entry_school_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_school_id: Numeric value of the entryschoolID (required)
        :param EntrySchoolItem entry_school_item: EntrySchool to update (required)
        :return: list[EntrySchoolItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_school_with_http_info(entry_school_id, entry_school_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_school_with_http_info(entry_school_id, entry_school_item, **kwargs)  # noqa: E501
            return data

    def update_entry_school_with_http_info(self, entry_school_id, entry_school_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntrySchool in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_school_with_http_info(entry_school_id, entry_school_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_school_id: Numeric value of the entryschoolID (required)
        :param EntrySchoolItem entry_school_item: EntrySchool to update (required)
        :return: list[EntrySchoolItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_school_id', 'entry_school_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_school" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_school_id' is set
        if ('entry_school_id' not in params or
                params['entry_school_id'] is None):
            raise ValueError("Missing the required parameter `entry_school_id` when calling `update_entry_school`")  # noqa: E501
        # verify the required parameter 'entry_school_item' is set
        if ('entry_school_item' not in params or
                params['entry_school_item'] is None):
            raise ValueError("Missing the required parameter `entry_school_item` when calling `update_entry_school`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_school_id' in params:
            path_params['EntrySchoolID'] = params['entry_school_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_school_item' in params:
            body_params = params['entry_school_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntrySchool/{EntrySchoolID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntrySchoolItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_sdas(self, entry_sdasid, entry_sdas_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntrySDAS in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_sdas(entry_sdasid, entry_sdas_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_sdasid: Numeric value of the entrysdasID (required)
        :param EntrySDASItem entry_sdas_item: EntrySDAS to update (required)
        :return: list[EntrySDASItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_sdas_with_http_info(entry_sdasid, entry_sdas_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_sdas_with_http_info(entry_sdasid, entry_sdas_item, **kwargs)  # noqa: E501
            return data

    def update_entry_sdas_with_http_info(self, entry_sdasid, entry_sdas_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntrySDAS in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_sdas_with_http_info(entry_sdasid, entry_sdas_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_sdasid: Numeric value of the entrysdasID (required)
        :param EntrySDASItem entry_sdas_item: EntrySDAS to update (required)
        :return: list[EntrySDASItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_sdasid', 'entry_sdas_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_sdas" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_sdasid' is set
        if ('entry_sdasid' not in params or
                params['entry_sdasid'] is None):
            raise ValueError("Missing the required parameter `entry_sdasid` when calling `update_entry_sdas`")  # noqa: E501
        # verify the required parameter 'entry_sdas_item' is set
        if ('entry_sdas_item' not in params or
                params['entry_sdas_item'] is None):
            raise ValueError("Missing the required parameter `entry_sdas_item` when calling `update_entry_sdas`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_sdasid' in params:
            path_params['EntrySDASID'] = params['entry_sdasid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_sdas_item' in params:
            body_params = params['entry_sdas_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntrySDAS/{EntrySDASID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntrySDASItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_entry_visitor(self, entry_visitor_id, entry_visitor_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryVisitor in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_visitor(entry_visitor_id, entry_visitor_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_visitor_id: Numeric value of the entryvisitorID (required)
        :param EntryVisitorItem entry_visitor_item: EntryVisitor to update (required)
        :return: list[EntryVisitorItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_entry_visitor_with_http_info(entry_visitor_id, entry_visitor_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_entry_visitor_with_http_info(entry_visitor_id, entry_visitor_item, **kwargs)  # noqa: E501
            return data

    def update_entry_visitor_with_http_info(self, entry_visitor_id, entry_visitor_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EntryVisitor in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_entry_visitor_with_http_info(entry_visitor_id, entry_visitor_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int entry_visitor_id: Numeric value of the entryvisitorID (required)
        :param EntryVisitorItem entry_visitor_item: EntryVisitor to update (required)
        :return: list[EntryVisitorItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entry_visitor_id', 'entry_visitor_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_entry_visitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entry_visitor_id' is set
        if ('entry_visitor_id' not in params or
                params['entry_visitor_id'] is None):
            raise ValueError("Missing the required parameter `entry_visitor_id` when calling `update_entry_visitor`")  # noqa: E501
        # verify the required parameter 'entry_visitor_item' is set
        if ('entry_visitor_item' not in params or
                params['entry_visitor_item'] is None):
            raise ValueError("Missing the required parameter `entry_visitor_item` when calling `update_entry_visitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'entry_visitor_id' in params:
            path_params['EntryVisitorID'] = params['entry_visitor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'entry_visitor_item' in params:
            body_params = params['entry_visitor_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EntryVisitor/{EntryVisitorID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntryVisitorItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_event(self, event_id, event_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Event in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event(event_id, event_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: Numeric value of the eventID (required)
        :param EventItem event_item: Event to update (required)
        :return: list[EventItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_event_with_http_info(event_id, event_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_event_with_http_info(event_id, event_item, **kwargs)  # noqa: E501
            return data

    def update_event_with_http_info(self, event_id, event_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Event in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_with_http_info(event_id, event_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_id: Numeric value of the eventID (required)
        :param EventItem event_item: Event to update (required)
        :return: list[EventItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'event_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `update_event`")  # noqa: E501
        # verify the required parameter 'event_item' is set
        if ('event_item' not in params or
                params['event_item'] is None):
            raise ValueError("Missing the required parameter `event_item` when calling `update_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['EventID'] = params['event_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'event_item' in params:
            body_params = params['event_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Event/{EventID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_event_charge(self, event_charge_id, event_charge_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EventCharge in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_charge(event_charge_id, event_charge_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_charge_id: Numeric value of the eventchargeID (required)
        :param EventChargeItem event_charge_item: EventCharge to update (required)
        :return: list[EventChargeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_event_charge_with_http_info(event_charge_id, event_charge_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_event_charge_with_http_info(event_charge_id, event_charge_item, **kwargs)  # noqa: E501
            return data

    def update_event_charge_with_http_info(self, event_charge_id, event_charge_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EventCharge in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_charge_with_http_info(event_charge_id, event_charge_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_charge_id: Numeric value of the eventchargeID (required)
        :param EventChargeItem event_charge_item: EventCharge to update (required)
        :return: list[EventChargeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_charge_id', 'event_charge_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_event_charge" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_charge_id' is set
        if ('event_charge_id' not in params or
                params['event_charge_id'] is None):
            raise ValueError("Missing the required parameter `event_charge_id` when calling `update_event_charge`")  # noqa: E501
        # verify the required parameter 'event_charge_item' is set
        if ('event_charge_item' not in params or
                params['event_charge_item'] is None):
            raise ValueError("Missing the required parameter `event_charge_item` when calling `update_event_charge`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_charge_id' in params:
            path_params['EventChargeID'] = params['event_charge_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'event_charge_item' in params:
            body_params = params['event_charge_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EventCharge/{EventChargeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventChargeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_event_contact_entry(self, event_contact_entry_id, event_contact_entry_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EventContactEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_contact_entry(event_contact_entry_id, event_contact_entry_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_contact_entry_id: Numeric value of the eventcontactentryID (required)
        :param EventContactEntryItem event_contact_entry_item: EventContactEntry to update (required)
        :return: list[EventContactEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_event_contact_entry_with_http_info(event_contact_entry_id, event_contact_entry_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_event_contact_entry_with_http_info(event_contact_entry_id, event_contact_entry_item, **kwargs)  # noqa: E501
            return data

    def update_event_contact_entry_with_http_info(self, event_contact_entry_id, event_contact_entry_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EventContactEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_contact_entry_with_http_info(event_contact_entry_id, event_contact_entry_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_contact_entry_id: Numeric value of the eventcontactentryID (required)
        :param EventContactEntryItem event_contact_entry_item: EventContactEntry to update (required)
        :return: list[EventContactEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_contact_entry_id', 'event_contact_entry_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_event_contact_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_contact_entry_id' is set
        if ('event_contact_entry_id' not in params or
                params['event_contact_entry_id'] is None):
            raise ValueError("Missing the required parameter `event_contact_entry_id` when calling `update_event_contact_entry`")  # noqa: E501
        # verify the required parameter 'event_contact_entry_item' is set
        if ('event_contact_entry_item' not in params or
                params['event_contact_entry_item'] is None):
            raise ValueError("Missing the required parameter `event_contact_entry_item` when calling `update_event_contact_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_contact_entry_id' in params:
            path_params['EventContactEntryID'] = params['event_contact_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'event_contact_entry_item' in params:
            body_params = params['event_contact_entry_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EventContactEntry/{EventContactEntryID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventContactEntryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_event_custom_field(self, event_custom_field_id, event_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EventCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_custom_field(event_custom_field_id, event_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_custom_field_id: Numeric value of the eventcustomfieldID (required)
        :param EventCustomFieldItem event_custom_field_item: EventCustomField to update (required)
        :return: list[EventCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_event_custom_field_with_http_info(event_custom_field_id, event_custom_field_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_event_custom_field_with_http_info(event_custom_field_id, event_custom_field_item, **kwargs)  # noqa: E501
            return data

    def update_event_custom_field_with_http_info(self, event_custom_field_id, event_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EventCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_custom_field_with_http_info(event_custom_field_id, event_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_custom_field_id: Numeric value of the eventcustomfieldID (required)
        :param EventCustomFieldItem event_custom_field_item: EventCustomField to update (required)
        :return: list[EventCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_custom_field_id', 'event_custom_field_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_event_custom_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_custom_field_id' is set
        if ('event_custom_field_id' not in params or
                params['event_custom_field_id'] is None):
            raise ValueError("Missing the required parameter `event_custom_field_id` when calling `update_event_custom_field`")  # noqa: E501
        # verify the required parameter 'event_custom_field_item' is set
        if ('event_custom_field_item' not in params or
                params['event_custom_field_item'] is None):
            raise ValueError("Missing the required parameter `event_custom_field_item` when calling `update_event_custom_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_custom_field_id' in params:
            path_params['EventCustomFieldID'] = params['event_custom_field_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'event_custom_field_item' in params:
            body_params = params['event_custom_field_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EventCustomField/{EventCustomFieldID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_event_meal_plan(self, event_meal_plan_id, event_meal_plan_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EventMealPlan in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_meal_plan(event_meal_plan_id, event_meal_plan_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_meal_plan_id: Numeric value of the eventmealplanID (required)
        :param EventMealPlanItem event_meal_plan_item: EventMealPlan to update (required)
        :return: list[EventMealPlanItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_event_meal_plan_with_http_info(event_meal_plan_id, event_meal_plan_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_event_meal_plan_with_http_info(event_meal_plan_id, event_meal_plan_item, **kwargs)  # noqa: E501
            return data

    def update_event_meal_plan_with_http_info(self, event_meal_plan_id, event_meal_plan_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EventMealPlan in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_meal_plan_with_http_info(event_meal_plan_id, event_meal_plan_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_meal_plan_id: Numeric value of the eventmealplanID (required)
        :param EventMealPlanItem event_meal_plan_item: EventMealPlan to update (required)
        :return: list[EventMealPlanItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_meal_plan_id', 'event_meal_plan_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_event_meal_plan" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_meal_plan_id' is set
        if ('event_meal_plan_id' not in params or
                params['event_meal_plan_id'] is None):
            raise ValueError("Missing the required parameter `event_meal_plan_id` when calling `update_event_meal_plan`")  # noqa: E501
        # verify the required parameter 'event_meal_plan_item' is set
        if ('event_meal_plan_item' not in params or
                params['event_meal_plan_item'] is None):
            raise ValueError("Missing the required parameter `event_meal_plan_item` when calling `update_event_meal_plan`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_meal_plan_id' in params:
            path_params['EventMealPlanID'] = params['event_meal_plan_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'event_meal_plan_item' in params:
            body_params = params['event_meal_plan_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EventMealPlan/{EventMealPlanID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventMealPlanItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_event_note(self, event_note_id, event_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EventNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_note(event_note_id, event_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_note_id: Numeric value of the eventnoteID (required)
        :param EventNoteItem event_note_item: EventNote to update (required)
        :return: list[EventNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_event_note_with_http_info(event_note_id, event_note_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_event_note_with_http_info(event_note_id, event_note_item, **kwargs)  # noqa: E501
            return data

    def update_event_note_with_http_info(self, event_note_id, event_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EventNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_note_with_http_info(event_note_id, event_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_note_id: Numeric value of the eventnoteID (required)
        :param EventNoteItem event_note_item: EventNote to update (required)
        :return: list[EventNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_note_id', 'event_note_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_event_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_note_id' is set
        if ('event_note_id' not in params or
                params['event_note_id'] is None):
            raise ValueError("Missing the required parameter `event_note_id` when calling `update_event_note`")  # noqa: E501
        # verify the required parameter 'event_note_item' is set
        if ('event_note_item' not in params or
                params['event_note_item'] is None):
            raise ValueError("Missing the required parameter `event_note_item` when calling `update_event_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_note_id' in params:
            path_params['EventNoteID'] = params['event_note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'event_note_item' in params:
            body_params = params['event_note_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EventNote/{EventNoteID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_event_quote(self, event_quote_id, event_quote_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EventQuote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_quote(event_quote_id, event_quote_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_quote_id: Numeric value of the eventquoteID (required)
        :param EventQuoteItem event_quote_item: EventQuote to update (required)
        :return: list[EventQuoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_event_quote_with_http_info(event_quote_id, event_quote_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_event_quote_with_http_info(event_quote_id, event_quote_item, **kwargs)  # noqa: E501
            return data

    def update_event_quote_with_http_info(self, event_quote_id, event_quote_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EventQuote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_quote_with_http_info(event_quote_id, event_quote_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_quote_id: Numeric value of the eventquoteID (required)
        :param EventQuoteItem event_quote_item: EventQuote to update (required)
        :return: list[EventQuoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_quote_id', 'event_quote_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_event_quote" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_quote_id' is set
        if ('event_quote_id' not in params or
                params['event_quote_id'] is None):
            raise ValueError("Missing the required parameter `event_quote_id` when calling `update_event_quote`")  # noqa: E501
        # verify the required parameter 'event_quote_item' is set
        if ('event_quote_item' not in params or
                params['event_quote_item'] is None):
            raise ValueError("Missing the required parameter `event_quote_item` when calling `update_event_quote`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_quote_id' in params:
            path_params['EventQuoteID'] = params['event_quote_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'event_quote_item' in params:
            body_params = params['event_quote_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EventQuote/{EventQuoteID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventQuoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_event_registration_fee(self, event_registration_fee_id, event_registration_fee_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EventRegistrationFee in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_registration_fee(event_registration_fee_id, event_registration_fee_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_registration_fee_id: Numeric value of the eventregistrationfeeID (required)
        :param EventRegistrationFeeItem event_registration_fee_item: EventRegistrationFee to update (required)
        :return: list[EventRegistrationFeeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_event_registration_fee_with_http_info(event_registration_fee_id, event_registration_fee_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_event_registration_fee_with_http_info(event_registration_fee_id, event_registration_fee_item, **kwargs)  # noqa: E501
            return data

    def update_event_registration_fee_with_http_info(self, event_registration_fee_id, event_registration_fee_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EventRegistrationFee in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_registration_fee_with_http_info(event_registration_fee_id, event_registration_fee_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_registration_fee_id: Numeric value of the eventregistrationfeeID (required)
        :param EventRegistrationFeeItem event_registration_fee_item: EventRegistrationFee to update (required)
        :return: list[EventRegistrationFeeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_registration_fee_id', 'event_registration_fee_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_event_registration_fee" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_registration_fee_id' is set
        if ('event_registration_fee_id' not in params or
                params['event_registration_fee_id'] is None):
            raise ValueError("Missing the required parameter `event_registration_fee_id` when calling `update_event_registration_fee`")  # noqa: E501
        # verify the required parameter 'event_registration_fee_item' is set
        if ('event_registration_fee_item' not in params or
                params['event_registration_fee_item'] is None):
            raise ValueError("Missing the required parameter `event_registration_fee_item` when calling `update_event_registration_fee`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_registration_fee_id' in params:
            path_params['EventRegistrationFeeID'] = params['event_registration_fee_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'event_registration_fee_item' in params:
            body_params = params['event_registration_fee_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EventRegistrationFee/{EventRegistrationFeeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventRegistrationFeeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_event_type(self, event_type_id, event_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EventType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_type(event_type_id, event_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_type_id: Numeric value of the eventtypeID (required)
        :param EventTypeItem event_type_item: EventType to update (required)
        :return: list[EventTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_event_type_with_http_info(event_type_id, event_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_event_type_with_http_info(event_type_id, event_type_item, **kwargs)  # noqa: E501
            return data

    def update_event_type_with_http_info(self, event_type_id, event_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an EventType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_event_type_with_http_info(event_type_id, event_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int event_type_id: Numeric value of the eventtypeID (required)
        :param EventTypeItem event_type_item: EventType to update (required)
        :return: list[EventTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_type_id', 'event_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_event_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_type_id' is set
        if ('event_type_id' not in params or
                params['event_type_id'] is None):
            raise ValueError("Missing the required parameter `event_type_id` when calling `update_event_type`")  # noqa: E501
        # verify the required parameter 'event_type_item' is set
        if ('event_type_item' not in params or
                params['event_type_item'] is None):
            raise ValueError("Missing the required parameter `event_type_item` when calling `update_event_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_type_id' in params:
            path_params['EventTypeID'] = params['event_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'event_type_item' in params:
            body_params = params['event_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/EventType/{EventTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EventTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_extension(self, extension_id, extension_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Extension in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_extension(extension_id, extension_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int extension_id: Numeric value of the extensionID (required)
        :param ExtensionItem extension_item: Extension to update (required)
        :return: list[ExtensionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_extension_with_http_info(extension_id, extension_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_extension_with_http_info(extension_id, extension_item, **kwargs)  # noqa: E501
            return data

    def update_extension_with_http_info(self, extension_id, extension_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Extension in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_extension_with_http_info(extension_id, extension_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int extension_id: Numeric value of the extensionID (required)
        :param ExtensionItem extension_item: Extension to update (required)
        :return: list[ExtensionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['extension_id', 'extension_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_extension" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'extension_id' is set
        if ('extension_id' not in params or
                params['extension_id'] is None):
            raise ValueError("Missing the required parameter `extension_id` when calling `update_extension`")  # noqa: E501
        # verify the required parameter 'extension_item' is set
        if ('extension_item' not in params or
                params['extension_item'] is None):
            raise ValueError("Missing the required parameter `extension_item` when calling `update_extension`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'extension_id' in params:
            path_params['ExtensionID'] = params['extension_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'extension_item' in params:
            body_params = params['extension_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Extension/{ExtensionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ExtensionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_field_default(self, field_default_id, field_default_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FieldDefault in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_field_default(field_default_id, field_default_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int field_default_id: Numeric value of the fielddefaultID (required)
        :param FieldDefaultItem field_default_item: FieldDefault to update (required)
        :return: list[FieldDefaultItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_field_default_with_http_info(field_default_id, field_default_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_field_default_with_http_info(field_default_id, field_default_item, **kwargs)  # noqa: E501
            return data

    def update_field_default_with_http_info(self, field_default_id, field_default_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FieldDefault in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_field_default_with_http_info(field_default_id, field_default_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int field_default_id: Numeric value of the fielddefaultID (required)
        :param FieldDefaultItem field_default_item: FieldDefault to update (required)
        :return: list[FieldDefaultItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['field_default_id', 'field_default_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_field_default" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'field_default_id' is set
        if ('field_default_id' not in params or
                params['field_default_id'] is None):
            raise ValueError("Missing the required parameter `field_default_id` when calling `update_field_default`")  # noqa: E501
        # verify the required parameter 'field_default_item' is set
        if ('field_default_item' not in params or
                params['field_default_item'] is None):
            raise ValueError("Missing the required parameter `field_default_item` when calling `update_field_default`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'field_default_id' in params:
            path_params['FieldDefaultID'] = params['field_default_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'field_default_item' in params:
            body_params = params['field_default_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FieldDefault/{FieldDefaultID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FieldDefaultItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_financial_support(self, financial_support_id, financial_support_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FinancialSupport in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_financial_support(financial_support_id, financial_support_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int financial_support_id: Numeric value of the financialsupportID (required)
        :param FinancialSupportItem financial_support_item: FinancialSupport to update (required)
        :return: list[FinancialSupportItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_financial_support_with_http_info(financial_support_id, financial_support_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_financial_support_with_http_info(financial_support_id, financial_support_item, **kwargs)  # noqa: E501
            return data

    def update_financial_support_with_http_info(self, financial_support_id, financial_support_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FinancialSupport in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_financial_support_with_http_info(financial_support_id, financial_support_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int financial_support_id: Numeric value of the financialsupportID (required)
        :param FinancialSupportItem financial_support_item: FinancialSupport to update (required)
        :return: list[FinancialSupportItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['financial_support_id', 'financial_support_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_financial_support" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'financial_support_id' is set
        if ('financial_support_id' not in params or
                params['financial_support_id'] is None):
            raise ValueError("Missing the required parameter `financial_support_id` when calling `update_financial_support`")  # noqa: E501
        # verify the required parameter 'financial_support_item' is set
        if ('financial_support_item' not in params or
                params['financial_support_item'] is None):
            raise ValueError("Missing the required parameter `financial_support_item` when calling `update_financial_support`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'financial_support_id' in params:
            path_params['FinancialSupportID'] = params['financial_support_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'financial_support_item' in params:
            body_params = params['financial_support_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FinancialSupport/{FinancialSupportID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FinancialSupportItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_function_booking(self, function_booking_id, function_booking_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_booking(function_booking_id, function_booking_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_id: Numeric value of the functionbookingID (required)
        :param FunctionBookingItem function_booking_item: FunctionBooking to update (required)
        :return: list[FunctionBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_function_booking_with_http_info(function_booking_id, function_booking_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_function_booking_with_http_info(function_booking_id, function_booking_item, **kwargs)  # noqa: E501
            return data

    def update_function_booking_with_http_info(self, function_booking_id, function_booking_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_booking_with_http_info(function_booking_id, function_booking_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_id: Numeric value of the functionbookingID (required)
        :param FunctionBookingItem function_booking_item: FunctionBooking to update (required)
        :return: list[FunctionBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_booking_id', 'function_booking_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_function_booking" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'function_booking_id' is set
        if ('function_booking_id' not in params or
                params['function_booking_id'] is None):
            raise ValueError("Missing the required parameter `function_booking_id` when calling `update_function_booking`")  # noqa: E501
        # verify the required parameter 'function_booking_item' is set
        if ('function_booking_item' not in params or
                params['function_booking_item'] is None):
            raise ValueError("Missing the required parameter `function_booking_item` when calling `update_function_booking`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'function_booking_id' in params:
            path_params['FunctionBookingID'] = params['function_booking_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'function_booking_item' in params:
            body_params = params['function_booking_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FunctionBooking/{FunctionBookingID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionBookingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_function_booking_attendee(self, function_booking_attendee_id, function_booking_attendee_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionBookingAttendee in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_booking_attendee(function_booking_attendee_id, function_booking_attendee_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_attendee_id: Numeric value of the functionbookingattendeeID (required)
        :param FunctionBookingAttendeeItem function_booking_attendee_item: FunctionBookingAttendee to update (required)
        :return: list[FunctionBookingAttendeeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_function_booking_attendee_with_http_info(function_booking_attendee_id, function_booking_attendee_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_function_booking_attendee_with_http_info(function_booking_attendee_id, function_booking_attendee_item, **kwargs)  # noqa: E501
            return data

    def update_function_booking_attendee_with_http_info(self, function_booking_attendee_id, function_booking_attendee_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionBookingAttendee in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_booking_attendee_with_http_info(function_booking_attendee_id, function_booking_attendee_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_attendee_id: Numeric value of the functionbookingattendeeID (required)
        :param FunctionBookingAttendeeItem function_booking_attendee_item: FunctionBookingAttendee to update (required)
        :return: list[FunctionBookingAttendeeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_booking_attendee_id', 'function_booking_attendee_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_function_booking_attendee" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'function_booking_attendee_id' is set
        if ('function_booking_attendee_id' not in params or
                params['function_booking_attendee_id'] is None):
            raise ValueError("Missing the required parameter `function_booking_attendee_id` when calling `update_function_booking_attendee`")  # noqa: E501
        # verify the required parameter 'function_booking_attendee_item' is set
        if ('function_booking_attendee_item' not in params or
                params['function_booking_attendee_item'] is None):
            raise ValueError("Missing the required parameter `function_booking_attendee_item` when calling `update_function_booking_attendee`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'function_booking_attendee_id' in params:
            path_params['FunctionBookingAttendeeID'] = params['function_booking_attendee_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'function_booking_attendee_item' in params:
            body_params = params['function_booking_attendee_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FunctionBookingAttendee/{FunctionBookingAttendeeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionBookingAttendeeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_function_booking_catering(self, function_booking_catering_id, function_booking_catering_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionBookingCatering in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_booking_catering(function_booking_catering_id, function_booking_catering_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_catering_id: Numeric value of the functionbookingcateringID (required)
        :param FunctionBookingCateringItem function_booking_catering_item: FunctionBookingCatering to update (required)
        :return: list[FunctionBookingCateringItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_function_booking_catering_with_http_info(function_booking_catering_id, function_booking_catering_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_function_booking_catering_with_http_info(function_booking_catering_id, function_booking_catering_item, **kwargs)  # noqa: E501
            return data

    def update_function_booking_catering_with_http_info(self, function_booking_catering_id, function_booking_catering_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionBookingCatering in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_booking_catering_with_http_info(function_booking_catering_id, function_booking_catering_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_catering_id: Numeric value of the functionbookingcateringID (required)
        :param FunctionBookingCateringItem function_booking_catering_item: FunctionBookingCatering to update (required)
        :return: list[FunctionBookingCateringItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_booking_catering_id', 'function_booking_catering_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_function_booking_catering" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'function_booking_catering_id' is set
        if ('function_booking_catering_id' not in params or
                params['function_booking_catering_id'] is None):
            raise ValueError("Missing the required parameter `function_booking_catering_id` when calling `update_function_booking_catering`")  # noqa: E501
        # verify the required parameter 'function_booking_catering_item' is set
        if ('function_booking_catering_item' not in params or
                params['function_booking_catering_item'] is None):
            raise ValueError("Missing the required parameter `function_booking_catering_item` when calling `update_function_booking_catering`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'function_booking_catering_id' in params:
            path_params['FunctionBookingCateringID'] = params['function_booking_catering_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'function_booking_catering_item' in params:
            body_params = params['function_booking_catering_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FunctionBookingCatering/{FunctionBookingCateringID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionBookingCateringItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_function_booking_catering_item(self, function_booking_catering_item_id, function_booking_catering_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionBookingCateringItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_booking_catering_item(function_booking_catering_item_id, function_booking_catering_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_catering_item_id: Numeric value of the functionbookingcateringitemID (required)
        :param FunctionBookingCateringItemItem function_booking_catering_item_item: FunctionBookingCateringItem to update (required)
        :return: list[FunctionBookingCateringItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_function_booking_catering_item_with_http_info(function_booking_catering_item_id, function_booking_catering_item_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_function_booking_catering_item_with_http_info(function_booking_catering_item_id, function_booking_catering_item_item, **kwargs)  # noqa: E501
            return data

    def update_function_booking_catering_item_with_http_info(self, function_booking_catering_item_id, function_booking_catering_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionBookingCateringItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_booking_catering_item_with_http_info(function_booking_catering_item_id, function_booking_catering_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_catering_item_id: Numeric value of the functionbookingcateringitemID (required)
        :param FunctionBookingCateringItemItem function_booking_catering_item_item: FunctionBookingCateringItem to update (required)
        :return: list[FunctionBookingCateringItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_booking_catering_item_id', 'function_booking_catering_item_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_function_booking_catering_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'function_booking_catering_item_id' is set
        if ('function_booking_catering_item_id' not in params or
                params['function_booking_catering_item_id'] is None):
            raise ValueError("Missing the required parameter `function_booking_catering_item_id` when calling `update_function_booking_catering_item`")  # noqa: E501
        # verify the required parameter 'function_booking_catering_item_item' is set
        if ('function_booking_catering_item_item' not in params or
                params['function_booking_catering_item_item'] is None):
            raise ValueError("Missing the required parameter `function_booking_catering_item_item` when calling `update_function_booking_catering_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'function_booking_catering_item_id' in params:
            path_params['FunctionBookingCateringItemID'] = params['function_booking_catering_item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'function_booking_catering_item_item' in params:
            body_params = params['function_booking_catering_item_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FunctionBookingCateringItem/{FunctionBookingCateringItemID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionBookingCateringItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_function_booking_charge(self, function_booking_charge_id, function_booking_charge_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionBookingCharge in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_booking_charge(function_booking_charge_id, function_booking_charge_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_charge_id: Numeric value of the functionbookingchargeID (required)
        :param FunctionBookingChargeItem function_booking_charge_item: FunctionBookingCharge to update (required)
        :return: list[FunctionBookingChargeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_function_booking_charge_with_http_info(function_booking_charge_id, function_booking_charge_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_function_booking_charge_with_http_info(function_booking_charge_id, function_booking_charge_item, **kwargs)  # noqa: E501
            return data

    def update_function_booking_charge_with_http_info(self, function_booking_charge_id, function_booking_charge_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionBookingCharge in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_booking_charge_with_http_info(function_booking_charge_id, function_booking_charge_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_booking_charge_id: Numeric value of the functionbookingchargeID (required)
        :param FunctionBookingChargeItem function_booking_charge_item: FunctionBookingCharge to update (required)
        :return: list[FunctionBookingChargeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_booking_charge_id', 'function_booking_charge_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_function_booking_charge" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'function_booking_charge_id' is set
        if ('function_booking_charge_id' not in params or
                params['function_booking_charge_id'] is None):
            raise ValueError("Missing the required parameter `function_booking_charge_id` when calling `update_function_booking_charge`")  # noqa: E501
        # verify the required parameter 'function_booking_charge_item' is set
        if ('function_booking_charge_item' not in params or
                params['function_booking_charge_item'] is None):
            raise ValueError("Missing the required parameter `function_booking_charge_item` when calling `update_function_booking_charge`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'function_booking_charge_id' in params:
            path_params['FunctionBookingChargeID'] = params['function_booking_charge_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'function_booking_charge_item' in params:
            body_params = params['function_booking_charge_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FunctionBookingCharge/{FunctionBookingChargeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionBookingChargeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_function_resource(self, function_resource_id, function_resource_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionResource in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_resource(function_resource_id, function_resource_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_resource_id: Numeric value of the functionresourceID (required)
        :param FunctionResourceItem function_resource_item: FunctionResource to update (required)
        :return: list[FunctionResourceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_function_resource_with_http_info(function_resource_id, function_resource_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_function_resource_with_http_info(function_resource_id, function_resource_item, **kwargs)  # noqa: E501
            return data

    def update_function_resource_with_http_info(self, function_resource_id, function_resource_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionResource in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_resource_with_http_info(function_resource_id, function_resource_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_resource_id: Numeric value of the functionresourceID (required)
        :param FunctionResourceItem function_resource_item: FunctionResource to update (required)
        :return: list[FunctionResourceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_resource_id', 'function_resource_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_function_resource" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'function_resource_id' is set
        if ('function_resource_id' not in params or
                params['function_resource_id'] is None):
            raise ValueError("Missing the required parameter `function_resource_id` when calling `update_function_resource`")  # noqa: E501
        # verify the required parameter 'function_resource_item' is set
        if ('function_resource_item' not in params or
                params['function_resource_item'] is None):
            raise ValueError("Missing the required parameter `function_resource_item` when calling `update_function_resource`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'function_resource_id' in params:
            path_params['FunctionResourceID'] = params['function_resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'function_resource_item' in params:
            body_params = params['function_resource_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FunctionResource/{FunctionResourceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionResourceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_function_resource_booking(self, function_resource_booking_id, function_resource_booking_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionResourceBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_resource_booking(function_resource_booking_id, function_resource_booking_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_resource_booking_id: Numeric value of the functionresourcebookingID (required)
        :param FunctionResourceBookingItem function_resource_booking_item: FunctionResourceBooking to update (required)
        :return: list[FunctionResourceBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_function_resource_booking_with_http_info(function_resource_booking_id, function_resource_booking_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_function_resource_booking_with_http_info(function_resource_booking_id, function_resource_booking_item, **kwargs)  # noqa: E501
            return data

    def update_function_resource_booking_with_http_info(self, function_resource_booking_id, function_resource_booking_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionResourceBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_resource_booking_with_http_info(function_resource_booking_id, function_resource_booking_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_resource_booking_id: Numeric value of the functionresourcebookingID (required)
        :param FunctionResourceBookingItem function_resource_booking_item: FunctionResourceBooking to update (required)
        :return: list[FunctionResourceBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_resource_booking_id', 'function_resource_booking_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_function_resource_booking" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'function_resource_booking_id' is set
        if ('function_resource_booking_id' not in params or
                params['function_resource_booking_id'] is None):
            raise ValueError("Missing the required parameter `function_resource_booking_id` when calling `update_function_resource_booking`")  # noqa: E501
        # verify the required parameter 'function_resource_booking_item' is set
        if ('function_resource_booking_item' not in params or
                params['function_resource_booking_item'] is None):
            raise ValueError("Missing the required parameter `function_resource_booking_item` when calling `update_function_resource_booking`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'function_resource_booking_id' in params:
            path_params['FunctionResourceBookingID'] = params['function_resource_booking_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'function_resource_booking_item' in params:
            body_params = params['function_resource_booking_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FunctionResourceBooking/{FunctionResourceBookingID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionResourceBookingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_function_resource_type(self, function_resource_type_id, function_resource_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionResourceType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_resource_type(function_resource_type_id, function_resource_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_resource_type_id: Numeric value of the functionresourcetypeID (required)
        :param FunctionResourceTypeItem function_resource_type_item: FunctionResourceType to update (required)
        :return: list[FunctionResourceTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_function_resource_type_with_http_info(function_resource_type_id, function_resource_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_function_resource_type_with_http_info(function_resource_type_id, function_resource_type_item, **kwargs)  # noqa: E501
            return data

    def update_function_resource_type_with_http_info(self, function_resource_type_id, function_resource_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionResourceType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_resource_type_with_http_info(function_resource_type_id, function_resource_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_resource_type_id: Numeric value of the functionresourcetypeID (required)
        :param FunctionResourceTypeItem function_resource_type_item: FunctionResourceType to update (required)
        :return: list[FunctionResourceTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_resource_type_id', 'function_resource_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_function_resource_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'function_resource_type_id' is set
        if ('function_resource_type_id' not in params or
                params['function_resource_type_id'] is None):
            raise ValueError("Missing the required parameter `function_resource_type_id` when calling `update_function_resource_type`")  # noqa: E501
        # verify the required parameter 'function_resource_type_item' is set
        if ('function_resource_type_item' not in params or
                params['function_resource_type_item'] is None):
            raise ValueError("Missing the required parameter `function_resource_type_item` when calling `update_function_resource_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'function_resource_type_id' in params:
            path_params['FunctionResourceTypeID'] = params['function_resource_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'function_resource_type_item' in params:
            body_params = params['function_resource_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FunctionResourceType/{FunctionResourceTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionResourceTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_function_room(self, function_room_id, function_room_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionRoom in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_room(function_room_id, function_room_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_id: Numeric value of the functionroomID (required)
        :param FunctionRoomItem function_room_item: FunctionRoom to update (required)
        :return: list[FunctionRoomItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_function_room_with_http_info(function_room_id, function_room_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_function_room_with_http_info(function_room_id, function_room_item, **kwargs)  # noqa: E501
            return data

    def update_function_room_with_http_info(self, function_room_id, function_room_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionRoom in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_room_with_http_info(function_room_id, function_room_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_id: Numeric value of the functionroomID (required)
        :param FunctionRoomItem function_room_item: FunctionRoom to update (required)
        :return: list[FunctionRoomItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_room_id', 'function_room_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_function_room" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'function_room_id' is set
        if ('function_room_id' not in params or
                params['function_room_id'] is None):
            raise ValueError("Missing the required parameter `function_room_id` when calling `update_function_room`")  # noqa: E501
        # verify the required parameter 'function_room_item' is set
        if ('function_room_item' not in params or
                params['function_room_item'] is None):
            raise ValueError("Missing the required parameter `function_room_item` when calling `update_function_room`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'function_room_id' in params:
            path_params['FunctionRoomID'] = params['function_room_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'function_room_item' in params:
            body_params = params['function_room_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FunctionRoom/{FunctionRoomID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionRoomItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_function_room_booking(self, function_room_booking_id, function_room_booking_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionRoomBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_room_booking(function_room_booking_id, function_room_booking_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_booking_id: Numeric value of the functionroombookingID (required)
        :param FunctionRoomBookingItem function_room_booking_item: FunctionRoomBooking to update (required)
        :return: list[FunctionRoomBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_function_room_booking_with_http_info(function_room_booking_id, function_room_booking_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_function_room_booking_with_http_info(function_room_booking_id, function_room_booking_item, **kwargs)  # noqa: E501
            return data

    def update_function_room_booking_with_http_info(self, function_room_booking_id, function_room_booking_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionRoomBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_room_booking_with_http_info(function_room_booking_id, function_room_booking_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_booking_id: Numeric value of the functionroombookingID (required)
        :param FunctionRoomBookingItem function_room_booking_item: FunctionRoomBooking to update (required)
        :return: list[FunctionRoomBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_room_booking_id', 'function_room_booking_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_function_room_booking" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'function_room_booking_id' is set
        if ('function_room_booking_id' not in params or
                params['function_room_booking_id'] is None):
            raise ValueError("Missing the required parameter `function_room_booking_id` when calling `update_function_room_booking`")  # noqa: E501
        # verify the required parameter 'function_room_booking_item' is set
        if ('function_room_booking_item' not in params or
                params['function_room_booking_item'] is None):
            raise ValueError("Missing the required parameter `function_room_booking_item` when calling `update_function_room_booking`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'function_room_booking_id' in params:
            path_params['FunctionRoomBookingID'] = params['function_room_booking_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'function_room_booking_item' in params:
            body_params = params['function_room_booking_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FunctionRoomBooking/{FunctionRoomBookingID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionRoomBookingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_function_room_closed(self, function_room_closed_id, function_room_closed_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionRoomClosed in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_room_closed(function_room_closed_id, function_room_closed_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_closed_id: Numeric value of the functionroomclosedID (required)
        :param FunctionRoomClosedItem function_room_closed_item: FunctionRoomClosed to update (required)
        :return: list[FunctionRoomClosedItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_function_room_closed_with_http_info(function_room_closed_id, function_room_closed_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_function_room_closed_with_http_info(function_room_closed_id, function_room_closed_item, **kwargs)  # noqa: E501
            return data

    def update_function_room_closed_with_http_info(self, function_room_closed_id, function_room_closed_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionRoomClosed in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_room_closed_with_http_info(function_room_closed_id, function_room_closed_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_closed_id: Numeric value of the functionroomclosedID (required)
        :param FunctionRoomClosedItem function_room_closed_item: FunctionRoomClosed to update (required)
        :return: list[FunctionRoomClosedItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_room_closed_id', 'function_room_closed_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_function_room_closed" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'function_room_closed_id' is set
        if ('function_room_closed_id' not in params or
                params['function_room_closed_id'] is None):
            raise ValueError("Missing the required parameter `function_room_closed_id` when calling `update_function_room_closed`")  # noqa: E501
        # verify the required parameter 'function_room_closed_item' is set
        if ('function_room_closed_item' not in params or
                params['function_room_closed_item'] is None):
            raise ValueError("Missing the required parameter `function_room_closed_item` when calling `update_function_room_closed`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'function_room_closed_id' in params:
            path_params['FunctionRoomClosedID'] = params['function_room_closed_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'function_room_closed_item' in params:
            body_params = params['function_room_closed_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FunctionRoomClosed/{FunctionRoomClosedID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionRoomClosedItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_function_room_location(self, function_room_location_id, function_room_location_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionRoomLocation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_room_location(function_room_location_id, function_room_location_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_location_id: Numeric value of the functionroomlocationID (required)
        :param FunctionRoomLocationItem function_room_location_item: FunctionRoomLocation to update (required)
        :return: list[FunctionRoomLocationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_function_room_location_with_http_info(function_room_location_id, function_room_location_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_function_room_location_with_http_info(function_room_location_id, function_room_location_item, **kwargs)  # noqa: E501
            return data

    def update_function_room_location_with_http_info(self, function_room_location_id, function_room_location_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionRoomLocation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_room_location_with_http_info(function_room_location_id, function_room_location_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_location_id: Numeric value of the functionroomlocationID (required)
        :param FunctionRoomLocationItem function_room_location_item: FunctionRoomLocation to update (required)
        :return: list[FunctionRoomLocationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_room_location_id', 'function_room_location_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_function_room_location" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'function_room_location_id' is set
        if ('function_room_location_id' not in params or
                params['function_room_location_id'] is None):
            raise ValueError("Missing the required parameter `function_room_location_id` when calling `update_function_room_location`")  # noqa: E501
        # verify the required parameter 'function_room_location_item' is set
        if ('function_room_location_item' not in params or
                params['function_room_location_item'] is None):
            raise ValueError("Missing the required parameter `function_room_location_item` when calling `update_function_room_location`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'function_room_location_id' in params:
            path_params['FunctionRoomLocationID'] = params['function_room_location_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'function_room_location_item' in params:
            body_params = params['function_room_location_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FunctionRoomLocation/{FunctionRoomLocationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionRoomLocationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_function_room_rate(self, function_room_rate_id, function_room_rate_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionRoomRate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_room_rate(function_room_rate_id, function_room_rate_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_rate_id: Numeric value of the functionroomrateID (required)
        :param FunctionRoomRateItem function_room_rate_item: FunctionRoomRate to update (required)
        :return: list[FunctionRoomRateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_function_room_rate_with_http_info(function_room_rate_id, function_room_rate_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_function_room_rate_with_http_info(function_room_rate_id, function_room_rate_item, **kwargs)  # noqa: E501
            return data

    def update_function_room_rate_with_http_info(self, function_room_rate_id, function_room_rate_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionRoomRate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_room_rate_with_http_info(function_room_rate_id, function_room_rate_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_rate_id: Numeric value of the functionroomrateID (required)
        :param FunctionRoomRateItem function_room_rate_item: FunctionRoomRate to update (required)
        :return: list[FunctionRoomRateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_room_rate_id', 'function_room_rate_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_function_room_rate" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'function_room_rate_id' is set
        if ('function_room_rate_id' not in params or
                params['function_room_rate_id'] is None):
            raise ValueError("Missing the required parameter `function_room_rate_id` when calling `update_function_room_rate`")  # noqa: E501
        # verify the required parameter 'function_room_rate_item' is set
        if ('function_room_rate_item' not in params or
                params['function_room_rate_item'] is None):
            raise ValueError("Missing the required parameter `function_room_rate_item` when calling `update_function_room_rate`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'function_room_rate_id' in params:
            path_params['FunctionRoomRateID'] = params['function_room_rate_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'function_room_rate_item' in params:
            body_params = params['function_room_rate_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FunctionRoomRate/{FunctionRoomRateID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionRoomRateItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_function_room_setup(self, function_room_setup_id, function_room_setup_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionRoomSetup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_room_setup(function_room_setup_id, function_room_setup_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_setup_id: Numeric value of the functionroomsetupID (required)
        :param FunctionRoomSetupItem function_room_setup_item: FunctionRoomSetup to update (required)
        :return: list[FunctionRoomSetupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_function_room_setup_with_http_info(function_room_setup_id, function_room_setup_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_function_room_setup_with_http_info(function_room_setup_id, function_room_setup_item, **kwargs)  # noqa: E501
            return data

    def update_function_room_setup_with_http_info(self, function_room_setup_id, function_room_setup_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionRoomSetup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_room_setup_with_http_info(function_room_setup_id, function_room_setup_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_setup_id: Numeric value of the functionroomsetupID (required)
        :param FunctionRoomSetupItem function_room_setup_item: FunctionRoomSetup to update (required)
        :return: list[FunctionRoomSetupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_room_setup_id', 'function_room_setup_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_function_room_setup" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'function_room_setup_id' is set
        if ('function_room_setup_id' not in params or
                params['function_room_setup_id'] is None):
            raise ValueError("Missing the required parameter `function_room_setup_id` when calling `update_function_room_setup`")  # noqa: E501
        # verify the required parameter 'function_room_setup_item' is set
        if ('function_room_setup_item' not in params or
                params['function_room_setup_item'] is None):
            raise ValueError("Missing the required parameter `function_room_setup_item` when calling `update_function_room_setup`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'function_room_setup_id' in params:
            path_params['FunctionRoomSetupID'] = params['function_room_setup_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'function_room_setup_item' in params:
            body_params = params['function_room_setup_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FunctionRoomSetup/{FunctionRoomSetupID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionRoomSetupItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_function_room_type(self, function_room_type_id, function_room_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionRoomType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_room_type(function_room_type_id, function_room_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_type_id: Numeric value of the functionroomtypeID (required)
        :param FunctionRoomTypeItem function_room_type_item: FunctionRoomType to update (required)
        :return: list[FunctionRoomTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_function_room_type_with_http_info(function_room_type_id, function_room_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_function_room_type_with_http_info(function_room_type_id, function_room_type_item, **kwargs)  # noqa: E501
            return data

    def update_function_room_type_with_http_info(self, function_room_type_id, function_room_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionRoomType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_room_type_with_http_info(function_room_type_id, function_room_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_room_type_id: Numeric value of the functionroomtypeID (required)
        :param FunctionRoomTypeItem function_room_type_item: FunctionRoomType to update (required)
        :return: list[FunctionRoomTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_room_type_id', 'function_room_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_function_room_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'function_room_type_id' is set
        if ('function_room_type_id' not in params or
                params['function_room_type_id'] is None):
            raise ValueError("Missing the required parameter `function_room_type_id` when calling `update_function_room_type`")  # noqa: E501
        # verify the required parameter 'function_room_type_item' is set
        if ('function_room_type_item' not in params or
                params['function_room_type_item'] is None):
            raise ValueError("Missing the required parameter `function_room_type_item` when calling `update_function_room_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'function_room_type_id' in params:
            path_params['FunctionRoomTypeID'] = params['function_room_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'function_room_type_item' in params:
            body_params = params['function_room_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FunctionRoomType/{FunctionRoomTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionRoomTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_function_type(self, function_type_id, function_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_type(function_type_id, function_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_type_id: Numeric value of the functiontypeID (required)
        :param FunctionTypeItem function_type_item: FunctionType to update (required)
        :return: list[FunctionTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_function_type_with_http_info(function_type_id, function_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_function_type_with_http_info(function_type_id, function_type_item, **kwargs)  # noqa: E501
            return data

    def update_function_type_with_http_info(self, function_type_id, function_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an FunctionType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_function_type_with_http_info(function_type_id, function_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int function_type_id: Numeric value of the functiontypeID (required)
        :param FunctionTypeItem function_type_item: FunctionType to update (required)
        :return: list[FunctionTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['function_type_id', 'function_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_function_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'function_type_id' is set
        if ('function_type_id' not in params or
                params['function_type_id'] is None):
            raise ValueError("Missing the required parameter `function_type_id` when calling `update_function_type`")  # noqa: E501
        # verify the required parameter 'function_type_item' is set
        if ('function_type_item' not in params or
                params['function_type_item'] is None):
            raise ValueError("Missing the required parameter `function_type_item` when calling `update_function_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'function_type_id' in params:
            path_params['FunctionTypeID'] = params['function_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'function_type_item' in params:
            body_params = params['function_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/FunctionType/{FunctionTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FunctionTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_generic_table_data(self, generic_table_data_id, generic_table_data_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GenericTableData in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_generic_table_data(generic_table_data_id, generic_table_data_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int generic_table_data_id: Numeric value of the generictabledataID (required)
        :param GenericTableDataItem generic_table_data_item: GenericTableData to update (required)
        :return: list[GenericTableDataItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_generic_table_data_with_http_info(generic_table_data_id, generic_table_data_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_generic_table_data_with_http_info(generic_table_data_id, generic_table_data_item, **kwargs)  # noqa: E501
            return data

    def update_generic_table_data_with_http_info(self, generic_table_data_id, generic_table_data_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GenericTableData in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_generic_table_data_with_http_info(generic_table_data_id, generic_table_data_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int generic_table_data_id: Numeric value of the generictabledataID (required)
        :param GenericTableDataItem generic_table_data_item: GenericTableData to update (required)
        :return: list[GenericTableDataItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['generic_table_data_id', 'generic_table_data_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_generic_table_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'generic_table_data_id' is set
        if ('generic_table_data_id' not in params or
                params['generic_table_data_id'] is None):
            raise ValueError("Missing the required parameter `generic_table_data_id` when calling `update_generic_table_data`")  # noqa: E501
        # verify the required parameter 'generic_table_data_item' is set
        if ('generic_table_data_item' not in params or
                params['generic_table_data_item'] is None):
            raise ValueError("Missing the required parameter `generic_table_data_item` when calling `update_generic_table_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'generic_table_data_id' in params:
            path_params['GenericTableDataID'] = params['generic_table_data_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'generic_table_data_item' in params:
            body_params = params['generic_table_data_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/GenericTableData/{GenericTableDataID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GenericTableDataItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_generic_table_data_field(self, generic_table_data_field_id, generic_table_data_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GenericTableDataField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_generic_table_data_field(generic_table_data_field_id, generic_table_data_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int generic_table_data_field_id: Numeric value of the generictabledatafieldID (required)
        :param GenericTableDataFieldItem generic_table_data_field_item: GenericTableDataField to update (required)
        :return: list[GenericTableDataFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_generic_table_data_field_with_http_info(generic_table_data_field_id, generic_table_data_field_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_generic_table_data_field_with_http_info(generic_table_data_field_id, generic_table_data_field_item, **kwargs)  # noqa: E501
            return data

    def update_generic_table_data_field_with_http_info(self, generic_table_data_field_id, generic_table_data_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GenericTableDataField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_generic_table_data_field_with_http_info(generic_table_data_field_id, generic_table_data_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int generic_table_data_field_id: Numeric value of the generictabledatafieldID (required)
        :param GenericTableDataFieldItem generic_table_data_field_item: GenericTableDataField to update (required)
        :return: list[GenericTableDataFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['generic_table_data_field_id', 'generic_table_data_field_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_generic_table_data_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'generic_table_data_field_id' is set
        if ('generic_table_data_field_id' not in params or
                params['generic_table_data_field_id'] is None):
            raise ValueError("Missing the required parameter `generic_table_data_field_id` when calling `update_generic_table_data_field`")  # noqa: E501
        # verify the required parameter 'generic_table_data_field_item' is set
        if ('generic_table_data_field_item' not in params or
                params['generic_table_data_field_item'] is None):
            raise ValueError("Missing the required parameter `generic_table_data_field_item` when calling `update_generic_table_data_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'generic_table_data_field_id' in params:
            path_params['GenericTableDataFieldID'] = params['generic_table_data_field_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'generic_table_data_field_item' in params:
            body_params = params['generic_table_data_field_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/GenericTableDataField/{GenericTableDataFieldID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GenericTableDataFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_generic_table_definition(self, generic_table_definition_id, generic_table_definition_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GenericTableDefinition in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_generic_table_definition(generic_table_definition_id, generic_table_definition_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int generic_table_definition_id: Numeric value of the generictabledefinitionID (required)
        :param GenericTableDefinitionItem generic_table_definition_item: GenericTableDefinition to update (required)
        :return: list[GenericTableDefinitionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_generic_table_definition_with_http_info(generic_table_definition_id, generic_table_definition_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_generic_table_definition_with_http_info(generic_table_definition_id, generic_table_definition_item, **kwargs)  # noqa: E501
            return data

    def update_generic_table_definition_with_http_info(self, generic_table_definition_id, generic_table_definition_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GenericTableDefinition in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_generic_table_definition_with_http_info(generic_table_definition_id, generic_table_definition_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int generic_table_definition_id: Numeric value of the generictabledefinitionID (required)
        :param GenericTableDefinitionItem generic_table_definition_item: GenericTableDefinition to update (required)
        :return: list[GenericTableDefinitionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['generic_table_definition_id', 'generic_table_definition_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_generic_table_definition" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'generic_table_definition_id' is set
        if ('generic_table_definition_id' not in params or
                params['generic_table_definition_id'] is None):
            raise ValueError("Missing the required parameter `generic_table_definition_id` when calling `update_generic_table_definition`")  # noqa: E501
        # verify the required parameter 'generic_table_definition_item' is set
        if ('generic_table_definition_item' not in params or
                params['generic_table_definition_item'] is None):
            raise ValueError("Missing the required parameter `generic_table_definition_item` when calling `update_generic_table_definition`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'generic_table_definition_id' in params:
            path_params['GenericTableDefinitionID'] = params['generic_table_definition_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'generic_table_definition_item' in params:
            body_params = params['generic_table_definition_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/GenericTableDefinition/{GenericTableDefinitionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GenericTableDefinitionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_generic_table_definition_field(self, generic_table_definition_field_id, generic_table_definition_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GenericTableDefinitionField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_generic_table_definition_field(generic_table_definition_field_id, generic_table_definition_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int generic_table_definition_field_id: Numeric value of the generictabledefinitionfieldID (required)
        :param GenericTableDefinitionFieldItem generic_table_definition_field_item: GenericTableDefinitionField to update (required)
        :return: list[GenericTableDefinitionFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_generic_table_definition_field_with_http_info(generic_table_definition_field_id, generic_table_definition_field_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_generic_table_definition_field_with_http_info(generic_table_definition_field_id, generic_table_definition_field_item, **kwargs)  # noqa: E501
            return data

    def update_generic_table_definition_field_with_http_info(self, generic_table_definition_field_id, generic_table_definition_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GenericTableDefinitionField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_generic_table_definition_field_with_http_info(generic_table_definition_field_id, generic_table_definition_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int generic_table_definition_field_id: Numeric value of the generictabledefinitionfieldID (required)
        :param GenericTableDefinitionFieldItem generic_table_definition_field_item: GenericTableDefinitionField to update (required)
        :return: list[GenericTableDefinitionFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['generic_table_definition_field_id', 'generic_table_definition_field_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_generic_table_definition_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'generic_table_definition_field_id' is set
        if ('generic_table_definition_field_id' not in params or
                params['generic_table_definition_field_id'] is None):
            raise ValueError("Missing the required parameter `generic_table_definition_field_id` when calling `update_generic_table_definition_field`")  # noqa: E501
        # verify the required parameter 'generic_table_definition_field_item' is set
        if ('generic_table_definition_field_item' not in params or
                params['generic_table_definition_field_item'] is None):
            raise ValueError("Missing the required parameter `generic_table_definition_field_item` when calling `update_generic_table_definition_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'generic_table_definition_field_id' in params:
            path_params['GenericTableDefinitionFieldID'] = params['generic_table_definition_field_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'generic_table_definition_field_item' in params:
            body_params = params['generic_table_definition_field_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/GenericTableDefinitionField/{GenericTableDefinitionFieldID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GenericTableDefinitionFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_gl_posting(self, gl_posting_id, gl_posting_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GLPosting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_gl_posting(gl_posting_id, gl_posting_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int gl_posting_id: Numeric value of the glpostingID (required)
        :param GLPostingItem gl_posting_item: GLPosting to update (required)
        :return: list[GLPostingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_gl_posting_with_http_info(gl_posting_id, gl_posting_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_gl_posting_with_http_info(gl_posting_id, gl_posting_item, **kwargs)  # noqa: E501
            return data

    def update_gl_posting_with_http_info(self, gl_posting_id, gl_posting_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GLPosting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_gl_posting_with_http_info(gl_posting_id, gl_posting_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int gl_posting_id: Numeric value of the glpostingID (required)
        :param GLPostingItem gl_posting_item: GLPosting to update (required)
        :return: list[GLPostingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gl_posting_id', 'gl_posting_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_gl_posting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gl_posting_id' is set
        if ('gl_posting_id' not in params or
                params['gl_posting_id'] is None):
            raise ValueError("Missing the required parameter `gl_posting_id` when calling `update_gl_posting`")  # noqa: E501
        # verify the required parameter 'gl_posting_item' is set
        if ('gl_posting_item' not in params or
                params['gl_posting_item'] is None):
            raise ValueError("Missing the required parameter `gl_posting_item` when calling `update_gl_posting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'gl_posting_id' in params:
            path_params['GLPostingID'] = params['gl_posting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'gl_posting_item' in params:
            body_params = params['gl_posting_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/GLPosting/{GLPostingID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GLPostingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_group(self, group_id, group_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Group in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_group(group_id, group_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_id: Numeric value of the groupID (required)
        :param GroupItem group_item: Group to update (required)
        :return: list[GroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_group_with_http_info(group_id, group_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_group_with_http_info(group_id, group_item, **kwargs)  # noqa: E501
            return data

    def update_group_with_http_info(self, group_id, group_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Group in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_group_with_http_info(group_id, group_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_id: Numeric value of the groupID (required)
        :param GroupItem group_item: Group to update (required)
        :return: list[GroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'group_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `update_group`")  # noqa: E501
        # verify the required parameter 'group_item' is set
        if ('group_item' not in params or
                params['group_item'] is None):
            raise ValueError("Missing the required parameter `group_item` when calling `update_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['GroupID'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'group_item' in params:
            body_params = params['group_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Group/{GroupID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GroupItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_group_contact_entry(self, group_contact_entry_id, group_contact_entry_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GroupContactEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_group_contact_entry(group_contact_entry_id, group_contact_entry_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_contact_entry_id: Numeric value of the groupcontactentryID (required)
        :param GroupContactEntryItem group_contact_entry_item: GroupContactEntry to update (required)
        :return: list[GroupContactEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_group_contact_entry_with_http_info(group_contact_entry_id, group_contact_entry_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_group_contact_entry_with_http_info(group_contact_entry_id, group_contact_entry_item, **kwargs)  # noqa: E501
            return data

    def update_group_contact_entry_with_http_info(self, group_contact_entry_id, group_contact_entry_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GroupContactEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_group_contact_entry_with_http_info(group_contact_entry_id, group_contact_entry_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_contact_entry_id: Numeric value of the groupcontactentryID (required)
        :param GroupContactEntryItem group_contact_entry_item: GroupContactEntry to update (required)
        :return: list[GroupContactEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_contact_entry_id', 'group_contact_entry_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_group_contact_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_contact_entry_id' is set
        if ('group_contact_entry_id' not in params or
                params['group_contact_entry_id'] is None):
            raise ValueError("Missing the required parameter `group_contact_entry_id` when calling `update_group_contact_entry`")  # noqa: E501
        # verify the required parameter 'group_contact_entry_item' is set
        if ('group_contact_entry_item' not in params or
                params['group_contact_entry_item'] is None):
            raise ValueError("Missing the required parameter `group_contact_entry_item` when calling `update_group_contact_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_contact_entry_id' in params:
            path_params['GroupContactEntryID'] = params['group_contact_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'group_contact_entry_item' in params:
            body_params = params['group_contact_entry_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/GroupContactEntry/{GroupContactEntryID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GroupContactEntryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_group_custom_field(self, group_custom_field_id, group_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GroupCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_group_custom_field(group_custom_field_id, group_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_custom_field_id: Numeric value of the groupcustomfieldID (required)
        :param GroupCustomFieldItem group_custom_field_item: GroupCustomField to update (required)
        :return: list[GroupCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_group_custom_field_with_http_info(group_custom_field_id, group_custom_field_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_group_custom_field_with_http_info(group_custom_field_id, group_custom_field_item, **kwargs)  # noqa: E501
            return data

    def update_group_custom_field_with_http_info(self, group_custom_field_id, group_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GroupCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_group_custom_field_with_http_info(group_custom_field_id, group_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_custom_field_id: Numeric value of the groupcustomfieldID (required)
        :param GroupCustomFieldItem group_custom_field_item: GroupCustomField to update (required)
        :return: list[GroupCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_custom_field_id', 'group_custom_field_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_group_custom_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_custom_field_id' is set
        if ('group_custom_field_id' not in params or
                params['group_custom_field_id'] is None):
            raise ValueError("Missing the required parameter `group_custom_field_id` when calling `update_group_custom_field`")  # noqa: E501
        # verify the required parameter 'group_custom_field_item' is set
        if ('group_custom_field_item' not in params or
                params['group_custom_field_item'] is None):
            raise ValueError("Missing the required parameter `group_custom_field_item` when calling `update_group_custom_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_custom_field_id' in params:
            path_params['GroupCustomFieldID'] = params['group_custom_field_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'group_custom_field_item' in params:
            body_params = params['group_custom_field_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/GroupCustomField/{GroupCustomFieldID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GroupCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_group_meal_plan(self, group_meal_plan_id, group_meal_plan_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GroupMealPlan in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_group_meal_plan(group_meal_plan_id, group_meal_plan_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_meal_plan_id: Numeric value of the groupmealplanID (required)
        :param GroupMealPlanItem group_meal_plan_item: GroupMealPlan to update (required)
        :return: list[GroupMealPlanItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_group_meal_plan_with_http_info(group_meal_plan_id, group_meal_plan_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_group_meal_plan_with_http_info(group_meal_plan_id, group_meal_plan_item, **kwargs)  # noqa: E501
            return data

    def update_group_meal_plan_with_http_info(self, group_meal_plan_id, group_meal_plan_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GroupMealPlan in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_group_meal_plan_with_http_info(group_meal_plan_id, group_meal_plan_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_meal_plan_id: Numeric value of the groupmealplanID (required)
        :param GroupMealPlanItem group_meal_plan_item: GroupMealPlan to update (required)
        :return: list[GroupMealPlanItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_meal_plan_id', 'group_meal_plan_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_group_meal_plan" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_meal_plan_id' is set
        if ('group_meal_plan_id' not in params or
                params['group_meal_plan_id'] is None):
            raise ValueError("Missing the required parameter `group_meal_plan_id` when calling `update_group_meal_plan`")  # noqa: E501
        # verify the required parameter 'group_meal_plan_item' is set
        if ('group_meal_plan_item' not in params or
                params['group_meal_plan_item'] is None):
            raise ValueError("Missing the required parameter `group_meal_plan_item` when calling `update_group_meal_plan`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_meal_plan_id' in params:
            path_params['GroupMealPlanID'] = params['group_meal_plan_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'group_meal_plan_item' in params:
            body_params = params['group_meal_plan_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/GroupMealPlan/{GroupMealPlanID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GroupMealPlanItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_group_room_space(self, group_room_space_id, group_room_space_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GroupRoomSpace in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_group_room_space(group_room_space_id, group_room_space_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_room_space_id: Numeric value of the grouproomspaceID (required)
        :param GroupRoomSpaceItem group_room_space_item: GroupRoomSpace to update (required)
        :return: list[GroupRoomSpaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_group_room_space_with_http_info(group_room_space_id, group_room_space_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_group_room_space_with_http_info(group_room_space_id, group_room_space_item, **kwargs)  # noqa: E501
            return data

    def update_group_room_space_with_http_info(self, group_room_space_id, group_room_space_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GroupRoomSpace in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_group_room_space_with_http_info(group_room_space_id, group_room_space_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_room_space_id: Numeric value of the grouproomspaceID (required)
        :param GroupRoomSpaceItem group_room_space_item: GroupRoomSpace to update (required)
        :return: list[GroupRoomSpaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_room_space_id', 'group_room_space_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_group_room_space" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_room_space_id' is set
        if ('group_room_space_id' not in params or
                params['group_room_space_id'] is None):
            raise ValueError("Missing the required parameter `group_room_space_id` when calling `update_group_room_space`")  # noqa: E501
        # verify the required parameter 'group_room_space_item' is set
        if ('group_room_space_item' not in params or
                params['group_room_space_item'] is None):
            raise ValueError("Missing the required parameter `group_room_space_item` when calling `update_group_room_space`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_room_space_id' in params:
            path_params['GroupRoomSpaceID'] = params['group_room_space_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'group_room_space_item' in params:
            body_params = params['group_room_space_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/GroupRoomSpace/{GroupRoomSpaceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GroupRoomSpaceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_group_room_type_and_rates(self, group_room_type_and_rates_id, group_room_type_and_rates_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GroupRoomTypeAndRates in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_group_room_type_and_rates(group_room_type_and_rates_id, group_room_type_and_rates_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_room_type_and_rates_id: Numeric value of the grouproomtypeandratesID (required)
        :param GroupRoomTypeAndRatesItem group_room_type_and_rates_item: GroupRoomTypeAndRates to update (required)
        :return: list[GroupRoomTypeAndRatesItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_group_room_type_and_rates_with_http_info(group_room_type_and_rates_id, group_room_type_and_rates_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_group_room_type_and_rates_with_http_info(group_room_type_and_rates_id, group_room_type_and_rates_item, **kwargs)  # noqa: E501
            return data

    def update_group_room_type_and_rates_with_http_info(self, group_room_type_and_rates_id, group_room_type_and_rates_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an GroupRoomTypeAndRates in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_group_room_type_and_rates_with_http_info(group_room_type_and_rates_id, group_room_type_and_rates_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int group_room_type_and_rates_id: Numeric value of the grouproomtypeandratesID (required)
        :param GroupRoomTypeAndRatesItem group_room_type_and_rates_item: GroupRoomTypeAndRates to update (required)
        :return: list[GroupRoomTypeAndRatesItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_room_type_and_rates_id', 'group_room_type_and_rates_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_group_room_type_and_rates" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_room_type_and_rates_id' is set
        if ('group_room_type_and_rates_id' not in params or
                params['group_room_type_and_rates_id'] is None):
            raise ValueError("Missing the required parameter `group_room_type_and_rates_id` when calling `update_group_room_type_and_rates`")  # noqa: E501
        # verify the required parameter 'group_room_type_and_rates_item' is set
        if ('group_room_type_and_rates_item' not in params or
                params['group_room_type_and_rates_item'] is None):
            raise ValueError("Missing the required parameter `group_room_type_and_rates_item` when calling `update_group_room_type_and_rates`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_room_type_and_rates_id' in params:
            path_params['GroupRoomTypeAndRatesID'] = params['group_room_type_and_rates_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'group_room_type_and_rates_item' in params:
            body_params = params['group_room_type_and_rates_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/GroupRoomTypeAndRates/{GroupRoomTypeAndRatesID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GroupRoomTypeAndRatesItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_housekeeping(self, housekeeping_id, housekeeping_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Housekeeping in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_housekeeping(housekeeping_id, housekeeping_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int housekeeping_id: Numeric value of the housekeepingID (required)
        :param HousekeepingItem housekeeping_item: Housekeeping to update (required)
        :return: list[HousekeepingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_housekeeping_with_http_info(housekeeping_id, housekeeping_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_housekeeping_with_http_info(housekeeping_id, housekeeping_item, **kwargs)  # noqa: E501
            return data

    def update_housekeeping_with_http_info(self, housekeeping_id, housekeeping_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Housekeeping in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_housekeeping_with_http_info(housekeeping_id, housekeeping_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int housekeeping_id: Numeric value of the housekeepingID (required)
        :param HousekeepingItem housekeeping_item: Housekeeping to update (required)
        :return: list[HousekeepingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['housekeeping_id', 'housekeeping_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_housekeeping" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'housekeeping_id' is set
        if ('housekeeping_id' not in params or
                params['housekeeping_id'] is None):
            raise ValueError("Missing the required parameter `housekeeping_id` when calling `update_housekeeping`")  # noqa: E501
        # verify the required parameter 'housekeeping_item' is set
        if ('housekeeping_item' not in params or
                params['housekeeping_item'] is None):
            raise ValueError("Missing the required parameter `housekeeping_item` when calling `update_housekeeping`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'housekeeping_id' in params:
            path_params['HousekeepingID'] = params['housekeeping_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'housekeeping_item' in params:
            body_params = params['housekeeping_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Housekeeping/{HousekeepingID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[HousekeepingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_housekeeping_schedule(self, housekeeping_schedule_id, housekeeping_schedule_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an HousekeepingSchedule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_housekeeping_schedule(housekeeping_schedule_id, housekeeping_schedule_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int housekeeping_schedule_id: Numeric value of the housekeepingscheduleID (required)
        :param HousekeepingScheduleItem housekeeping_schedule_item: HousekeepingSchedule to update (required)
        :return: list[HousekeepingScheduleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_housekeeping_schedule_with_http_info(housekeeping_schedule_id, housekeeping_schedule_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_housekeeping_schedule_with_http_info(housekeeping_schedule_id, housekeeping_schedule_item, **kwargs)  # noqa: E501
            return data

    def update_housekeeping_schedule_with_http_info(self, housekeeping_schedule_id, housekeeping_schedule_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an HousekeepingSchedule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_housekeeping_schedule_with_http_info(housekeeping_schedule_id, housekeeping_schedule_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int housekeeping_schedule_id: Numeric value of the housekeepingscheduleID (required)
        :param HousekeepingScheduleItem housekeeping_schedule_item: HousekeepingSchedule to update (required)
        :return: list[HousekeepingScheduleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['housekeeping_schedule_id', 'housekeeping_schedule_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_housekeeping_schedule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'housekeeping_schedule_id' is set
        if ('housekeeping_schedule_id' not in params or
                params['housekeeping_schedule_id'] is None):
            raise ValueError("Missing the required parameter `housekeeping_schedule_id` when calling `update_housekeeping_schedule`")  # noqa: E501
        # verify the required parameter 'housekeeping_schedule_item' is set
        if ('housekeeping_schedule_item' not in params or
                params['housekeeping_schedule_item'] is None):
            raise ValueError("Missing the required parameter `housekeeping_schedule_item` when calling `update_housekeeping_schedule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'housekeeping_schedule_id' in params:
            path_params['HousekeepingScheduleID'] = params['housekeeping_schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'housekeeping_schedule_item' in params:
            body_params = params['housekeeping_schedule_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/HousekeepingSchedule/{HousekeepingScheduleID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[HousekeepingScheduleItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_housekeeping_schedule_skip(self, housekeeping_schedule_skip_id, housekeeping_schedule_skip_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an HousekeepingScheduleSkip in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_housekeeping_schedule_skip(housekeeping_schedule_skip_id, housekeeping_schedule_skip_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int housekeeping_schedule_skip_id: Numeric value of the housekeepingscheduleskipID (required)
        :param HousekeepingScheduleSkipItem housekeeping_schedule_skip_item: HousekeepingScheduleSkip to update (required)
        :return: list[HousekeepingScheduleSkipItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_housekeeping_schedule_skip_with_http_info(housekeeping_schedule_skip_id, housekeeping_schedule_skip_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_housekeeping_schedule_skip_with_http_info(housekeeping_schedule_skip_id, housekeeping_schedule_skip_item, **kwargs)  # noqa: E501
            return data

    def update_housekeeping_schedule_skip_with_http_info(self, housekeeping_schedule_skip_id, housekeeping_schedule_skip_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an HousekeepingScheduleSkip in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_housekeeping_schedule_skip_with_http_info(housekeeping_schedule_skip_id, housekeeping_schedule_skip_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int housekeeping_schedule_skip_id: Numeric value of the housekeepingscheduleskipID (required)
        :param HousekeepingScheduleSkipItem housekeeping_schedule_skip_item: HousekeepingScheduleSkip to update (required)
        :return: list[HousekeepingScheduleSkipItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['housekeeping_schedule_skip_id', 'housekeeping_schedule_skip_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_housekeeping_schedule_skip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'housekeeping_schedule_skip_id' is set
        if ('housekeeping_schedule_skip_id' not in params or
                params['housekeeping_schedule_skip_id'] is None):
            raise ValueError("Missing the required parameter `housekeeping_schedule_skip_id` when calling `update_housekeeping_schedule_skip`")  # noqa: E501
        # verify the required parameter 'housekeeping_schedule_skip_item' is set
        if ('housekeeping_schedule_skip_item' not in params or
                params['housekeeping_schedule_skip_item'] is None):
            raise ValueError("Missing the required parameter `housekeeping_schedule_skip_item` when calling `update_housekeeping_schedule_skip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'housekeeping_schedule_skip_id' in params:
            path_params['HousekeepingScheduleSkipID'] = params['housekeeping_schedule_skip_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'housekeeping_schedule_skip_item' in params:
            body_params = params['housekeeping_schedule_skip_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/HousekeepingScheduleSkip/{HousekeepingScheduleSkipID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[HousekeepingScheduleSkipItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident(self, incident_id, incident_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Incident in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident(incident_id, incident_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_id: Numeric value of the incidentID (required)
        :param IncidentItem incident_item: Incident to update (required)
        :return: list[IncidentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_with_http_info(incident_id, incident_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_with_http_info(incident_id, incident_item, **kwargs)  # noqa: E501
            return data

    def update_incident_with_http_info(self, incident_id, incident_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Incident in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_with_http_info(incident_id, incident_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_id: Numeric value of the incidentID (required)
        :param IncidentItem incident_item: Incident to update (required)
        :return: list[IncidentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_id', 'incident_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_id' is set
        if ('incident_id' not in params or
                params['incident_id'] is None):
            raise ValueError("Missing the required parameter `incident_id` when calling `update_incident`")  # noqa: E501
        # verify the required parameter 'incident_item' is set
        if ('incident_item' not in params or
                params['incident_item'] is None):
            raise ValueError("Missing the required parameter `incident_item` when calling `update_incident`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_id' in params:
            path_params['IncidentID'] = params['incident_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_item' in params:
            body_params = params['incident_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Incident/{IncidentID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_action(self, incident_action_id, incident_action_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_action(incident_action_id, incident_action_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_action_id: Numeric value of the incidentactionID (required)
        :param IncidentActionItem incident_action_item: IncidentAction to update (required)
        :return: list[IncidentActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_action_with_http_info(incident_action_id, incident_action_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_action_with_http_info(incident_action_id, incident_action_item, **kwargs)  # noqa: E501
            return data

    def update_incident_action_with_http_info(self, incident_action_id, incident_action_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_action_with_http_info(incident_action_id, incident_action_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_action_id: Numeric value of the incidentactionID (required)
        :param IncidentActionItem incident_action_item: IncidentAction to update (required)
        :return: list[IncidentActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_action_id', 'incident_action_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_action_id' is set
        if ('incident_action_id' not in params or
                params['incident_action_id'] is None):
            raise ValueError("Missing the required parameter `incident_action_id` when calling `update_incident_action`")  # noqa: E501
        # verify the required parameter 'incident_action_item' is set
        if ('incident_action_item' not in params or
                params['incident_action_item'] is None):
            raise ValueError("Missing the required parameter `incident_action_item` when calling `update_incident_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_action_id' in params:
            path_params['IncidentActionID'] = params['incident_action_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_action_item' in params:
            body_params = params['incident_action_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentAction/{IncidentActionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentActionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_action_entry(self, incident_action_entry_id, incident_action_entry_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentActionEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_action_entry(incident_action_entry_id, incident_action_entry_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_action_entry_id: Numeric value of the incidentactionentryID (required)
        :param IncidentActionEntryItem incident_action_entry_item: IncidentActionEntry to update (required)
        :return: list[IncidentActionEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_action_entry_with_http_info(incident_action_entry_id, incident_action_entry_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_action_entry_with_http_info(incident_action_entry_id, incident_action_entry_item, **kwargs)  # noqa: E501
            return data

    def update_incident_action_entry_with_http_info(self, incident_action_entry_id, incident_action_entry_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentActionEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_action_entry_with_http_info(incident_action_entry_id, incident_action_entry_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_action_entry_id: Numeric value of the incidentactionentryID (required)
        :param IncidentActionEntryItem incident_action_entry_item: IncidentActionEntry to update (required)
        :return: list[IncidentActionEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_action_entry_id', 'incident_action_entry_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_action_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_action_entry_id' is set
        if ('incident_action_entry_id' not in params or
                params['incident_action_entry_id'] is None):
            raise ValueError("Missing the required parameter `incident_action_entry_id` when calling `update_incident_action_entry`")  # noqa: E501
        # verify the required parameter 'incident_action_entry_item' is set
        if ('incident_action_entry_item' not in params or
                params['incident_action_entry_item'] is None):
            raise ValueError("Missing the required parameter `incident_action_entry_item` when calling `update_incident_action_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_action_entry_id' in params:
            path_params['IncidentActionEntryID'] = params['incident_action_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_action_entry_item' in params:
            body_params = params['incident_action_entry_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentActionEntry/{IncidentActionEntryID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentActionEntryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_action_type(self, incident_action_type_id, incident_action_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentActionType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_action_type(incident_action_type_id, incident_action_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_action_type_id: Numeric value of the incidentactiontypeID (required)
        :param IncidentActionTypeItem incident_action_type_item: IncidentActionType to update (required)
        :return: list[IncidentActionTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_action_type_with_http_info(incident_action_type_id, incident_action_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_action_type_with_http_info(incident_action_type_id, incident_action_type_item, **kwargs)  # noqa: E501
            return data

    def update_incident_action_type_with_http_info(self, incident_action_type_id, incident_action_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentActionType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_action_type_with_http_info(incident_action_type_id, incident_action_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_action_type_id: Numeric value of the incidentactiontypeID (required)
        :param IncidentActionTypeItem incident_action_type_item: IncidentActionType to update (required)
        :return: list[IncidentActionTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_action_type_id', 'incident_action_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_action_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_action_type_id' is set
        if ('incident_action_type_id' not in params or
                params['incident_action_type_id'] is None):
            raise ValueError("Missing the required parameter `incident_action_type_id` when calling `update_incident_action_type`")  # noqa: E501
        # verify the required parameter 'incident_action_type_item' is set
        if ('incident_action_type_item' not in params or
                params['incident_action_type_item'] is None):
            raise ValueError("Missing the required parameter `incident_action_type_item` when calling `update_incident_action_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_action_type_id' in params:
            path_params['IncidentActionTypeID'] = params['incident_action_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_action_type_item' in params:
            body_params = params['incident_action_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentActionType/{IncidentActionTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentActionTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_appeal_decision(self, incident_appeal_decision_id, incident_appeal_decision_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentAppealDecision in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_appeal_decision(incident_appeal_decision_id, incident_appeal_decision_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_appeal_decision_id: Numeric value of the incidentappealdecisionID (required)
        :param IncidentAppealDecisionItem incident_appeal_decision_item: IncidentAppealDecision to update (required)
        :return: list[IncidentAppealDecisionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_appeal_decision_with_http_info(incident_appeal_decision_id, incident_appeal_decision_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_appeal_decision_with_http_info(incident_appeal_decision_id, incident_appeal_decision_item, **kwargs)  # noqa: E501
            return data

    def update_incident_appeal_decision_with_http_info(self, incident_appeal_decision_id, incident_appeal_decision_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentAppealDecision in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_appeal_decision_with_http_info(incident_appeal_decision_id, incident_appeal_decision_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_appeal_decision_id: Numeric value of the incidentappealdecisionID (required)
        :param IncidentAppealDecisionItem incident_appeal_decision_item: IncidentAppealDecision to update (required)
        :return: list[IncidentAppealDecisionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_appeal_decision_id', 'incident_appeal_decision_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_appeal_decision" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_appeal_decision_id' is set
        if ('incident_appeal_decision_id' not in params or
                params['incident_appeal_decision_id'] is None):
            raise ValueError("Missing the required parameter `incident_appeal_decision_id` when calling `update_incident_appeal_decision`")  # noqa: E501
        # verify the required parameter 'incident_appeal_decision_item' is set
        if ('incident_appeal_decision_item' not in params or
                params['incident_appeal_decision_item'] is None):
            raise ValueError("Missing the required parameter `incident_appeal_decision_item` when calling `update_incident_appeal_decision`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_appeal_decision_id' in params:
            path_params['IncidentAppealDecisionID'] = params['incident_appeal_decision_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_appeal_decision_item' in params:
            body_params = params['incident_appeal_decision_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentAppealDecision/{IncidentAppealDecisionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentAppealDecisionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_appeal_type(self, incident_appeal_type_id, incident_appeal_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentAppealType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_appeal_type(incident_appeal_type_id, incident_appeal_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_appeal_type_id: Numeric value of the incidentappealtypeID (required)
        :param IncidentAppealTypeItem incident_appeal_type_item: IncidentAppealType to update (required)
        :return: list[IncidentAppealTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_appeal_type_with_http_info(incident_appeal_type_id, incident_appeal_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_appeal_type_with_http_info(incident_appeal_type_id, incident_appeal_type_item, **kwargs)  # noqa: E501
            return data

    def update_incident_appeal_type_with_http_info(self, incident_appeal_type_id, incident_appeal_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentAppealType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_appeal_type_with_http_info(incident_appeal_type_id, incident_appeal_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_appeal_type_id: Numeric value of the incidentappealtypeID (required)
        :param IncidentAppealTypeItem incident_appeal_type_item: IncidentAppealType to update (required)
        :return: list[IncidentAppealTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_appeal_type_id', 'incident_appeal_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_appeal_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_appeal_type_id' is set
        if ('incident_appeal_type_id' not in params or
                params['incident_appeal_type_id'] is None):
            raise ValueError("Missing the required parameter `incident_appeal_type_id` when calling `update_incident_appeal_type`")  # noqa: E501
        # verify the required parameter 'incident_appeal_type_item' is set
        if ('incident_appeal_type_item' not in params or
                params['incident_appeal_type_item'] is None):
            raise ValueError("Missing the required parameter `incident_appeal_type_item` when calling `update_incident_appeal_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_appeal_type_id' in params:
            path_params['IncidentAppealTypeID'] = params['incident_appeal_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_appeal_type_item' in params:
            body_params = params['incident_appeal_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentAppealType/{IncidentAppealTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentAppealTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_clery_geography(self, incident_clery_geography_id, incident_clery_geography_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentCleryGeography in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_clery_geography(incident_clery_geography_id, incident_clery_geography_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_clery_geography_id: Numeric value of the incidentclerygeographyID (required)
        :param IncidentCleryGeographyItem incident_clery_geography_item: IncidentCleryGeography to update (required)
        :return: list[IncidentCleryGeographyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_clery_geography_with_http_info(incident_clery_geography_id, incident_clery_geography_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_clery_geography_with_http_info(incident_clery_geography_id, incident_clery_geography_item, **kwargs)  # noqa: E501
            return data

    def update_incident_clery_geography_with_http_info(self, incident_clery_geography_id, incident_clery_geography_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentCleryGeography in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_clery_geography_with_http_info(incident_clery_geography_id, incident_clery_geography_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_clery_geography_id: Numeric value of the incidentclerygeographyID (required)
        :param IncidentCleryGeographyItem incident_clery_geography_item: IncidentCleryGeography to update (required)
        :return: list[IncidentCleryGeographyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_clery_geography_id', 'incident_clery_geography_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_clery_geography" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_clery_geography_id' is set
        if ('incident_clery_geography_id' not in params or
                params['incident_clery_geography_id'] is None):
            raise ValueError("Missing the required parameter `incident_clery_geography_id` when calling `update_incident_clery_geography`")  # noqa: E501
        # verify the required parameter 'incident_clery_geography_item' is set
        if ('incident_clery_geography_item' not in params or
                params['incident_clery_geography_item'] is None):
            raise ValueError("Missing the required parameter `incident_clery_geography_item` when calling `update_incident_clery_geography`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_clery_geography_id' in params:
            path_params['IncidentCleryGeographyID'] = params['incident_clery_geography_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_clery_geography_item' in params:
            body_params = params['incident_clery_geography_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentCleryGeography/{IncidentCleryGeographyID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentCleryGeographyItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_custom_field(self, incident_custom_field_id, incident_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_custom_field(incident_custom_field_id, incident_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_custom_field_id: Numeric value of the incidentcustomfieldID (required)
        :param IncidentCustomFieldItem incident_custom_field_item: IncidentCustomField to update (required)
        :return: list[IncidentCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_custom_field_with_http_info(incident_custom_field_id, incident_custom_field_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_custom_field_with_http_info(incident_custom_field_id, incident_custom_field_item, **kwargs)  # noqa: E501
            return data

    def update_incident_custom_field_with_http_info(self, incident_custom_field_id, incident_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_custom_field_with_http_info(incident_custom_field_id, incident_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_custom_field_id: Numeric value of the incidentcustomfieldID (required)
        :param IncidentCustomFieldItem incident_custom_field_item: IncidentCustomField to update (required)
        :return: list[IncidentCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_custom_field_id', 'incident_custom_field_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_custom_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_custom_field_id' is set
        if ('incident_custom_field_id' not in params or
                params['incident_custom_field_id'] is None):
            raise ValueError("Missing the required parameter `incident_custom_field_id` when calling `update_incident_custom_field`")  # noqa: E501
        # verify the required parameter 'incident_custom_field_item' is set
        if ('incident_custom_field_item' not in params or
                params['incident_custom_field_item'] is None):
            raise ValueError("Missing the required parameter `incident_custom_field_item` when calling `update_incident_custom_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_custom_field_id' in params:
            path_params['IncidentCustomFieldID'] = params['incident_custom_field_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_custom_field_item' in params:
            body_params = params['incident_custom_field_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentCustomField/{IncidentCustomFieldID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_entry(self, incident_entry_id, incident_entry_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_entry(incident_entry_id, incident_entry_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_id: Numeric value of the incidententryID (required)
        :param IncidentEntryItem incident_entry_item: IncidentEntry to update (required)
        :return: list[IncidentEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_entry_with_http_info(incident_entry_id, incident_entry_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_entry_with_http_info(incident_entry_id, incident_entry_item, **kwargs)  # noqa: E501
            return data

    def update_incident_entry_with_http_info(self, incident_entry_id, incident_entry_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_entry_with_http_info(incident_entry_id, incident_entry_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_id: Numeric value of the incidententryID (required)
        :param IncidentEntryItem incident_entry_item: IncidentEntry to update (required)
        :return: list[IncidentEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_entry_id', 'incident_entry_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_entry_id' is set
        if ('incident_entry_id' not in params or
                params['incident_entry_id'] is None):
            raise ValueError("Missing the required parameter `incident_entry_id` when calling `update_incident_entry`")  # noqa: E501
        # verify the required parameter 'incident_entry_item' is set
        if ('incident_entry_item' not in params or
                params['incident_entry_item'] is None):
            raise ValueError("Missing the required parameter `incident_entry_item` when calling `update_incident_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_entry_id' in params:
            path_params['IncidentEntryID'] = params['incident_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_entry_item' in params:
            body_params = params['incident_entry_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentEntry/{IncidentEntryID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentEntryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_entry_appeal(self, incident_entry_appeal_id, incident_entry_appeal_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentEntryAppeal in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_entry_appeal(incident_entry_appeal_id, incident_entry_appeal_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_appeal_id: Numeric value of the incidententryappealID (required)
        :param IncidentEntryAppealItem incident_entry_appeal_item: IncidentEntryAppeal to update (required)
        :return: list[IncidentEntryAppealItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_entry_appeal_with_http_info(incident_entry_appeal_id, incident_entry_appeal_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_entry_appeal_with_http_info(incident_entry_appeal_id, incident_entry_appeal_item, **kwargs)  # noqa: E501
            return data

    def update_incident_entry_appeal_with_http_info(self, incident_entry_appeal_id, incident_entry_appeal_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentEntryAppeal in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_entry_appeal_with_http_info(incident_entry_appeal_id, incident_entry_appeal_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_appeal_id: Numeric value of the incidententryappealID (required)
        :param IncidentEntryAppealItem incident_entry_appeal_item: IncidentEntryAppeal to update (required)
        :return: list[IncidentEntryAppealItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_entry_appeal_id', 'incident_entry_appeal_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_entry_appeal" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_entry_appeal_id' is set
        if ('incident_entry_appeal_id' not in params or
                params['incident_entry_appeal_id'] is None):
            raise ValueError("Missing the required parameter `incident_entry_appeal_id` when calling `update_incident_entry_appeal`")  # noqa: E501
        # verify the required parameter 'incident_entry_appeal_item' is set
        if ('incident_entry_appeal_item' not in params or
                params['incident_entry_appeal_item'] is None):
            raise ValueError("Missing the required parameter `incident_entry_appeal_item` when calling `update_incident_entry_appeal`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_entry_appeal_id' in params:
            path_params['IncidentEntryAppealID'] = params['incident_entry_appeal_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_entry_appeal_item' in params:
            body_params = params['incident_entry_appeal_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentEntryAppeal/{IncidentEntryAppealID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentEntryAppealItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_entry_correspondence(self, incident_entry_correspondence_id, incident_entry_correspondence_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentEntryCorrespondence in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_entry_correspondence(incident_entry_correspondence_id, incident_entry_correspondence_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_correspondence_id: Numeric value of the incidententrycorrespondenceID (required)
        :param IncidentEntryCorrespondenceItem incident_entry_correspondence_item: IncidentEntryCorrespondence to update (required)
        :return: list[IncidentEntryCorrespondenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_entry_correspondence_with_http_info(incident_entry_correspondence_id, incident_entry_correspondence_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_entry_correspondence_with_http_info(incident_entry_correspondence_id, incident_entry_correspondence_item, **kwargs)  # noqa: E501
            return data

    def update_incident_entry_correspondence_with_http_info(self, incident_entry_correspondence_id, incident_entry_correspondence_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentEntryCorrespondence in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_entry_correspondence_with_http_info(incident_entry_correspondence_id, incident_entry_correspondence_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_correspondence_id: Numeric value of the incidententrycorrespondenceID (required)
        :param IncidentEntryCorrespondenceItem incident_entry_correspondence_item: IncidentEntryCorrespondence to update (required)
        :return: list[IncidentEntryCorrespondenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_entry_correspondence_id', 'incident_entry_correspondence_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_entry_correspondence" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_entry_correspondence_id' is set
        if ('incident_entry_correspondence_id' not in params or
                params['incident_entry_correspondence_id'] is None):
            raise ValueError("Missing the required parameter `incident_entry_correspondence_id` when calling `update_incident_entry_correspondence`")  # noqa: E501
        # verify the required parameter 'incident_entry_correspondence_item' is set
        if ('incident_entry_correspondence_item' not in params or
                params['incident_entry_correspondence_item'] is None):
            raise ValueError("Missing the required parameter `incident_entry_correspondence_item` when calling `update_incident_entry_correspondence`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_entry_correspondence_id' in params:
            path_params['IncidentEntryCorrespondenceID'] = params['incident_entry_correspondence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_entry_correspondence_item' in params:
            body_params = params['incident_entry_correspondence_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentEntryCorrespondence/{IncidentEntryCorrespondenceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentEntryCorrespondenceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_entry_note(self, incident_entry_note_id, incident_entry_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentEntryNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_entry_note(incident_entry_note_id, incident_entry_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_note_id: Numeric value of the incidententrynoteID (required)
        :param IncidentEntryNoteItem incident_entry_note_item: IncidentEntryNote to update (required)
        :return: list[IncidentEntryNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_entry_note_with_http_info(incident_entry_note_id, incident_entry_note_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_entry_note_with_http_info(incident_entry_note_id, incident_entry_note_item, **kwargs)  # noqa: E501
            return data

    def update_incident_entry_note_with_http_info(self, incident_entry_note_id, incident_entry_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentEntryNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_entry_note_with_http_info(incident_entry_note_id, incident_entry_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_note_id: Numeric value of the incidententrynoteID (required)
        :param IncidentEntryNoteItem incident_entry_note_item: IncidentEntryNote to update (required)
        :return: list[IncidentEntryNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_entry_note_id', 'incident_entry_note_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_entry_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_entry_note_id' is set
        if ('incident_entry_note_id' not in params or
                params['incident_entry_note_id'] is None):
            raise ValueError("Missing the required parameter `incident_entry_note_id` when calling `update_incident_entry_note`")  # noqa: E501
        # verify the required parameter 'incident_entry_note_item' is set
        if ('incident_entry_note_item' not in params or
                params['incident_entry_note_item'] is None):
            raise ValueError("Missing the required parameter `incident_entry_note_item` when calling `update_incident_entry_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_entry_note_id' in params:
            path_params['IncidentEntryNoteID'] = params['incident_entry_note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_entry_note_item' in params:
            body_params = params['incident_entry_note_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentEntryNote/{IncidentEntryNoteID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentEntryNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_entry_sanction(self, incident_entry_sanction_id, incident_entry_sanction_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentEntrySanction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_entry_sanction(incident_entry_sanction_id, incident_entry_sanction_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_sanction_id: Numeric value of the incidententrysanctionID (required)
        :param IncidentEntrySanctionItem incident_entry_sanction_item: IncidentEntrySanction to update (required)
        :return: list[IncidentEntrySanctionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_entry_sanction_with_http_info(incident_entry_sanction_id, incident_entry_sanction_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_entry_sanction_with_http_info(incident_entry_sanction_id, incident_entry_sanction_item, **kwargs)  # noqa: E501
            return data

    def update_incident_entry_sanction_with_http_info(self, incident_entry_sanction_id, incident_entry_sanction_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentEntrySanction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_entry_sanction_with_http_info(incident_entry_sanction_id, incident_entry_sanction_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_sanction_id: Numeric value of the incidententrysanctionID (required)
        :param IncidentEntrySanctionItem incident_entry_sanction_item: IncidentEntrySanction to update (required)
        :return: list[IncidentEntrySanctionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_entry_sanction_id', 'incident_entry_sanction_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_entry_sanction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_entry_sanction_id' is set
        if ('incident_entry_sanction_id' not in params or
                params['incident_entry_sanction_id'] is None):
            raise ValueError("Missing the required parameter `incident_entry_sanction_id` when calling `update_incident_entry_sanction`")  # noqa: E501
        # verify the required parameter 'incident_entry_sanction_item' is set
        if ('incident_entry_sanction_item' not in params or
                params['incident_entry_sanction_item'] is None):
            raise ValueError("Missing the required parameter `incident_entry_sanction_item` when calling `update_incident_entry_sanction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_entry_sanction_id' in params:
            path_params['IncidentEntrySanctionID'] = params['incident_entry_sanction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_entry_sanction_item' in params:
            body_params = params['incident_entry_sanction_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentEntrySanction/{IncidentEntrySanctionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentEntrySanctionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_entry_violation(self, incident_entry_violation_id, incident_entry_violation_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentEntryViolation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_entry_violation(incident_entry_violation_id, incident_entry_violation_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_violation_id: Numeric value of the incidententryviolationID (required)
        :param IncidentEntryViolationItem incident_entry_violation_item: IncidentEntryViolation to update (required)
        :return: list[IncidentEntryViolationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_entry_violation_with_http_info(incident_entry_violation_id, incident_entry_violation_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_entry_violation_with_http_info(incident_entry_violation_id, incident_entry_violation_item, **kwargs)  # noqa: E501
            return data

    def update_incident_entry_violation_with_http_info(self, incident_entry_violation_id, incident_entry_violation_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentEntryViolation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_entry_violation_with_http_info(incident_entry_violation_id, incident_entry_violation_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_entry_violation_id: Numeric value of the incidententryviolationID (required)
        :param IncidentEntryViolationItem incident_entry_violation_item: IncidentEntryViolation to update (required)
        :return: list[IncidentEntryViolationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_entry_violation_id', 'incident_entry_violation_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_entry_violation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_entry_violation_id' is set
        if ('incident_entry_violation_id' not in params or
                params['incident_entry_violation_id'] is None):
            raise ValueError("Missing the required parameter `incident_entry_violation_id` when calling `update_incident_entry_violation`")  # noqa: E501
        # verify the required parameter 'incident_entry_violation_item' is set
        if ('incident_entry_violation_item' not in params or
                params['incident_entry_violation_item'] is None):
            raise ValueError("Missing the required parameter `incident_entry_violation_item` when calling `update_incident_entry_violation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_entry_violation_id' in params:
            path_params['IncidentEntryViolationID'] = params['incident_entry_violation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_entry_violation_item' in params:
            body_params = params['incident_entry_violation_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentEntryViolation/{IncidentEntryViolationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentEntryViolationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_finding(self, incident_finding_id, incident_finding_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentFinding in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_finding(incident_finding_id, incident_finding_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_finding_id: Numeric value of the incidentfindingID (required)
        :param IncidentFindingItem incident_finding_item: IncidentFinding to update (required)
        :return: list[IncidentFindingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_finding_with_http_info(incident_finding_id, incident_finding_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_finding_with_http_info(incident_finding_id, incident_finding_item, **kwargs)  # noqa: E501
            return data

    def update_incident_finding_with_http_info(self, incident_finding_id, incident_finding_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentFinding in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_finding_with_http_info(incident_finding_id, incident_finding_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_finding_id: Numeric value of the incidentfindingID (required)
        :param IncidentFindingItem incident_finding_item: IncidentFinding to update (required)
        :return: list[IncidentFindingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_finding_id', 'incident_finding_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_finding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_finding_id' is set
        if ('incident_finding_id' not in params or
                params['incident_finding_id'] is None):
            raise ValueError("Missing the required parameter `incident_finding_id` when calling `update_incident_finding`")  # noqa: E501
        # verify the required parameter 'incident_finding_item' is set
        if ('incident_finding_item' not in params or
                params['incident_finding_item'] is None):
            raise ValueError("Missing the required parameter `incident_finding_item` when calling `update_incident_finding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_finding_id' in params:
            path_params['IncidentFindingID'] = params['incident_finding_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_finding_item' in params:
            body_params = params['incident_finding_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentFinding/{IncidentFindingID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentFindingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_involvement(self, incident_involvement_id, incident_involvement_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentInvolvement in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_involvement(incident_involvement_id, incident_involvement_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_involvement_id: Numeric value of the incidentinvolvementID (required)
        :param IncidentInvolvementItem incident_involvement_item: IncidentInvolvement to update (required)
        :return: list[IncidentInvolvementItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_involvement_with_http_info(incident_involvement_id, incident_involvement_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_involvement_with_http_info(incident_involvement_id, incident_involvement_item, **kwargs)  # noqa: E501
            return data

    def update_incident_involvement_with_http_info(self, incident_involvement_id, incident_involvement_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentInvolvement in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_involvement_with_http_info(incident_involvement_id, incident_involvement_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_involvement_id: Numeric value of the incidentinvolvementID (required)
        :param IncidentInvolvementItem incident_involvement_item: IncidentInvolvement to update (required)
        :return: list[IncidentInvolvementItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_involvement_id', 'incident_involvement_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_involvement" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_involvement_id' is set
        if ('incident_involvement_id' not in params or
                params['incident_involvement_id'] is None):
            raise ValueError("Missing the required parameter `incident_involvement_id` when calling `update_incident_involvement`")  # noqa: E501
        # verify the required parameter 'incident_involvement_item' is set
        if ('incident_involvement_item' not in params or
                params['incident_involvement_item'] is None):
            raise ValueError("Missing the required parameter `incident_involvement_item` when calling `update_incident_involvement`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_involvement_id' in params:
            path_params['IncidentInvolvementID'] = params['incident_involvement_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_involvement_item' in params:
            body_params = params['incident_involvement_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentInvolvement/{IncidentInvolvementID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentInvolvementItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_note(self, incident_note_id, incident_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_note(incident_note_id, incident_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_note_id: Numeric value of the incidentnoteID (required)
        :param IncidentNoteItem incident_note_item: IncidentNote to update (required)
        :return: list[IncidentNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_note_with_http_info(incident_note_id, incident_note_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_note_with_http_info(incident_note_id, incident_note_item, **kwargs)  # noqa: E501
            return data

    def update_incident_note_with_http_info(self, incident_note_id, incident_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_note_with_http_info(incident_note_id, incident_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_note_id: Numeric value of the incidentnoteID (required)
        :param IncidentNoteItem incident_note_item: IncidentNote to update (required)
        :return: list[IncidentNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_note_id', 'incident_note_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_note_id' is set
        if ('incident_note_id' not in params or
                params['incident_note_id'] is None):
            raise ValueError("Missing the required parameter `incident_note_id` when calling `update_incident_note`")  # noqa: E501
        # verify the required parameter 'incident_note_item' is set
        if ('incident_note_item' not in params or
                params['incident_note_item'] is None):
            raise ValueError("Missing the required parameter `incident_note_item` when calling `update_incident_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_note_id' in params:
            path_params['IncidentNoteID'] = params['incident_note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_note_item' in params:
            body_params = params['incident_note_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentNote/{IncidentNoteID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_plea(self, incident_plea_id, incident_plea_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentPlea in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_plea(incident_plea_id, incident_plea_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_plea_id: Numeric value of the incidentpleaID (required)
        :param IncidentPleaItem incident_plea_item: IncidentPlea to update (required)
        :return: list[IncidentPleaItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_plea_with_http_info(incident_plea_id, incident_plea_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_plea_with_http_info(incident_plea_id, incident_plea_item, **kwargs)  # noqa: E501
            return data

    def update_incident_plea_with_http_info(self, incident_plea_id, incident_plea_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentPlea in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_plea_with_http_info(incident_plea_id, incident_plea_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_plea_id: Numeric value of the incidentpleaID (required)
        :param IncidentPleaItem incident_plea_item: IncidentPlea to update (required)
        :return: list[IncidentPleaItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_plea_id', 'incident_plea_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_plea" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_plea_id' is set
        if ('incident_plea_id' not in params or
                params['incident_plea_id'] is None):
            raise ValueError("Missing the required parameter `incident_plea_id` when calling `update_incident_plea`")  # noqa: E501
        # verify the required parameter 'incident_plea_item' is set
        if ('incident_plea_item' not in params or
                params['incident_plea_item'] is None):
            raise ValueError("Missing the required parameter `incident_plea_item` when calling `update_incident_plea`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_plea_id' in params:
            path_params['IncidentPleaID'] = params['incident_plea_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_plea_item' in params:
            body_params = params['incident_plea_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentPlea/{IncidentPleaID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentPleaItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_sanction_sub_type(self, incident_sanction_sub_type_id, incident_sanction_sub_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentSanctionSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_sanction_sub_type(incident_sanction_sub_type_id, incident_sanction_sub_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_sanction_sub_type_id: Numeric value of the incidentsanctionsubtypeID (required)
        :param IncidentSanctionSubTypeItem incident_sanction_sub_type_item: IncidentSanctionSubType to update (required)
        :return: list[IncidentSanctionSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_sanction_sub_type_with_http_info(incident_sanction_sub_type_id, incident_sanction_sub_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_sanction_sub_type_with_http_info(incident_sanction_sub_type_id, incident_sanction_sub_type_item, **kwargs)  # noqa: E501
            return data

    def update_incident_sanction_sub_type_with_http_info(self, incident_sanction_sub_type_id, incident_sanction_sub_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentSanctionSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_sanction_sub_type_with_http_info(incident_sanction_sub_type_id, incident_sanction_sub_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_sanction_sub_type_id: Numeric value of the incidentsanctionsubtypeID (required)
        :param IncidentSanctionSubTypeItem incident_sanction_sub_type_item: IncidentSanctionSubType to update (required)
        :return: list[IncidentSanctionSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_sanction_sub_type_id', 'incident_sanction_sub_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_sanction_sub_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_sanction_sub_type_id' is set
        if ('incident_sanction_sub_type_id' not in params or
                params['incident_sanction_sub_type_id'] is None):
            raise ValueError("Missing the required parameter `incident_sanction_sub_type_id` when calling `update_incident_sanction_sub_type`")  # noqa: E501
        # verify the required parameter 'incident_sanction_sub_type_item' is set
        if ('incident_sanction_sub_type_item' not in params or
                params['incident_sanction_sub_type_item'] is None):
            raise ValueError("Missing the required parameter `incident_sanction_sub_type_item` when calling `update_incident_sanction_sub_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_sanction_sub_type_id' in params:
            path_params['IncidentSanctionSubTypeID'] = params['incident_sanction_sub_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_sanction_sub_type_item' in params:
            body_params = params['incident_sanction_sub_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentSanctionSubType/{IncidentSanctionSubTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentSanctionSubTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_sanction_type(self, incident_sanction_type_id, incident_sanction_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentSanctionType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_sanction_type(incident_sanction_type_id, incident_sanction_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_sanction_type_id: Numeric value of the incidentsanctiontypeID (required)
        :param IncidentSanctionTypeItem incident_sanction_type_item: IncidentSanctionType to update (required)
        :return: list[IncidentSanctionTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_sanction_type_with_http_info(incident_sanction_type_id, incident_sanction_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_sanction_type_with_http_info(incident_sanction_type_id, incident_sanction_type_item, **kwargs)  # noqa: E501
            return data

    def update_incident_sanction_type_with_http_info(self, incident_sanction_type_id, incident_sanction_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentSanctionType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_sanction_type_with_http_info(incident_sanction_type_id, incident_sanction_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_sanction_type_id: Numeric value of the incidentsanctiontypeID (required)
        :param IncidentSanctionTypeItem incident_sanction_type_item: IncidentSanctionType to update (required)
        :return: list[IncidentSanctionTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_sanction_type_id', 'incident_sanction_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_sanction_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_sanction_type_id' is set
        if ('incident_sanction_type_id' not in params or
                params['incident_sanction_type_id'] is None):
            raise ValueError("Missing the required parameter `incident_sanction_type_id` when calling `update_incident_sanction_type`")  # noqa: E501
        # verify the required parameter 'incident_sanction_type_item' is set
        if ('incident_sanction_type_item' not in params or
                params['incident_sanction_type_item'] is None):
            raise ValueError("Missing the required parameter `incident_sanction_type_item` when calling `update_incident_sanction_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_sanction_type_id' in params:
            path_params['IncidentSanctionTypeID'] = params['incident_sanction_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_sanction_type_item' in params:
            body_params = params['incident_sanction_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentSanctionType/{IncidentSanctionTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentSanctionTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_severity(self, incident_severity_id, incident_severity_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentSeverity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_severity(incident_severity_id, incident_severity_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_severity_id: Numeric value of the incidentseverityID (required)
        :param IncidentSeverityItem incident_severity_item: IncidentSeverity to update (required)
        :return: list[IncidentSeverityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_severity_with_http_info(incident_severity_id, incident_severity_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_severity_with_http_info(incident_severity_id, incident_severity_item, **kwargs)  # noqa: E501
            return data

    def update_incident_severity_with_http_info(self, incident_severity_id, incident_severity_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentSeverity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_severity_with_http_info(incident_severity_id, incident_severity_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_severity_id: Numeric value of the incidentseverityID (required)
        :param IncidentSeverityItem incident_severity_item: IncidentSeverity to update (required)
        :return: list[IncidentSeverityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_severity_id', 'incident_severity_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_severity" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_severity_id' is set
        if ('incident_severity_id' not in params or
                params['incident_severity_id'] is None):
            raise ValueError("Missing the required parameter `incident_severity_id` when calling `update_incident_severity`")  # noqa: E501
        # verify the required parameter 'incident_severity_item' is set
        if ('incident_severity_item' not in params or
                params['incident_severity_item'] is None):
            raise ValueError("Missing the required parameter `incident_severity_item` when calling `update_incident_severity`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_severity_id' in params:
            path_params['IncidentSeverityID'] = params['incident_severity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_severity_item' in params:
            body_params = params['incident_severity_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentSeverity/{IncidentSeverityID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentSeverityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_status(self, incident_status_id, incident_status_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_status(incident_status_id, incident_status_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_status_id: Numeric value of the incidentstatusID (required)
        :param IncidentStatusItem incident_status_item: IncidentStatus to update (required)
        :return: list[IncidentStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_status_with_http_info(incident_status_id, incident_status_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_status_with_http_info(incident_status_id, incident_status_item, **kwargs)  # noqa: E501
            return data

    def update_incident_status_with_http_info(self, incident_status_id, incident_status_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_status_with_http_info(incident_status_id, incident_status_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_status_id: Numeric value of the incidentstatusID (required)
        :param IncidentStatusItem incident_status_item: IncidentStatus to update (required)
        :return: list[IncidentStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_status_id', 'incident_status_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_status_id' is set
        if ('incident_status_id' not in params or
                params['incident_status_id'] is None):
            raise ValueError("Missing the required parameter `incident_status_id` when calling `update_incident_status`")  # noqa: E501
        # verify the required parameter 'incident_status_item' is set
        if ('incident_status_item' not in params or
                params['incident_status_item'] is None):
            raise ValueError("Missing the required parameter `incident_status_item` when calling `update_incident_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_status_id' in params:
            path_params['IncidentStatusID'] = params['incident_status_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_status_item' in params:
            body_params = params['incident_status_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentStatus/{IncidentStatusID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentStatusItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_sub_type(self, incident_sub_type_id, incident_sub_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_sub_type(incident_sub_type_id, incident_sub_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_sub_type_id: Numeric value of the incidentsubtypeID (required)
        :param IncidentSubTypeItem incident_sub_type_item: IncidentSubType to update (required)
        :return: list[IncidentSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_sub_type_with_http_info(incident_sub_type_id, incident_sub_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_sub_type_with_http_info(incident_sub_type_id, incident_sub_type_item, **kwargs)  # noqa: E501
            return data

    def update_incident_sub_type_with_http_info(self, incident_sub_type_id, incident_sub_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_sub_type_with_http_info(incident_sub_type_id, incident_sub_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_sub_type_id: Numeric value of the incidentsubtypeID (required)
        :param IncidentSubTypeItem incident_sub_type_item: IncidentSubType to update (required)
        :return: list[IncidentSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_sub_type_id', 'incident_sub_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_sub_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_sub_type_id' is set
        if ('incident_sub_type_id' not in params or
                params['incident_sub_type_id'] is None):
            raise ValueError("Missing the required parameter `incident_sub_type_id` when calling `update_incident_sub_type`")  # noqa: E501
        # verify the required parameter 'incident_sub_type_item' is set
        if ('incident_sub_type_item' not in params or
                params['incident_sub_type_item'] is None):
            raise ValueError("Missing the required parameter `incident_sub_type_item` when calling `update_incident_sub_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_sub_type_id' in params:
            path_params['IncidentSubTypeID'] = params['incident_sub_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_sub_type_item' in params:
            body_params = params['incident_sub_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentSubType/{IncidentSubTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentSubTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_type(self, incident_type_id, incident_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_type(incident_type_id, incident_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_type_id: Numeric value of the incidenttypeID (required)
        :param IncidentTypeItem incident_type_item: IncidentType to update (required)
        :return: list[IncidentTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_type_with_http_info(incident_type_id, incident_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_type_with_http_info(incident_type_id, incident_type_item, **kwargs)  # noqa: E501
            return data

    def update_incident_type_with_http_info(self, incident_type_id, incident_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_type_with_http_info(incident_type_id, incident_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_type_id: Numeric value of the incidenttypeID (required)
        :param IncidentTypeItem incident_type_item: IncidentType to update (required)
        :return: list[IncidentTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_type_id', 'incident_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_type_id' is set
        if ('incident_type_id' not in params or
                params['incident_type_id'] is None):
            raise ValueError("Missing the required parameter `incident_type_id` when calling `update_incident_type`")  # noqa: E501
        # verify the required parameter 'incident_type_item' is set
        if ('incident_type_item' not in params or
                params['incident_type_item'] is None):
            raise ValueError("Missing the required parameter `incident_type_item` when calling `update_incident_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_type_id' in params:
            path_params['IncidentTypeID'] = params['incident_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_type_item' in params:
            body_params = params['incident_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentType/{IncidentTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_incident_violation(self, incident_violation_id, incident_violation_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentViolation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_violation(incident_violation_id, incident_violation_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_violation_id: Numeric value of the incidentviolationID (required)
        :param IncidentViolationItem incident_violation_item: IncidentViolation to update (required)
        :return: list[IncidentViolationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_incident_violation_with_http_info(incident_violation_id, incident_violation_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_incident_violation_with_http_info(incident_violation_id, incident_violation_item, **kwargs)  # noqa: E501
            return data

    def update_incident_violation_with_http_info(self, incident_violation_id, incident_violation_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an IncidentViolation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_incident_violation_with_http_info(incident_violation_id, incident_violation_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int incident_violation_id: Numeric value of the incidentviolationID (required)
        :param IncidentViolationItem incident_violation_item: IncidentViolation to update (required)
        :return: list[IncidentViolationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['incident_violation_id', 'incident_violation_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_incident_violation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'incident_violation_id' is set
        if ('incident_violation_id' not in params or
                params['incident_violation_id'] is None):
            raise ValueError("Missing the required parameter `incident_violation_id` when calling `update_incident_violation`")  # noqa: E501
        # verify the required parameter 'incident_violation_item' is set
        if ('incident_violation_item' not in params or
                params['incident_violation_item'] is None):
            raise ValueError("Missing the required parameter `incident_violation_item` when calling `update_incident_violation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'incident_violation_id' in params:
            path_params['IncidentViolationID'] = params['incident_violation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'incident_violation_item' in params:
            body_params = params['incident_violation_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/IncidentViolation/{IncidentViolationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[IncidentViolationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_inspection_run_template(self, inspection_run_template_id, inspection_run_template_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an InspectionRunTemplate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_inspection_run_template(inspection_run_template_id, inspection_run_template_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int inspection_run_template_id: Numeric value of the inspectionruntemplateID (required)
        :param InspectionRunTemplateItem inspection_run_template_item: InspectionRunTemplate to update (required)
        :return: list[InspectionRunTemplateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_inspection_run_template_with_http_info(inspection_run_template_id, inspection_run_template_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_inspection_run_template_with_http_info(inspection_run_template_id, inspection_run_template_item, **kwargs)  # noqa: E501
            return data

    def update_inspection_run_template_with_http_info(self, inspection_run_template_id, inspection_run_template_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an InspectionRunTemplate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_inspection_run_template_with_http_info(inspection_run_template_id, inspection_run_template_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int inspection_run_template_id: Numeric value of the inspectionruntemplateID (required)
        :param InspectionRunTemplateItem inspection_run_template_item: InspectionRunTemplate to update (required)
        :return: list[InspectionRunTemplateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['inspection_run_template_id', 'inspection_run_template_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_inspection_run_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'inspection_run_template_id' is set
        if ('inspection_run_template_id' not in params or
                params['inspection_run_template_id'] is None):
            raise ValueError("Missing the required parameter `inspection_run_template_id` when calling `update_inspection_run_template`")  # noqa: E501
        # verify the required parameter 'inspection_run_template_item' is set
        if ('inspection_run_template_item' not in params or
                params['inspection_run_template_item'] is None):
            raise ValueError("Missing the required parameter `inspection_run_template_item` when calling `update_inspection_run_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'inspection_run_template_id' in params:
            path_params['InspectionRunTemplateID'] = params['inspection_run_template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'inspection_run_template_item' in params:
            body_params = params['inspection_run_template_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/InspectionRunTemplate/{InspectionRunTemplateID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InspectionRunTemplateItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_interface(self, interface_id, interface_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Interface in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_interface(interface_id, interface_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int interface_id: Numeric value of the interfaceID (required)
        :param InterfaceItem interface_item: Interface to update (required)
        :return: list[InterfaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_interface_with_http_info(interface_id, interface_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_interface_with_http_info(interface_id, interface_item, **kwargs)  # noqa: E501
            return data

    def update_interface_with_http_info(self, interface_id, interface_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Interface in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_interface_with_http_info(interface_id, interface_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int interface_id: Numeric value of the interfaceID (required)
        :param InterfaceItem interface_item: Interface to update (required)
        :return: list[InterfaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interface_id', 'interface_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'interface_id' is set
        if ('interface_id' not in params or
                params['interface_id'] is None):
            raise ValueError("Missing the required parameter `interface_id` when calling `update_interface`")  # noqa: E501
        # verify the required parameter 'interface_item' is set
        if ('interface_item' not in params or
                params['interface_item'] is None):
            raise ValueError("Missing the required parameter `interface_item` when calling `update_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'interface_id' in params:
            path_params['InterfaceID'] = params['interface_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'interface_item' in params:
            body_params = params['interface_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Interface/{InterfaceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InterfaceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_interface_application(self, interface_application_id, interface_application_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an InterfaceApplication in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_interface_application(interface_application_id, interface_application_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int interface_application_id: Numeric value of the interfaceapplicationID (required)
        :param InterfaceApplicationItem interface_application_item: InterfaceApplication to update (required)
        :return: list[InterfaceApplicationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_interface_application_with_http_info(interface_application_id, interface_application_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_interface_application_with_http_info(interface_application_id, interface_application_item, **kwargs)  # noqa: E501
            return data

    def update_interface_application_with_http_info(self, interface_application_id, interface_application_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an InterfaceApplication in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_interface_application_with_http_info(interface_application_id, interface_application_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int interface_application_id: Numeric value of the interfaceapplicationID (required)
        :param InterfaceApplicationItem interface_application_item: InterfaceApplication to update (required)
        :return: list[InterfaceApplicationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interface_application_id', 'interface_application_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_interface_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'interface_application_id' is set
        if ('interface_application_id' not in params or
                params['interface_application_id'] is None):
            raise ValueError("Missing the required parameter `interface_application_id` when calling `update_interface_application`")  # noqa: E501
        # verify the required parameter 'interface_application_item' is set
        if ('interface_application_item' not in params or
                params['interface_application_item'] is None):
            raise ValueError("Missing the required parameter `interface_application_item` when calling `update_interface_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'interface_application_id' in params:
            path_params['InterfaceApplicationID'] = params['interface_application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'interface_application_item' in params:
            body_params = params['interface_application_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/InterfaceApplication/{InterfaceApplicationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InterfaceApplicationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_interface_subscribe(self, interface_subscribe_id, interface_subscribe_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an InterfaceSubscribe in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_interface_subscribe(interface_subscribe_id, interface_subscribe_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int interface_subscribe_id: Numeric value of the interfacesubscribeID (required)
        :param InterfaceSubscribeItem interface_subscribe_item: InterfaceSubscribe to update (required)
        :return: list[InterfaceSubscribeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_interface_subscribe_with_http_info(interface_subscribe_id, interface_subscribe_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_interface_subscribe_with_http_info(interface_subscribe_id, interface_subscribe_item, **kwargs)  # noqa: E501
            return data

    def update_interface_subscribe_with_http_info(self, interface_subscribe_id, interface_subscribe_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an InterfaceSubscribe in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_interface_subscribe_with_http_info(interface_subscribe_id, interface_subscribe_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int interface_subscribe_id: Numeric value of the interfacesubscribeID (required)
        :param InterfaceSubscribeItem interface_subscribe_item: InterfaceSubscribe to update (required)
        :return: list[InterfaceSubscribeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['interface_subscribe_id', 'interface_subscribe_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_interface_subscribe" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'interface_subscribe_id' is set
        if ('interface_subscribe_id' not in params or
                params['interface_subscribe_id'] is None):
            raise ValueError("Missing the required parameter `interface_subscribe_id` when calling `update_interface_subscribe`")  # noqa: E501
        # verify the required parameter 'interface_subscribe_item' is set
        if ('interface_subscribe_item' not in params or
                params['interface_subscribe_item'] is None):
            raise ValueError("Missing the required parameter `interface_subscribe_item` when calling `update_interface_subscribe`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'interface_subscribe_id' in params:
            path_params['InterfaceSubscribeID'] = params['interface_subscribe_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'interface_subscribe_item' in params:
            body_params = params['interface_subscribe_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/InterfaceSubscribe/{InterfaceSubscribeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InterfaceSubscribeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_invoice(self, invoice_id, invoice_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Invoice in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_invoice(invoice_id, invoice_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int invoice_id: Numeric value of the invoiceID (required)
        :param InvoiceItem invoice_item: Invoice to update (required)
        :return: list[InvoiceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_invoice_with_http_info(invoice_id, invoice_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_invoice_with_http_info(invoice_id, invoice_item, **kwargs)  # noqa: E501
            return data

    def update_invoice_with_http_info(self, invoice_id, invoice_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Invoice in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_invoice_with_http_info(invoice_id, invoice_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int invoice_id: Numeric value of the invoiceID (required)
        :param InvoiceItem invoice_item: Invoice to update (required)
        :return: list[InvoiceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['invoice_id', 'invoice_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_invoice" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'invoice_id' is set
        if ('invoice_id' not in params or
                params['invoice_id'] is None):
            raise ValueError("Missing the required parameter `invoice_id` when calling `update_invoice`")  # noqa: E501
        # verify the required parameter 'invoice_item' is set
        if ('invoice_item' not in params or
                params['invoice_item'] is None):
            raise ValueError("Missing the required parameter `invoice_item` when calling `update_invoice`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'invoice_id' in params:
            path_params['InvoiceID'] = params['invoice_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'invoice_item' in params:
            body_params = params['invoice_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Invoice/{InvoiceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InvoiceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_log_activity(self, log_activity_id, log_activity_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an LogActivity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_log_activity(log_activity_id, log_activity_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int log_activity_id: Numeric value of the logactivityID (required)
        :param LogActivityItem log_activity_item: LogActivity to update (required)
        :return: list[LogActivityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_log_activity_with_http_info(log_activity_id, log_activity_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_log_activity_with_http_info(log_activity_id, log_activity_item, **kwargs)  # noqa: E501
            return data

    def update_log_activity_with_http_info(self, log_activity_id, log_activity_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an LogActivity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_log_activity_with_http_info(log_activity_id, log_activity_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int log_activity_id: Numeric value of the logactivityID (required)
        :param LogActivityItem log_activity_item: LogActivity to update (required)
        :return: list[LogActivityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['log_activity_id', 'log_activity_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_log_activity" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'log_activity_id' is set
        if ('log_activity_id' not in params or
                params['log_activity_id'] is None):
            raise ValueError("Missing the required parameter `log_activity_id` when calling `update_log_activity`")  # noqa: E501
        # verify the required parameter 'log_activity_item' is set
        if ('log_activity_item' not in params or
                params['log_activity_item'] is None):
            raise ValueError("Missing the required parameter `log_activity_item` when calling `update_log_activity`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'log_activity_id' in params:
            path_params['LogActivityID'] = params['log_activity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'log_activity_item' in params:
            body_params = params['log_activity_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/LogActivity/{LogActivityID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LogActivityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_log_add_in(self, log_add_in_id, log_add_in_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an LogAddIn in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_log_add_in(log_add_in_id, log_add_in_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int log_add_in_id: Numeric value of the logaddinID (required)
        :param LogAddInItem log_add_in_item: LogAddIn to update (required)
        :return: list[LogAddInItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_log_add_in_with_http_info(log_add_in_id, log_add_in_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_log_add_in_with_http_info(log_add_in_id, log_add_in_item, **kwargs)  # noqa: E501
            return data

    def update_log_add_in_with_http_info(self, log_add_in_id, log_add_in_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an LogAddIn in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_log_add_in_with_http_info(log_add_in_id, log_add_in_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int log_add_in_id: Numeric value of the logaddinID (required)
        :param LogAddInItem log_add_in_item: LogAddIn to update (required)
        :return: list[LogAddInItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['log_add_in_id', 'log_add_in_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_log_add_in" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'log_add_in_id' is set
        if ('log_add_in_id' not in params or
                params['log_add_in_id'] is None):
            raise ValueError("Missing the required parameter `log_add_in_id` when calling `update_log_add_in`")  # noqa: E501
        # verify the required parameter 'log_add_in_item' is set
        if ('log_add_in_item' not in params or
                params['log_add_in_item'] is None):
            raise ValueError("Missing the required parameter `log_add_in_item` when calling `update_log_add_in`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'log_add_in_id' in params:
            path_params['LogAddInID'] = params['log_add_in_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'log_add_in_item' in params:
            body_params = params['log_add_in_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/LogAddIn/{LogAddInID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LogAddInItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_log_interface(self, log_interface_id, log_interface_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an LogInterface in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_log_interface(log_interface_id, log_interface_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int log_interface_id: Numeric value of the loginterfaceID (required)
        :param LogInterfaceItem log_interface_item: LogInterface to update (required)
        :return: list[LogInterfaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_log_interface_with_http_info(log_interface_id, log_interface_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_log_interface_with_http_info(log_interface_id, log_interface_item, **kwargs)  # noqa: E501
            return data

    def update_log_interface_with_http_info(self, log_interface_id, log_interface_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an LogInterface in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_log_interface_with_http_info(log_interface_id, log_interface_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int log_interface_id: Numeric value of the loginterfaceID (required)
        :param LogInterfaceItem log_interface_item: LogInterface to update (required)
        :return: list[LogInterfaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['log_interface_id', 'log_interface_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_log_interface" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'log_interface_id' is set
        if ('log_interface_id' not in params or
                params['log_interface_id'] is None):
            raise ValueError("Missing the required parameter `log_interface_id` when calling `update_log_interface`")  # noqa: E501
        # verify the required parameter 'log_interface_item' is set
        if ('log_interface_item' not in params or
                params['log_interface_item'] is None):
            raise ValueError("Missing the required parameter `log_interface_item` when calling `update_log_interface`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'log_interface_id' in params:
            path_params['LogInterfaceID'] = params['log_interface_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'log_interface_item' in params:
            body_params = params['log_interface_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/LogInterface/{LogInterfaceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LogInterfaceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_log_metric(self, log_metric_id, log_metric_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an LogMetric in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_log_metric(log_metric_id, log_metric_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int log_metric_id: Numeric value of the logmetricID (required)
        :param LogMetricItem log_metric_item: LogMetric to update (required)
        :return: list[LogMetricItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_log_metric_with_http_info(log_metric_id, log_metric_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_log_metric_with_http_info(log_metric_id, log_metric_item, **kwargs)  # noqa: E501
            return data

    def update_log_metric_with_http_info(self, log_metric_id, log_metric_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an LogMetric in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_log_metric_with_http_info(log_metric_id, log_metric_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int log_metric_id: Numeric value of the logmetricID (required)
        :param LogMetricItem log_metric_item: LogMetric to update (required)
        :return: list[LogMetricItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['log_metric_id', 'log_metric_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_log_metric" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'log_metric_id' is set
        if ('log_metric_id' not in params or
                params['log_metric_id'] is None):
            raise ValueError("Missing the required parameter `log_metric_id` when calling `update_log_metric`")  # noqa: E501
        # verify the required parameter 'log_metric_item' is set
        if ('log_metric_item' not in params or
                params['log_metric_item'] is None):
            raise ValueError("Missing the required parameter `log_metric_item` when calling `update_log_metric`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'log_metric_id' in params:
            path_params['LogMetricID'] = params['log_metric_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'log_metric_item' in params:
            body_params = params['log_metric_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/LogMetric/{LogMetricID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LogMetricItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_lookup(self, lookup_id, lookup_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Lookup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_lookup(lookup_id, lookup_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int lookup_id: Numeric value of the lookupID (required)
        :param LookupItem lookup_item: Lookup to update (required)
        :return: list[LookupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_lookup_with_http_info(lookup_id, lookup_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_lookup_with_http_info(lookup_id, lookup_item, **kwargs)  # noqa: E501
            return data

    def update_lookup_with_http_info(self, lookup_id, lookup_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Lookup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_lookup_with_http_info(lookup_id, lookup_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int lookup_id: Numeric value of the lookupID (required)
        :param LookupItem lookup_item: Lookup to update (required)
        :return: list[LookupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lookup_id', 'lookup_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_lookup" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lookup_id' is set
        if ('lookup_id' not in params or
                params['lookup_id'] is None):
            raise ValueError("Missing the required parameter `lookup_id` when calling `update_lookup`")  # noqa: E501
        # verify the required parameter 'lookup_item' is set
        if ('lookup_item' not in params or
                params['lookup_item'] is None):
            raise ValueError("Missing the required parameter `lookup_item` when calling `update_lookup`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lookup_id' in params:
            path_params['LookupID'] = params['lookup_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lookup_item' in params:
            body_params = params['lookup_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Lookup/{LookupID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LookupItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_lookup_text(self, lookup_text_id, lookup_text_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an LookupText in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_lookup_text(lookup_text_id, lookup_text_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int lookup_text_id: Numeric value of the lookuptextID (required)
        :param LookupTextItem lookup_text_item: LookupText to update (required)
        :return: list[LookupTextItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_lookup_text_with_http_info(lookup_text_id, lookup_text_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_lookup_text_with_http_info(lookup_text_id, lookup_text_item, **kwargs)  # noqa: E501
            return data

    def update_lookup_text_with_http_info(self, lookup_text_id, lookup_text_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an LookupText in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_lookup_text_with_http_info(lookup_text_id, lookup_text_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int lookup_text_id: Numeric value of the lookuptextID (required)
        :param LookupTextItem lookup_text_item: LookupText to update (required)
        :return: list[LookupTextItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['lookup_text_id', 'lookup_text_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_lookup_text" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'lookup_text_id' is set
        if ('lookup_text_id' not in params or
                params['lookup_text_id'] is None):
            raise ValueError("Missing the required parameter `lookup_text_id` when calling `update_lookup_text`")  # noqa: E501
        # verify the required parameter 'lookup_text_item' is set
        if ('lookup_text_item' not in params or
                params['lookup_text_item'] is None):
            raise ValueError("Missing the required parameter `lookup_text_item` when calling `update_lookup_text`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'lookup_text_id' in params:
            path_params['LookupTextID'] = params['lookup_text_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'lookup_text_item' in params:
            body_params = params['lookup_text_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/LookupText/{LookupTextID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LookupTextItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_mail_merge(self, mail_merge_id, mail_merge_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MailMerge in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_mail_merge(mail_merge_id, mail_merge_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int mail_merge_id: Numeric value of the mailmergeID (required)
        :param MailMergeItem mail_merge_item: MailMerge to update (required)
        :return: list[MailMergeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_mail_merge_with_http_info(mail_merge_id, mail_merge_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_mail_merge_with_http_info(mail_merge_id, mail_merge_item, **kwargs)  # noqa: E501
            return data

    def update_mail_merge_with_http_info(self, mail_merge_id, mail_merge_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MailMerge in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_mail_merge_with_http_info(mail_merge_id, mail_merge_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int mail_merge_id: Numeric value of the mailmergeID (required)
        :param MailMergeItem mail_merge_item: MailMerge to update (required)
        :return: list[MailMergeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mail_merge_id', 'mail_merge_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_mail_merge" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mail_merge_id' is set
        if ('mail_merge_id' not in params or
                params['mail_merge_id'] is None):
            raise ValueError("Missing the required parameter `mail_merge_id` when calling `update_mail_merge`")  # noqa: E501
        # verify the required parameter 'mail_merge_item' is set
        if ('mail_merge_item' not in params or
                params['mail_merge_item'] is None):
            raise ValueError("Missing the required parameter `mail_merge_item` when calling `update_mail_merge`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'mail_merge_id' in params:
            path_params['MailMergeID'] = params['mail_merge_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'mail_merge_item' in params:
            body_params = params['mail_merge_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/MailMerge/{MailMergeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MailMergeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_meal_plan(self, meal_plan_id, meal_plan_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MealPlan in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_meal_plan(meal_plan_id, meal_plan_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_id: Numeric value of the mealplanID (required)
        :param MealPlanItem meal_plan_item: MealPlan to update (required)
        :return: list[MealPlanItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_meal_plan_with_http_info(meal_plan_id, meal_plan_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_meal_plan_with_http_info(meal_plan_id, meal_plan_item, **kwargs)  # noqa: E501
            return data

    def update_meal_plan_with_http_info(self, meal_plan_id, meal_plan_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MealPlan in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_meal_plan_with_http_info(meal_plan_id, meal_plan_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_id: Numeric value of the mealplanID (required)
        :param MealPlanItem meal_plan_item: MealPlan to update (required)
        :return: list[MealPlanItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meal_plan_id', 'meal_plan_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_meal_plan" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'meal_plan_id' is set
        if ('meal_plan_id' not in params or
                params['meal_plan_id'] is None):
            raise ValueError("Missing the required parameter `meal_plan_id` when calling `update_meal_plan`")  # noqa: E501
        # verify the required parameter 'meal_plan_item' is set
        if ('meal_plan_item' not in params or
                params['meal_plan_item'] is None):
            raise ValueError("Missing the required parameter `meal_plan_item` when calling `update_meal_plan`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meal_plan_id' in params:
            path_params['MealPlanID'] = params['meal_plan_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'meal_plan_item' in params:
            body_params = params['meal_plan_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/MealPlan/{MealPlanID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MealPlanItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_meal_plan_detail(self, meal_plan_detail_id, meal_plan_detail_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MealPlanDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_meal_plan_detail(meal_plan_detail_id, meal_plan_detail_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_detail_id: Numeric value of the mealplandetailID (required)
        :param MealPlanDetailItem meal_plan_detail_item: MealPlanDetail to update (required)
        :return: list[MealPlanDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_meal_plan_detail_with_http_info(meal_plan_detail_id, meal_plan_detail_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_meal_plan_detail_with_http_info(meal_plan_detail_id, meal_plan_detail_item, **kwargs)  # noqa: E501
            return data

    def update_meal_plan_detail_with_http_info(self, meal_plan_detail_id, meal_plan_detail_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MealPlanDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_meal_plan_detail_with_http_info(meal_plan_detail_id, meal_plan_detail_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_detail_id: Numeric value of the mealplandetailID (required)
        :param MealPlanDetailItem meal_plan_detail_item: MealPlanDetail to update (required)
        :return: list[MealPlanDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meal_plan_detail_id', 'meal_plan_detail_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_meal_plan_detail" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'meal_plan_detail_id' is set
        if ('meal_plan_detail_id' not in params or
                params['meal_plan_detail_id'] is None):
            raise ValueError("Missing the required parameter `meal_plan_detail_id` when calling `update_meal_plan_detail`")  # noqa: E501
        # verify the required parameter 'meal_plan_detail_item' is set
        if ('meal_plan_detail_item' not in params or
                params['meal_plan_detail_item'] is None):
            raise ValueError("Missing the required parameter `meal_plan_detail_item` when calling `update_meal_plan_detail`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meal_plan_detail_id' in params:
            path_params['MealPlanDetailID'] = params['meal_plan_detail_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'meal_plan_detail_item' in params:
            body_params = params['meal_plan_detail_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/MealPlanDetail/{MealPlanDetailID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MealPlanDetailItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_meal_plan_dining_hall(self, meal_plan_dining_hall_id, meal_plan_dining_hall_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MealPlanDiningHall in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_meal_plan_dining_hall(meal_plan_dining_hall_id, meal_plan_dining_hall_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_dining_hall_id: Numeric value of the mealplandininghallID (required)
        :param MealPlanDiningHallItem meal_plan_dining_hall_item: MealPlanDiningHall to update (required)
        :return: list[MealPlanDiningHallItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_meal_plan_dining_hall_with_http_info(meal_plan_dining_hall_id, meal_plan_dining_hall_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_meal_plan_dining_hall_with_http_info(meal_plan_dining_hall_id, meal_plan_dining_hall_item, **kwargs)  # noqa: E501
            return data

    def update_meal_plan_dining_hall_with_http_info(self, meal_plan_dining_hall_id, meal_plan_dining_hall_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MealPlanDiningHall in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_meal_plan_dining_hall_with_http_info(meal_plan_dining_hall_id, meal_plan_dining_hall_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_dining_hall_id: Numeric value of the mealplandininghallID (required)
        :param MealPlanDiningHallItem meal_plan_dining_hall_item: MealPlanDiningHall to update (required)
        :return: list[MealPlanDiningHallItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meal_plan_dining_hall_id', 'meal_plan_dining_hall_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_meal_plan_dining_hall" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'meal_plan_dining_hall_id' is set
        if ('meal_plan_dining_hall_id' not in params or
                params['meal_plan_dining_hall_id'] is None):
            raise ValueError("Missing the required parameter `meal_plan_dining_hall_id` when calling `update_meal_plan_dining_hall`")  # noqa: E501
        # verify the required parameter 'meal_plan_dining_hall_item' is set
        if ('meal_plan_dining_hall_item' not in params or
                params['meal_plan_dining_hall_item'] is None):
            raise ValueError("Missing the required parameter `meal_plan_dining_hall_item` when calling `update_meal_plan_dining_hall`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meal_plan_dining_hall_id' in params:
            path_params['MealPlanDiningHallID'] = params['meal_plan_dining_hall_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'meal_plan_dining_hall_item' in params:
            body_params = params['meal_plan_dining_hall_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/MealPlanDiningHall/{MealPlanDiningHallID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MealPlanDiningHallItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_meal_plan_free(self, meal_plan_free_id, meal_plan_free_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MealPlanFree in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_meal_plan_free(meal_plan_free_id, meal_plan_free_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_free_id: Numeric value of the mealplanfreeID (required)
        :param MealPlanFreeItem meal_plan_free_item: MealPlanFree to update (required)
        :return: list[MealPlanFreeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_meal_plan_free_with_http_info(meal_plan_free_id, meal_plan_free_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_meal_plan_free_with_http_info(meal_plan_free_id, meal_plan_free_item, **kwargs)  # noqa: E501
            return data

    def update_meal_plan_free_with_http_info(self, meal_plan_free_id, meal_plan_free_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MealPlanFree in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_meal_plan_free_with_http_info(meal_plan_free_id, meal_plan_free_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_free_id: Numeric value of the mealplanfreeID (required)
        :param MealPlanFreeItem meal_plan_free_item: MealPlanFree to update (required)
        :return: list[MealPlanFreeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meal_plan_free_id', 'meal_plan_free_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_meal_plan_free" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'meal_plan_free_id' is set
        if ('meal_plan_free_id' not in params or
                params['meal_plan_free_id'] is None):
            raise ValueError("Missing the required parameter `meal_plan_free_id` when calling `update_meal_plan_free`")  # noqa: E501
        # verify the required parameter 'meal_plan_free_item' is set
        if ('meal_plan_free_item' not in params or
                params['meal_plan_free_item'] is None):
            raise ValueError("Missing the required parameter `meal_plan_free_item` when calling `update_meal_plan_free`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meal_plan_free_id' in params:
            path_params['MealPlanFreeID'] = params['meal_plan_free_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'meal_plan_free_item' in params:
            body_params = params['meal_plan_free_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/MealPlanFree/{MealPlanFreeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MealPlanFreeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_meal_plan_session(self, meal_plan_session_id, meal_plan_session_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MealPlanSession in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_meal_plan_session(meal_plan_session_id, meal_plan_session_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_session_id: Numeric value of the mealplansessionID (required)
        :param MealPlanSessionItem meal_plan_session_item: MealPlanSession to update (required)
        :return: list[MealPlanSessionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_meal_plan_session_with_http_info(meal_plan_session_id, meal_plan_session_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_meal_plan_session_with_http_info(meal_plan_session_id, meal_plan_session_item, **kwargs)  # noqa: E501
            return data

    def update_meal_plan_session_with_http_info(self, meal_plan_session_id, meal_plan_session_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MealPlanSession in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_meal_plan_session_with_http_info(meal_plan_session_id, meal_plan_session_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_plan_session_id: Numeric value of the mealplansessionID (required)
        :param MealPlanSessionItem meal_plan_session_item: MealPlanSession to update (required)
        :return: list[MealPlanSessionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meal_plan_session_id', 'meal_plan_session_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_meal_plan_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'meal_plan_session_id' is set
        if ('meal_plan_session_id' not in params or
                params['meal_plan_session_id'] is None):
            raise ValueError("Missing the required parameter `meal_plan_session_id` when calling `update_meal_plan_session`")  # noqa: E501
        # verify the required parameter 'meal_plan_session_item' is set
        if ('meal_plan_session_item' not in params or
                params['meal_plan_session_item'] is None):
            raise ValueError("Missing the required parameter `meal_plan_session_item` when calling `update_meal_plan_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meal_plan_session_id' in params:
            path_params['MealPlanSessionID'] = params['meal_plan_session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'meal_plan_session_item' in params:
            body_params = params['meal_plan_session_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/MealPlanSession/{MealPlanSessionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MealPlanSessionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_meal_pricing(self, meal_pricing_id, meal_pricing_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MealPricing in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_meal_pricing(meal_pricing_id, meal_pricing_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_pricing_id: Numeric value of the mealpricingID (required)
        :param MealPricingItem meal_pricing_item: MealPricing to update (required)
        :return: list[MealPricingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_meal_pricing_with_http_info(meal_pricing_id, meal_pricing_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_meal_pricing_with_http_info(meal_pricing_id, meal_pricing_item, **kwargs)  # noqa: E501
            return data

    def update_meal_pricing_with_http_info(self, meal_pricing_id, meal_pricing_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MealPricing in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_meal_pricing_with_http_info(meal_pricing_id, meal_pricing_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int meal_pricing_id: Numeric value of the mealpricingID (required)
        :param MealPricingItem meal_pricing_item: MealPricing to update (required)
        :return: list[MealPricingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['meal_pricing_id', 'meal_pricing_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_meal_pricing" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'meal_pricing_id' is set
        if ('meal_pricing_id' not in params or
                params['meal_pricing_id'] is None):
            raise ValueError("Missing the required parameter `meal_pricing_id` when calling `update_meal_pricing`")  # noqa: E501
        # verify the required parameter 'meal_pricing_item' is set
        if ('meal_pricing_item' not in params or
                params['meal_pricing_item'] is None):
            raise ValueError("Missing the required parameter `meal_pricing_item` when calling `update_meal_pricing`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'meal_pricing_id' in params:
            path_params['MealPricingID'] = params['meal_pricing_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'meal_pricing_item' in params:
            body_params = params['meal_pricing_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/MealPricing/{MealPricingID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MealPricingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_membership_type(self, membership_type_id, membership_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MembershipType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_membership_type(membership_type_id, membership_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int membership_type_id: Numeric value of the membershiptypeID (required)
        :param MembershipTypeItem membership_type_item: MembershipType to update (required)
        :return: list[MembershipTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_membership_type_with_http_info(membership_type_id, membership_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_membership_type_with_http_info(membership_type_id, membership_type_item, **kwargs)  # noqa: E501
            return data

    def update_membership_type_with_http_info(self, membership_type_id, membership_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MembershipType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_membership_type_with_http_info(membership_type_id, membership_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int membership_type_id: Numeric value of the membershiptypeID (required)
        :param MembershipTypeItem membership_type_item: MembershipType to update (required)
        :return: list[MembershipTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['membership_type_id', 'membership_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_membership_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'membership_type_id' is set
        if ('membership_type_id' not in params or
                params['membership_type_id'] is None):
            raise ValueError("Missing the required parameter `membership_type_id` when calling `update_membership_type`")  # noqa: E501
        # verify the required parameter 'membership_type_item' is set
        if ('membership_type_item' not in params or
                params['membership_type_item'] is None):
            raise ValueError("Missing the required parameter `membership_type_item` when calling `update_membership_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'membership_type_id' in params:
            path_params['MembershipTypeID'] = params['membership_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'membership_type_item' in params:
            body_params = params['membership_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/MembershipType/{MembershipTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MembershipTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_message(self, message_id, message_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Message in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_message(message_id, message_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_id: Numeric value of the messageID (required)
        :param MessageItem message_item: Message to update (required)
        :return: list[MessageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_message_with_http_info(message_id, message_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_message_with_http_info(message_id, message_item, **kwargs)  # noqa: E501
            return data

    def update_message_with_http_info(self, message_id, message_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Message in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_message_with_http_info(message_id, message_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_id: Numeric value of the messageID (required)
        :param MessageItem message_item: Message to update (required)
        :return: list[MessageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['message_id', 'message_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'message_id' is set
        if ('message_id' not in params or
                params['message_id'] is None):
            raise ValueError("Missing the required parameter `message_id` when calling `update_message`")  # noqa: E501
        # verify the required parameter 'message_item' is set
        if ('message_item' not in params or
                params['message_item'] is None):
            raise ValueError("Missing the required parameter `message_item` when calling `update_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'message_id' in params:
            path_params['MessageID'] = params['message_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'message_item' in params:
            body_params = params['message_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Message/{MessageID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MessageItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_message_action(self, message_action_id, message_action_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MessageAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_message_action(message_action_id, message_action_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_action_id: Numeric value of the messageactionID (required)
        :param MessageActionItem message_action_item: MessageAction to update (required)
        :return: list[MessageActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_message_action_with_http_info(message_action_id, message_action_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_message_action_with_http_info(message_action_id, message_action_item, **kwargs)  # noqa: E501
            return data

    def update_message_action_with_http_info(self, message_action_id, message_action_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MessageAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_message_action_with_http_info(message_action_id, message_action_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_action_id: Numeric value of the messageactionID (required)
        :param MessageActionItem message_action_item: MessageAction to update (required)
        :return: list[MessageActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['message_action_id', 'message_action_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_message_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'message_action_id' is set
        if ('message_action_id' not in params or
                params['message_action_id'] is None):
            raise ValueError("Missing the required parameter `message_action_id` when calling `update_message_action`")  # noqa: E501
        # verify the required parameter 'message_action_item' is set
        if ('message_action_item' not in params or
                params['message_action_item'] is None):
            raise ValueError("Missing the required parameter `message_action_item` when calling `update_message_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'message_action_id' in params:
            path_params['MessageActionID'] = params['message_action_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'message_action_item' in params:
            body_params = params['message_action_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/MessageAction/{MessageActionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MessageActionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_message_subscriber(self, message_subscriber_id, message_subscriber_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MessageSubscriber in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_message_subscriber(message_subscriber_id, message_subscriber_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_subscriber_id: Numeric value of the messagesubscriberID (required)
        :param MessageSubscriberItem message_subscriber_item: MessageSubscriber to update (required)
        :return: list[MessageSubscriberItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_message_subscriber_with_http_info(message_subscriber_id, message_subscriber_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_message_subscriber_with_http_info(message_subscriber_id, message_subscriber_item, **kwargs)  # noqa: E501
            return data

    def update_message_subscriber_with_http_info(self, message_subscriber_id, message_subscriber_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MessageSubscriber in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_message_subscriber_with_http_info(message_subscriber_id, message_subscriber_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_subscriber_id: Numeric value of the messagesubscriberID (required)
        :param MessageSubscriberItem message_subscriber_item: MessageSubscriber to update (required)
        :return: list[MessageSubscriberItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['message_subscriber_id', 'message_subscriber_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_message_subscriber" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'message_subscriber_id' is set
        if ('message_subscriber_id' not in params or
                params['message_subscriber_id'] is None):
            raise ValueError("Missing the required parameter `message_subscriber_id` when calling `update_message_subscriber`")  # noqa: E501
        # verify the required parameter 'message_subscriber_item' is set
        if ('message_subscriber_item' not in params or
                params['message_subscriber_item'] is None):
            raise ValueError("Missing the required parameter `message_subscriber_item` when calling `update_message_subscriber`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'message_subscriber_id' in params:
            path_params['MessageSubscriberID'] = params['message_subscriber_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'message_subscriber_item' in params:
            body_params = params['message_subscriber_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/MessageSubscriber/{MessageSubscriberID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MessageSubscriberItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_message_subscription(self, message_subscription_id, message_subscription_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MessageSubscription in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_message_subscription(message_subscription_id, message_subscription_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_subscription_id: Numeric value of the messagesubscriptionID (required)
        :param MessageSubscriptionItem message_subscription_item: MessageSubscription to update (required)
        :return: list[MessageSubscriptionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_message_subscription_with_http_info(message_subscription_id, message_subscription_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_message_subscription_with_http_info(message_subscription_id, message_subscription_item, **kwargs)  # noqa: E501
            return data

    def update_message_subscription_with_http_info(self, message_subscription_id, message_subscription_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MessageSubscription in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_message_subscription_with_http_info(message_subscription_id, message_subscription_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_subscription_id: Numeric value of the messagesubscriptionID (required)
        :param MessageSubscriptionItem message_subscription_item: MessageSubscription to update (required)
        :return: list[MessageSubscriptionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['message_subscription_id', 'message_subscription_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_message_subscription" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'message_subscription_id' is set
        if ('message_subscription_id' not in params or
                params['message_subscription_id'] is None):
            raise ValueError("Missing the required parameter `message_subscription_id` when calling `update_message_subscription`")  # noqa: E501
        # verify the required parameter 'message_subscription_item' is set
        if ('message_subscription_item' not in params or
                params['message_subscription_item'] is None):
            raise ValueError("Missing the required parameter `message_subscription_item` when calling `update_message_subscription`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'message_subscription_id' in params:
            path_params['MessageSubscriptionID'] = params['message_subscription_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'message_subscription_item' in params:
            body_params = params['message_subscription_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/MessageSubscription/{MessageSubscriptionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MessageSubscriptionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_message_subscription_settings(self, message_subscription_settings_id, message_subscription_settings_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MessageSubscriptionSettings in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_message_subscription_settings(message_subscription_settings_id, message_subscription_settings_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_subscription_settings_id: Numeric value of the messagesubscriptionsettingsID (required)
        :param MessageSubscriptionSettingsItem message_subscription_settings_item: MessageSubscriptionSettings to update (required)
        :return: list[MessageSubscriptionSettingsItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_message_subscription_settings_with_http_info(message_subscription_settings_id, message_subscription_settings_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_message_subscription_settings_with_http_info(message_subscription_settings_id, message_subscription_settings_item, **kwargs)  # noqa: E501
            return data

    def update_message_subscription_settings_with_http_info(self, message_subscription_settings_id, message_subscription_settings_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an MessageSubscriptionSettings in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_message_subscription_settings_with_http_info(message_subscription_settings_id, message_subscription_settings_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int message_subscription_settings_id: Numeric value of the messagesubscriptionsettingsID (required)
        :param MessageSubscriptionSettingsItem message_subscription_settings_item: MessageSubscriptionSettings to update (required)
        :return: list[MessageSubscriptionSettingsItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['message_subscription_settings_id', 'message_subscription_settings_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_message_subscription_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'message_subscription_settings_id' is set
        if ('message_subscription_settings_id' not in params or
                params['message_subscription_settings_id'] is None):
            raise ValueError("Missing the required parameter `message_subscription_settings_id` when calling `update_message_subscription_settings`")  # noqa: E501
        # verify the required parameter 'message_subscription_settings_item' is set
        if ('message_subscription_settings_item' not in params or
                params['message_subscription_settings_item'] is None):
            raise ValueError("Missing the required parameter `message_subscription_settings_item` when calling `update_message_subscription_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'message_subscription_settings_id' in params:
            path_params['MessageSubscriptionSettingsID'] = params['message_subscription_settings_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'message_subscription_settings_item' in params:
            body_params = params['message_subscription_settings_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/MessageSubscriptionSettings/{MessageSubscriptionSettingsID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MessageSubscriptionSettingsItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_nationality(self, nationality_id, nationality_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Nationality in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_nationality(nationality_id, nationality_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int nationality_id: Numeric value of the nationalityID (required)
        :param NationalityItem nationality_item: Nationality to update (required)
        :return: list[NationalityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_nationality_with_http_info(nationality_id, nationality_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_nationality_with_http_info(nationality_id, nationality_item, **kwargs)  # noqa: E501
            return data

    def update_nationality_with_http_info(self, nationality_id, nationality_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Nationality in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_nationality_with_http_info(nationality_id, nationality_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int nationality_id: Numeric value of the nationalityID (required)
        :param NationalityItem nationality_item: Nationality to update (required)
        :return: list[NationalityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['nationality_id', 'nationality_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_nationality" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'nationality_id' is set
        if ('nationality_id' not in params or
                params['nationality_id'] is None):
            raise ValueError("Missing the required parameter `nationality_id` when calling `update_nationality`")  # noqa: E501
        # verify the required parameter 'nationality_item' is set
        if ('nationality_item' not in params or
                params['nationality_item'] is None):
            raise ValueError("Missing the required parameter `nationality_item` when calling `update_nationality`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'nationality_id' in params:
            path_params['NationalityID'] = params['nationality_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'nationality_item' in params:
            body_params = params['nationality_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Nationality/{NationalityID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NationalityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_note_type(self, note_type_id, note_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an NoteType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_note_type(note_type_id, note_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int note_type_id: Numeric value of the notetypeID (required)
        :param NoteTypeItem note_type_item: NoteType to update (required)
        :return: list[NoteTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_note_type_with_http_info(note_type_id, note_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_note_type_with_http_info(note_type_id, note_type_item, **kwargs)  # noqa: E501
            return data

    def update_note_type_with_http_info(self, note_type_id, note_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an NoteType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_note_type_with_http_info(note_type_id, note_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int note_type_id: Numeric value of the notetypeID (required)
        :param NoteTypeItem note_type_item: NoteType to update (required)
        :return: list[NoteTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['note_type_id', 'note_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_note_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'note_type_id' is set
        if ('note_type_id' not in params or
                params['note_type_id'] is None):
            raise ValueError("Missing the required parameter `note_type_id` when calling `update_note_type`")  # noqa: E501
        # verify the required parameter 'note_type_item' is set
        if ('note_type_item' not in params or
                params['note_type_item'] is None):
            raise ValueError("Missing the required parameter `note_type_item` when calling `update_note_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'note_type_id' in params:
            path_params['NoteTypeID'] = params['note_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'note_type_item' in params:
            body_params = params['note_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/NoteType/{NoteTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NoteTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_parcel_type(self, parcel_type_id, parcel_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ParcelType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_parcel_type(parcel_type_id, parcel_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int parcel_type_id: Numeric value of the parceltypeID (required)
        :param ParcelTypeItem parcel_type_item: ParcelType to update (required)
        :return: list[ParcelTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_parcel_type_with_http_info(parcel_type_id, parcel_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_parcel_type_with_http_info(parcel_type_id, parcel_type_item, **kwargs)  # noqa: E501
            return data

    def update_parcel_type_with_http_info(self, parcel_type_id, parcel_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ParcelType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_parcel_type_with_http_info(parcel_type_id, parcel_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int parcel_type_id: Numeric value of the parceltypeID (required)
        :param ParcelTypeItem parcel_type_item: ParcelType to update (required)
        :return: list[ParcelTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['parcel_type_id', 'parcel_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_parcel_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'parcel_type_id' is set
        if ('parcel_type_id' not in params or
                params['parcel_type_id'] is None):
            raise ValueError("Missing the required parameter `parcel_type_id` when calling `update_parcel_type`")  # noqa: E501
        # verify the required parameter 'parcel_type_item' is set
        if ('parcel_type_item' not in params or
                params['parcel_type_item'] is None):
            raise ValueError("Missing the required parameter `parcel_type_item` when calling `update_parcel_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'parcel_type_id' in params:
            path_params['ParcelTypeID'] = params['parcel_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'parcel_type_item' in params:
            body_params = params['parcel_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ParcelType/{ParcelTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ParcelTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_payment(self, payment_id, payment_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Payment in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_payment(payment_id, payment_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int payment_id: Numeric value of the paymentID (required)
        :param PaymentItem payment_item: Payment to update (required)
        :return: list[PaymentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_payment_with_http_info(payment_id, payment_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_payment_with_http_info(payment_id, payment_item, **kwargs)  # noqa: E501
            return data

    def update_payment_with_http_info(self, payment_id, payment_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Payment in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_payment_with_http_info(payment_id, payment_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int payment_id: Numeric value of the paymentID (required)
        :param PaymentItem payment_item: Payment to update (required)
        :return: list[PaymentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payment_id', 'payment_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_payment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payment_id' is set
        if ('payment_id' not in params or
                params['payment_id'] is None):
            raise ValueError("Missing the required parameter `payment_id` when calling `update_payment`")  # noqa: E501
        # verify the required parameter 'payment_item' is set
        if ('payment_item' not in params or
                params['payment_item'] is None):
            raise ValueError("Missing the required parameter `payment_item` when calling `update_payment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'payment_id' in params:
            path_params['PaymentID'] = params['payment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payment_item' in params:
            body_params = params['payment_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Payment/{PaymentID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PaymentItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_payment_type(self, payment_type_id, payment_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PaymentType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_payment_type(payment_type_id, payment_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int payment_type_id: Numeric value of the paymenttypeID (required)
        :param PaymentTypeItem payment_type_item: PaymentType to update (required)
        :return: list[PaymentTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_payment_type_with_http_info(payment_type_id, payment_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_payment_type_with_http_info(payment_type_id, payment_type_item, **kwargs)  # noqa: E501
            return data

    def update_payment_type_with_http_info(self, payment_type_id, payment_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PaymentType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_payment_type_with_http_info(payment_type_id, payment_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int payment_type_id: Numeric value of the paymenttypeID (required)
        :param PaymentTypeItem payment_type_item: PaymentType to update (required)
        :return: list[PaymentTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['payment_type_id', 'payment_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_payment_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'payment_type_id' is set
        if ('payment_type_id' not in params or
                params['payment_type_id'] is None):
            raise ValueError("Missing the required parameter `payment_type_id` when calling `update_payment_type`")  # noqa: E501
        # verify the required parameter 'payment_type_item' is set
        if ('payment_type_item' not in params or
                params['payment_type_item'] is None):
            raise ValueError("Missing the required parameter `payment_type_item` when calling `update_payment_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'payment_type_id' in params:
            path_params['PaymentTypeID'] = params['payment_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'payment_type_item' in params:
            body_params = params['payment_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PaymentType/{PaymentTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PaymentTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_phone_charge_type(self, phone_charge_type_id, phone_charge_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PhoneChargeType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_phone_charge_type(phone_charge_type_id, phone_charge_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int phone_charge_type_id: Numeric value of the phonechargetypeID (required)
        :param PhoneChargeTypeItem phone_charge_type_item: PhoneChargeType to update (required)
        :return: list[PhoneChargeTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_phone_charge_type_with_http_info(phone_charge_type_id, phone_charge_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_phone_charge_type_with_http_info(phone_charge_type_id, phone_charge_type_item, **kwargs)  # noqa: E501
            return data

    def update_phone_charge_type_with_http_info(self, phone_charge_type_id, phone_charge_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PhoneChargeType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_phone_charge_type_with_http_info(phone_charge_type_id, phone_charge_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int phone_charge_type_id: Numeric value of the phonechargetypeID (required)
        :param PhoneChargeTypeItem phone_charge_type_item: PhoneChargeType to update (required)
        :return: list[PhoneChargeTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['phone_charge_type_id', 'phone_charge_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_phone_charge_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'phone_charge_type_id' is set
        if ('phone_charge_type_id' not in params or
                params['phone_charge_type_id'] is None):
            raise ValueError("Missing the required parameter `phone_charge_type_id` when calling `update_phone_charge_type`")  # noqa: E501
        # verify the required parameter 'phone_charge_type_item' is set
        if ('phone_charge_type_item' not in params or
                params['phone_charge_type_item'] is None):
            raise ValueError("Missing the required parameter `phone_charge_type_item` when calling `update_phone_charge_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'phone_charge_type_id' in params:
            path_params['PhoneChargeTypeID'] = params['phone_charge_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'phone_charge_type_item' in params:
            body_params = params['phone_charge_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PhoneChargeType/{PhoneChargeTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PhoneChargeTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_phone_charge_type_call_type(self, phone_charge_type_call_type_id, phone_charge_type_call_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PhoneChargeTypeCallType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_phone_charge_type_call_type(phone_charge_type_call_type_id, phone_charge_type_call_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int phone_charge_type_call_type_id: Numeric value of the phonechargetypecalltypeID (required)
        :param PhoneChargeTypeCallTypeItem phone_charge_type_call_type_item: PhoneChargeTypeCallType to update (required)
        :return: list[PhoneChargeTypeCallTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_phone_charge_type_call_type_with_http_info(phone_charge_type_call_type_id, phone_charge_type_call_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_phone_charge_type_call_type_with_http_info(phone_charge_type_call_type_id, phone_charge_type_call_type_item, **kwargs)  # noqa: E501
            return data

    def update_phone_charge_type_call_type_with_http_info(self, phone_charge_type_call_type_id, phone_charge_type_call_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PhoneChargeTypeCallType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_phone_charge_type_call_type_with_http_info(phone_charge_type_call_type_id, phone_charge_type_call_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int phone_charge_type_call_type_id: Numeric value of the phonechargetypecalltypeID (required)
        :param PhoneChargeTypeCallTypeItem phone_charge_type_call_type_item: PhoneChargeTypeCallType to update (required)
        :return: list[PhoneChargeTypeCallTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['phone_charge_type_call_type_id', 'phone_charge_type_call_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_phone_charge_type_call_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'phone_charge_type_call_type_id' is set
        if ('phone_charge_type_call_type_id' not in params or
                params['phone_charge_type_call_type_id'] is None):
            raise ValueError("Missing the required parameter `phone_charge_type_call_type_id` when calling `update_phone_charge_type_call_type`")  # noqa: E501
        # verify the required parameter 'phone_charge_type_call_type_item' is set
        if ('phone_charge_type_call_type_item' not in params or
                params['phone_charge_type_call_type_item'] is None):
            raise ValueError("Missing the required parameter `phone_charge_type_call_type_item` when calling `update_phone_charge_type_call_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'phone_charge_type_call_type_id' in params:
            path_params['PhoneChargeTypeCallTypeID'] = params['phone_charge_type_call_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'phone_charge_type_call_type_item' in params:
            body_params = params['phone_charge_type_call_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PhoneChargeTypeCallType/{PhoneChargeTypeCallTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PhoneChargeTypeCallTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portal_action(self, portal_action_id, portal_action_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_action(portal_action_id, portal_action_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_action_id: Numeric value of the portalactionID (required)
        :param PortalActionItem portal_action_item: PortalAction to update (required)
        :return: list[PortalActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_portal_action_with_http_info(portal_action_id, portal_action_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portal_action_with_http_info(portal_action_id, portal_action_item, **kwargs)  # noqa: E501
            return data

    def update_portal_action_with_http_info(self, portal_action_id, portal_action_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_action_with_http_info(portal_action_id, portal_action_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_action_id: Numeric value of the portalactionID (required)
        :param PortalActionItem portal_action_item: PortalAction to update (required)
        :return: list[PortalActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_action_id', 'portal_action_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portal_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portal_action_id' is set
        if ('portal_action_id' not in params or
                params['portal_action_id'] is None):
            raise ValueError("Missing the required parameter `portal_action_id` when calling `update_portal_action`")  # noqa: E501
        # verify the required parameter 'portal_action_item' is set
        if ('portal_action_item' not in params or
                params['portal_action_item'] is None):
            raise ValueError("Missing the required parameter `portal_action_item` when calling `update_portal_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portal_action_id' in params:
            path_params['PortalActionID'] = params['portal_action_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'portal_action_item' in params:
            body_params = params['portal_action_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PortalAction/{PortalActionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalActionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portal_activity(self, portal_activity_id, portal_activity_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalActivity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_activity(portal_activity_id, portal_activity_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_activity_id: Numeric value of the portalactivityID (required)
        :param PortalActivityItem portal_activity_item: PortalActivity to update (required)
        :return: list[PortalActivityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_portal_activity_with_http_info(portal_activity_id, portal_activity_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portal_activity_with_http_info(portal_activity_id, portal_activity_item, **kwargs)  # noqa: E501
            return data

    def update_portal_activity_with_http_info(self, portal_activity_id, portal_activity_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalActivity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_activity_with_http_info(portal_activity_id, portal_activity_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_activity_id: Numeric value of the portalactivityID (required)
        :param PortalActivityItem portal_activity_item: PortalActivity to update (required)
        :return: list[PortalActivityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_activity_id', 'portal_activity_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portal_activity" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portal_activity_id' is set
        if ('portal_activity_id' not in params or
                params['portal_activity_id'] is None):
            raise ValueError("Missing the required parameter `portal_activity_id` when calling `update_portal_activity`")  # noqa: E501
        # verify the required parameter 'portal_activity_item' is set
        if ('portal_activity_item' not in params or
                params['portal_activity_item'] is None):
            raise ValueError("Missing the required parameter `portal_activity_item` when calling `update_portal_activity`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portal_activity_id' in params:
            path_params['PortalActivityID'] = params['portal_activity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'portal_activity_item' in params:
            body_params = params['portal_activity_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PortalActivity/{PortalActivityID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalActivityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portal_choice(self, portal_choice_id, portal_choice_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalChoice in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_choice(portal_choice_id, portal_choice_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_choice_id: Numeric value of the portalchoiceID (required)
        :param PortalChoiceItem portal_choice_item: PortalChoice to update (required)
        :return: list[PortalChoiceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_portal_choice_with_http_info(portal_choice_id, portal_choice_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portal_choice_with_http_info(portal_choice_id, portal_choice_item, **kwargs)  # noqa: E501
            return data

    def update_portal_choice_with_http_info(self, portal_choice_id, portal_choice_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalChoice in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_choice_with_http_info(portal_choice_id, portal_choice_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_choice_id: Numeric value of the portalchoiceID (required)
        :param PortalChoiceItem portal_choice_item: PortalChoice to update (required)
        :return: list[PortalChoiceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_choice_id', 'portal_choice_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portal_choice" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portal_choice_id' is set
        if ('portal_choice_id' not in params or
                params['portal_choice_id'] is None):
            raise ValueError("Missing the required parameter `portal_choice_id` when calling `update_portal_choice`")  # noqa: E501
        # verify the required parameter 'portal_choice_item' is set
        if ('portal_choice_item' not in params or
                params['portal_choice_item'] is None):
            raise ValueError("Missing the required parameter `portal_choice_item` when calling `update_portal_choice`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portal_choice_id' in params:
            path_params['PortalChoiceID'] = params['portal_choice_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'portal_choice_item' in params:
            body_params = params['portal_choice_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PortalChoice/{PortalChoiceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalChoiceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portal_page(self, portal_page_id, portal_page_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalPage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_page(portal_page_id, portal_page_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_page_id: Numeric value of the portalpageID (required)
        :param PortalPageItem portal_page_item: PortalPage to update (required)
        :return: list[PortalPageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_portal_page_with_http_info(portal_page_id, portal_page_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portal_page_with_http_info(portal_page_id, portal_page_item, **kwargs)  # noqa: E501
            return data

    def update_portal_page_with_http_info(self, portal_page_id, portal_page_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalPage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_page_with_http_info(portal_page_id, portal_page_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_page_id: Numeric value of the portalpageID (required)
        :param PortalPageItem portal_page_item: PortalPage to update (required)
        :return: list[PortalPageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_page_id', 'portal_page_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portal_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portal_page_id' is set
        if ('portal_page_id' not in params or
                params['portal_page_id'] is None):
            raise ValueError("Missing the required parameter `portal_page_id` when calling `update_portal_page`")  # noqa: E501
        # verify the required parameter 'portal_page_item' is set
        if ('portal_page_item' not in params or
                params['portal_page_item'] is None):
            raise ValueError("Missing the required parameter `portal_page_item` when calling `update_portal_page`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portal_page_id' in params:
            path_params['PortalPageID'] = params['portal_page_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'portal_page_item' in params:
            body_params = params['portal_page_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PortalPage/{PortalPageID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalPageItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portal_page_action(self, portal_page_action_id, portal_page_action_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalPageAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_page_action(portal_page_action_id, portal_page_action_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_page_action_id: Numeric value of the portalpageactionID (required)
        :param PortalPageActionItem portal_page_action_item: PortalPageAction to update (required)
        :return: list[PortalPageActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_portal_page_action_with_http_info(portal_page_action_id, portal_page_action_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portal_page_action_with_http_info(portal_page_action_id, portal_page_action_item, **kwargs)  # noqa: E501
            return data

    def update_portal_page_action_with_http_info(self, portal_page_action_id, portal_page_action_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalPageAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_page_action_with_http_info(portal_page_action_id, portal_page_action_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_page_action_id: Numeric value of the portalpageactionID (required)
        :param PortalPageActionItem portal_page_action_item: PortalPageAction to update (required)
        :return: list[PortalPageActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_page_action_id', 'portal_page_action_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portal_page_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portal_page_action_id' is set
        if ('portal_page_action_id' not in params or
                params['portal_page_action_id'] is None):
            raise ValueError("Missing the required parameter `portal_page_action_id` when calling `update_portal_page_action`")  # noqa: E501
        # verify the required parameter 'portal_page_action_item' is set
        if ('portal_page_action_item' not in params or
                params['portal_page_action_item'] is None):
            raise ValueError("Missing the required parameter `portal_page_action_item` when calling `update_portal_page_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portal_page_action_id' in params:
            path_params['PortalPageActionID'] = params['portal_page_action_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'portal_page_action_item' in params:
            body_params = params['portal_page_action_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PortalPageAction/{PortalPageActionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalPageActionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portal_page_widget(self, portal_page_widget_id, portal_page_widget_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalPageWidget in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_page_widget(portal_page_widget_id, portal_page_widget_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_page_widget_id: Numeric value of the portalpagewidgetID (required)
        :param PortalPageWidgetItem portal_page_widget_item: PortalPageWidget to update (required)
        :return: list[PortalPageWidgetItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_portal_page_widget_with_http_info(portal_page_widget_id, portal_page_widget_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portal_page_widget_with_http_info(portal_page_widget_id, portal_page_widget_item, **kwargs)  # noqa: E501
            return data

    def update_portal_page_widget_with_http_info(self, portal_page_widget_id, portal_page_widget_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalPageWidget in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_page_widget_with_http_info(portal_page_widget_id, portal_page_widget_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_page_widget_id: Numeric value of the portalpagewidgetID (required)
        :param PortalPageWidgetItem portal_page_widget_item: PortalPageWidget to update (required)
        :return: list[PortalPageWidgetItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_page_widget_id', 'portal_page_widget_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portal_page_widget" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portal_page_widget_id' is set
        if ('portal_page_widget_id' not in params or
                params['portal_page_widget_id'] is None):
            raise ValueError("Missing the required parameter `portal_page_widget_id` when calling `update_portal_page_widget`")  # noqa: E501
        # verify the required parameter 'portal_page_widget_item' is set
        if ('portal_page_widget_item' not in params or
                params['portal_page_widget_item'] is None):
            raise ValueError("Missing the required parameter `portal_page_widget_item` when calling `update_portal_page_widget`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portal_page_widget_id' in params:
            path_params['PortalPageWidgetID'] = params['portal_page_widget_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'portal_page_widget_item' in params:
            body_params = params['portal_page_widget_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PortalPageWidget/{PortalPageWidgetID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalPageWidgetItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portal_process(self, portal_process_id, portal_process_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalProcess in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_process(portal_process_id, portal_process_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_process_id: Numeric value of the portalprocessID (required)
        :param PortalProcessItem portal_process_item: PortalProcess to update (required)
        :return: list[PortalProcessItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_portal_process_with_http_info(portal_process_id, portal_process_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portal_process_with_http_info(portal_process_id, portal_process_item, **kwargs)  # noqa: E501
            return data

    def update_portal_process_with_http_info(self, portal_process_id, portal_process_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalProcess in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_process_with_http_info(portal_process_id, portal_process_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_process_id: Numeric value of the portalprocessID (required)
        :param PortalProcessItem portal_process_item: PortalProcess to update (required)
        :return: list[PortalProcessItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_process_id', 'portal_process_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portal_process" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portal_process_id' is set
        if ('portal_process_id' not in params or
                params['portal_process_id'] is None):
            raise ValueError("Missing the required parameter `portal_process_id` when calling `update_portal_process`")  # noqa: E501
        # verify the required parameter 'portal_process_item' is set
        if ('portal_process_item' not in params or
                params['portal_process_item'] is None):
            raise ValueError("Missing the required parameter `portal_process_item` when calling `update_portal_process`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portal_process_id' in params:
            path_params['PortalProcessID'] = params['portal_process_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'portal_process_item' in params:
            body_params = params['portal_process_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PortalProcess/{PortalProcessID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalProcessItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portal_rule(self, portal_rule_id, portal_rule_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalRule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_rule(portal_rule_id, portal_rule_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_rule_id: Numeric value of the portalruleID (required)
        :param PortalRuleItem portal_rule_item: PortalRule to update (required)
        :return: list[PortalRuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_portal_rule_with_http_info(portal_rule_id, portal_rule_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portal_rule_with_http_info(portal_rule_id, portal_rule_item, **kwargs)  # noqa: E501
            return data

    def update_portal_rule_with_http_info(self, portal_rule_id, portal_rule_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalRule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_rule_with_http_info(portal_rule_id, portal_rule_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_rule_id: Numeric value of the portalruleID (required)
        :param PortalRuleItem portal_rule_item: PortalRule to update (required)
        :return: list[PortalRuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_rule_id', 'portal_rule_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portal_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portal_rule_id' is set
        if ('portal_rule_id' not in params or
                params['portal_rule_id'] is None):
            raise ValueError("Missing the required parameter `portal_rule_id` when calling `update_portal_rule`")  # noqa: E501
        # verify the required parameter 'portal_rule_item' is set
        if ('portal_rule_item' not in params or
                params['portal_rule_item'] is None):
            raise ValueError("Missing the required parameter `portal_rule_item` when calling `update_portal_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portal_rule_id' in params:
            path_params['PortalRuleID'] = params['portal_rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'portal_rule_item' in params:
            body_params = params['portal_rule_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PortalRule/{PortalRuleID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalRuleItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portal_rule_link(self, portal_rule_link_id, portal_rule_link_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalRuleLink in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_rule_link(portal_rule_link_id, portal_rule_link_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_rule_link_id: Numeric value of the portalrulelinkID (required)
        :param PortalRuleLinkItem portal_rule_link_item: PortalRuleLink to update (required)
        :return: list[PortalRuleLinkItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_portal_rule_link_with_http_info(portal_rule_link_id, portal_rule_link_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portal_rule_link_with_http_info(portal_rule_link_id, portal_rule_link_item, **kwargs)  # noqa: E501
            return data

    def update_portal_rule_link_with_http_info(self, portal_rule_link_id, portal_rule_link_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalRuleLink in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_rule_link_with_http_info(portal_rule_link_id, portal_rule_link_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_rule_link_id: Numeric value of the portalrulelinkID (required)
        :param PortalRuleLinkItem portal_rule_link_item: PortalRuleLink to update (required)
        :return: list[PortalRuleLinkItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_rule_link_id', 'portal_rule_link_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portal_rule_link" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portal_rule_link_id' is set
        if ('portal_rule_link_id' not in params or
                params['portal_rule_link_id'] is None):
            raise ValueError("Missing the required parameter `portal_rule_link_id` when calling `update_portal_rule_link`")  # noqa: E501
        # verify the required parameter 'portal_rule_link_item' is set
        if ('portal_rule_link_item' not in params or
                params['portal_rule_link_item'] is None):
            raise ValueError("Missing the required parameter `portal_rule_link_item` when calling `update_portal_rule_link`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portal_rule_link_id' in params:
            path_params['PortalRuleLinkID'] = params['portal_rule_link_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'portal_rule_link_item' in params:
            body_params = params['portal_rule_link_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PortalRuleLink/{PortalRuleLinkID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalRuleLinkItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portal_setting(self, portal_setting_id, portal_setting_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalSetting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_setting(portal_setting_id, portal_setting_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_setting_id: Numeric value of the portalsettingID (required)
        :param PortalSettingItem portal_setting_item: PortalSetting to update (required)
        :return: list[PortalSettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_portal_setting_with_http_info(portal_setting_id, portal_setting_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portal_setting_with_http_info(portal_setting_id, portal_setting_item, **kwargs)  # noqa: E501
            return data

    def update_portal_setting_with_http_info(self, portal_setting_id, portal_setting_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalSetting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_setting_with_http_info(portal_setting_id, portal_setting_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_setting_id: Numeric value of the portalsettingID (required)
        :param PortalSettingItem portal_setting_item: PortalSetting to update (required)
        :return: list[PortalSettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_setting_id', 'portal_setting_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portal_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portal_setting_id' is set
        if ('portal_setting_id' not in params or
                params['portal_setting_id'] is None):
            raise ValueError("Missing the required parameter `portal_setting_id` when calling `update_portal_setting`")  # noqa: E501
        # verify the required parameter 'portal_setting_item' is set
        if ('portal_setting_item' not in params or
                params['portal_setting_item'] is None):
            raise ValueError("Missing the required parameter `portal_setting_item` when calling `update_portal_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portal_setting_id' in params:
            path_params['PortalSettingID'] = params['portal_setting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'portal_setting_item' in params:
            body_params = params['portal_setting_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PortalSetting/{PortalSettingID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalSettingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portal_site(self, portal_site_id, portal_site_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalSite in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_site(portal_site_id, portal_site_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_site_id: Numeric value of the portalsiteID (required)
        :param PortalSiteItem portal_site_item: PortalSite to update (required)
        :return: list[PortalSiteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_portal_site_with_http_info(portal_site_id, portal_site_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portal_site_with_http_info(portal_site_id, portal_site_item, **kwargs)  # noqa: E501
            return data

    def update_portal_site_with_http_info(self, portal_site_id, portal_site_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalSite in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_site_with_http_info(portal_site_id, portal_site_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_site_id: Numeric value of the portalsiteID (required)
        :param PortalSiteItem portal_site_item: PortalSite to update (required)
        :return: list[PortalSiteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_site_id', 'portal_site_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portal_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portal_site_id' is set
        if ('portal_site_id' not in params or
                params['portal_site_id'] is None):
            raise ValueError("Missing the required parameter `portal_site_id` when calling `update_portal_site`")  # noqa: E501
        # verify the required parameter 'portal_site_item' is set
        if ('portal_site_item' not in params or
                params['portal_site_item'] is None):
            raise ValueError("Missing the required parameter `portal_site_item` when calling `update_portal_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portal_site_id' in params:
            path_params['PortalSiteID'] = params['portal_site_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'portal_site_item' in params:
            body_params = params['portal_site_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PortalSite/{PortalSiteID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalSiteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portal_step(self, portal_step_id, portal_step_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalStep in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_step(portal_step_id, portal_step_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_step_id: Numeric value of the portalstepID (required)
        :param PortalStepItem portal_step_item: PortalStep to update (required)
        :return: list[PortalStepItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_portal_step_with_http_info(portal_step_id, portal_step_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portal_step_with_http_info(portal_step_id, portal_step_item, **kwargs)  # noqa: E501
            return data

    def update_portal_step_with_http_info(self, portal_step_id, portal_step_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalStep in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_step_with_http_info(portal_step_id, portal_step_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_step_id: Numeric value of the portalstepID (required)
        :param PortalStepItem portal_step_item: PortalStep to update (required)
        :return: list[PortalStepItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_step_id', 'portal_step_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portal_step" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portal_step_id' is set
        if ('portal_step_id' not in params or
                params['portal_step_id'] is None):
            raise ValueError("Missing the required parameter `portal_step_id` when calling `update_portal_step`")  # noqa: E501
        # verify the required parameter 'portal_step_item' is set
        if ('portal_step_item' not in params or
                params['portal_step_item'] is None):
            raise ValueError("Missing the required parameter `portal_step_item` when calling `update_portal_step`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portal_step_id' in params:
            path_params['PortalStepID'] = params['portal_step_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'portal_step_item' in params:
            body_params = params['portal_step_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PortalStep/{PortalStepID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalStepItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portal_step_link(self, portal_step_link_id, portal_step_link_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalStepLink in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_step_link(portal_step_link_id, portal_step_link_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_step_link_id: Numeric value of the portalsteplinkID (required)
        :param PortalStepLinkItem portal_step_link_item: PortalStepLink to update (required)
        :return: list[PortalStepLinkItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_portal_step_link_with_http_info(portal_step_link_id, portal_step_link_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portal_step_link_with_http_info(portal_step_link_id, portal_step_link_item, **kwargs)  # noqa: E501
            return data

    def update_portal_step_link_with_http_info(self, portal_step_link_id, portal_step_link_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalStepLink in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_step_link_with_http_info(portal_step_link_id, portal_step_link_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_step_link_id: Numeric value of the portalsteplinkID (required)
        :param PortalStepLinkItem portal_step_link_item: PortalStepLink to update (required)
        :return: list[PortalStepLinkItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_step_link_id', 'portal_step_link_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portal_step_link" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portal_step_link_id' is set
        if ('portal_step_link_id' not in params or
                params['portal_step_link_id'] is None):
            raise ValueError("Missing the required parameter `portal_step_link_id` when calling `update_portal_step_link`")  # noqa: E501
        # verify the required parameter 'portal_step_link_item' is set
        if ('portal_step_link_item' not in params or
                params['portal_step_link_item'] is None):
            raise ValueError("Missing the required parameter `portal_step_link_item` when calling `update_portal_step_link`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portal_step_link_id' in params:
            path_params['PortalStepLinkID'] = params['portal_step_link_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'portal_step_link_item' in params:
            body_params = params['portal_step_link_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PortalStepLink/{PortalStepLinkID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalStepLinkItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portal_theme(self, portal_theme_id, portal_theme_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalTheme in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_theme(portal_theme_id, portal_theme_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_theme_id: Numeric value of the portalthemeID (required)
        :param PortalThemeItem portal_theme_item: PortalTheme to update (required)
        :return: list[PortalThemeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_portal_theme_with_http_info(portal_theme_id, portal_theme_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portal_theme_with_http_info(portal_theme_id, portal_theme_item, **kwargs)  # noqa: E501
            return data

    def update_portal_theme_with_http_info(self, portal_theme_id, portal_theme_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalTheme in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_theme_with_http_info(portal_theme_id, portal_theme_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_theme_id: Numeric value of the portalthemeID (required)
        :param PortalThemeItem portal_theme_item: PortalTheme to update (required)
        :return: list[PortalThemeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_theme_id', 'portal_theme_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portal_theme" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portal_theme_id' is set
        if ('portal_theme_id' not in params or
                params['portal_theme_id'] is None):
            raise ValueError("Missing the required parameter `portal_theme_id` when calling `update_portal_theme`")  # noqa: E501
        # verify the required parameter 'portal_theme_item' is set
        if ('portal_theme_item' not in params or
                params['portal_theme_item'] is None):
            raise ValueError("Missing the required parameter `portal_theme_item` when calling `update_portal_theme`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portal_theme_id' in params:
            path_params['PortalThemeID'] = params['portal_theme_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'portal_theme_item' in params:
            body_params = params['portal_theme_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PortalTheme/{PortalThemeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalThemeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portal_user_hold(self, portal_user_hold_id, portal_user_hold_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalUserHold in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_user_hold(portal_user_hold_id, portal_user_hold_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_user_hold_id: Numeric value of the portaluserholdID (required)
        :param PortalUserHoldItem portal_user_hold_item: PortalUserHold to update (required)
        :return: list[PortalUserHoldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_portal_user_hold_with_http_info(portal_user_hold_id, portal_user_hold_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portal_user_hold_with_http_info(portal_user_hold_id, portal_user_hold_item, **kwargs)  # noqa: E501
            return data

    def update_portal_user_hold_with_http_info(self, portal_user_hold_id, portal_user_hold_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalUserHold in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_user_hold_with_http_info(portal_user_hold_id, portal_user_hold_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_user_hold_id: Numeric value of the portaluserholdID (required)
        :param PortalUserHoldItem portal_user_hold_item: PortalUserHold to update (required)
        :return: list[PortalUserHoldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_user_hold_id', 'portal_user_hold_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portal_user_hold" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portal_user_hold_id' is set
        if ('portal_user_hold_id' not in params or
                params['portal_user_hold_id'] is None):
            raise ValueError("Missing the required parameter `portal_user_hold_id` when calling `update_portal_user_hold`")  # noqa: E501
        # verify the required parameter 'portal_user_hold_item' is set
        if ('portal_user_hold_item' not in params or
                params['portal_user_hold_item'] is None):
            raise ValueError("Missing the required parameter `portal_user_hold_item` when calling `update_portal_user_hold`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portal_user_hold_id' in params:
            path_params['PortalUserHoldID'] = params['portal_user_hold_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'portal_user_hold_item' in params:
            body_params = params['portal_user_hold_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PortalUserHold/{PortalUserHoldID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalUserHoldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portal_user_signature(self, portal_user_signature_id, portal_user_signature_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalUserSignature in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_user_signature(portal_user_signature_id, portal_user_signature_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_user_signature_id: Numeric value of the portalusersignatureID (required)
        :param PortalUserSignatureItem portal_user_signature_item: PortalUserSignature to update (required)
        :return: list[PortalUserSignatureItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_portal_user_signature_with_http_info(portal_user_signature_id, portal_user_signature_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portal_user_signature_with_http_info(portal_user_signature_id, portal_user_signature_item, **kwargs)  # noqa: E501
            return data

    def update_portal_user_signature_with_http_info(self, portal_user_signature_id, portal_user_signature_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalUserSignature in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_user_signature_with_http_info(portal_user_signature_id, portal_user_signature_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_user_signature_id: Numeric value of the portalusersignatureID (required)
        :param PortalUserSignatureItem portal_user_signature_item: PortalUserSignature to update (required)
        :return: list[PortalUserSignatureItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_user_signature_id', 'portal_user_signature_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portal_user_signature" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portal_user_signature_id' is set
        if ('portal_user_signature_id' not in params or
                params['portal_user_signature_id'] is None):
            raise ValueError("Missing the required parameter `portal_user_signature_id` when calling `update_portal_user_signature`")  # noqa: E501
        # verify the required parameter 'portal_user_signature_item' is set
        if ('portal_user_signature_item' not in params or
                params['portal_user_signature_item'] is None):
            raise ValueError("Missing the required parameter `portal_user_signature_item` when calling `update_portal_user_signature`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portal_user_signature_id' in params:
            path_params['PortalUserSignatureID'] = params['portal_user_signature_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'portal_user_signature_item' in params:
            body_params = params['portal_user_signature_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PortalUserSignature/{PortalUserSignatureID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalUserSignatureItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_portal_user_token(self, portal_user_token_id, portal_user_token_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalUserToken in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_user_token(portal_user_token_id, portal_user_token_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_user_token_id: Numeric value of the portalusertokenID (required)
        :param PortalUserTokenItem portal_user_token_item: PortalUserToken to update (required)
        :return: list[PortalUserTokenItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_portal_user_token_with_http_info(portal_user_token_id, portal_user_token_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_portal_user_token_with_http_info(portal_user_token_id, portal_user_token_item, **kwargs)  # noqa: E501
            return data

    def update_portal_user_token_with_http_info(self, portal_user_token_id, portal_user_token_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PortalUserToken in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_portal_user_token_with_http_info(portal_user_token_id, portal_user_token_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int portal_user_token_id: Numeric value of the portalusertokenID (required)
        :param PortalUserTokenItem portal_user_token_item: PortalUserToken to update (required)
        :return: list[PortalUserTokenItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['portal_user_token_id', 'portal_user_token_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_portal_user_token" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'portal_user_token_id' is set
        if ('portal_user_token_id' not in params or
                params['portal_user_token_id'] is None):
            raise ValueError("Missing the required parameter `portal_user_token_id` when calling `update_portal_user_token`")  # noqa: E501
        # verify the required parameter 'portal_user_token_item' is set
        if ('portal_user_token_item' not in params or
                params['portal_user_token_item'] is None):
            raise ValueError("Missing the required parameter `portal_user_token_item` when calling `update_portal_user_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'portal_user_token_id' in params:
            path_params['PortalUserTokenID'] = params['portal_user_token_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'portal_user_token_item' in params:
            body_params = params['portal_user_token_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PortalUserToken/{PortalUserTokenID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PortalUserTokenItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_preference(self, preference_id, preference_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Preference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_preference(preference_id, preference_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int preference_id: Numeric value of the preferenceID (required)
        :param PreferenceItem preference_item: Preference to update (required)
        :return: list[PreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_preference_with_http_info(preference_id, preference_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_preference_with_http_info(preference_id, preference_item, **kwargs)  # noqa: E501
            return data

    def update_preference_with_http_info(self, preference_id, preference_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Preference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_preference_with_http_info(preference_id, preference_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int preference_id: Numeric value of the preferenceID (required)
        :param PreferenceItem preference_item: Preference to update (required)
        :return: list[PreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['preference_id', 'preference_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_preference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'preference_id' is set
        if ('preference_id' not in params or
                params['preference_id'] is None):
            raise ValueError("Missing the required parameter `preference_id` when calling `update_preference`")  # noqa: E501
        # verify the required parameter 'preference_item' is set
        if ('preference_item' not in params or
                params['preference_item'] is None):
            raise ValueError("Missing the required parameter `preference_item` when calling `update_preference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'preference_id' in params:
            path_params['PreferenceID'] = params['preference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'preference_item' in params:
            body_params = params['preference_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Preference/{PreferenceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PreferenceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_priority(self, priority_id, priority_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Priority in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_priority(priority_id, priority_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int priority_id: Numeric value of the priorityID (required)
        :param PriorityItem priority_item: Priority to update (required)
        :return: list[PriorityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_priority_with_http_info(priority_id, priority_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_priority_with_http_info(priority_id, priority_item, **kwargs)  # noqa: E501
            return data

    def update_priority_with_http_info(self, priority_id, priority_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Priority in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_priority_with_http_info(priority_id, priority_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int priority_id: Numeric value of the priorityID (required)
        :param PriorityItem priority_item: Priority to update (required)
        :return: list[PriorityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['priority_id', 'priority_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_priority" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'priority_id' is set
        if ('priority_id' not in params or
                params['priority_id'] is None):
            raise ValueError("Missing the required parameter `priority_id` when calling `update_priority`")  # noqa: E501
        # verify the required parameter 'priority_item' is set
        if ('priority_item' not in params or
                params['priority_item'] is None):
            raise ValueError("Missing the required parameter `priority_item` when calling `update_priority`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'priority_id' in params:
            path_params['PriorityID'] = params['priority_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'priority_item' in params:
            body_params = params['priority_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Priority/{PriorityID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PriorityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_process(self, process_id, process_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Process in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_process(process_id, process_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int process_id: Numeric value of the processID (required)
        :param ProcessItem process_item: Process to update (required)
        :return: list[ProcessItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_process_with_http_info(process_id, process_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_process_with_http_info(process_id, process_item, **kwargs)  # noqa: E501
            return data

    def update_process_with_http_info(self, process_id, process_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Process in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_process_with_http_info(process_id, process_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int process_id: Numeric value of the processID (required)
        :param ProcessItem process_item: Process to update (required)
        :return: list[ProcessItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['process_id', 'process_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_process" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'process_id' is set
        if ('process_id' not in params or
                params['process_id'] is None):
            raise ValueError("Missing the required parameter `process_id` when calling `update_process`")  # noqa: E501
        # verify the required parameter 'process_item' is set
        if ('process_item' not in params or
                params['process_item'] is None):
            raise ValueError("Missing the required parameter `process_item` when calling `update_process`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'process_id' in params:
            path_params['ProcessID'] = params['process_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'process_item' in params:
            body_params = params['process_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Process/{ProcessID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProcessItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_profile_item(self, profile_item_id, profile_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ProfileItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_profile_item(profile_item_id, profile_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int profile_item_id: Numeric value of the profileitemID (required)
        :param ProfileItemItem profile_item_item: ProfileItem to update (required)
        :return: list[ProfileItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_profile_item_with_http_info(profile_item_id, profile_item_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_profile_item_with_http_info(profile_item_id, profile_item_item, **kwargs)  # noqa: E501
            return data

    def update_profile_item_with_http_info(self, profile_item_id, profile_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ProfileItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_profile_item_with_http_info(profile_item_id, profile_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int profile_item_id: Numeric value of the profileitemID (required)
        :param ProfileItemItem profile_item_item: ProfileItem to update (required)
        :return: list[ProfileItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['profile_item_id', 'profile_item_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_profile_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'profile_item_id' is set
        if ('profile_item_id' not in params or
                params['profile_item_id'] is None):
            raise ValueError("Missing the required parameter `profile_item_id` when calling `update_profile_item`")  # noqa: E501
        # verify the required parameter 'profile_item_item' is set
        if ('profile_item_item' not in params or
                params['profile_item_item'] is None):
            raise ValueError("Missing the required parameter `profile_item_item` when calling `update_profile_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'profile_item_id' in params:
            path_params['ProfileItemID'] = params['profile_item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'profile_item_item' in params:
            body_params = params['profile_item_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ProfileItem/{ProfileItemID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProfileItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_profile_type(self, profile_type_id, profile_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ProfileType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_profile_type(profile_type_id, profile_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int profile_type_id: Numeric value of the profiletypeID (required)
        :param ProfileTypeItem profile_type_item: ProfileType to update (required)
        :return: list[ProfileTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_profile_type_with_http_info(profile_type_id, profile_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_profile_type_with_http_info(profile_type_id, profile_type_item, **kwargs)  # noqa: E501
            return data

    def update_profile_type_with_http_info(self, profile_type_id, profile_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ProfileType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_profile_type_with_http_info(profile_type_id, profile_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int profile_type_id: Numeric value of the profiletypeID (required)
        :param ProfileTypeItem profile_type_item: ProfileType to update (required)
        :return: list[ProfileTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['profile_type_id', 'profile_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_profile_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'profile_type_id' is set
        if ('profile_type_id' not in params or
                params['profile_type_id'] is None):
            raise ValueError("Missing the required parameter `profile_type_id` when calling `update_profile_type`")  # noqa: E501
        # verify the required parameter 'profile_type_item' is set
        if ('profile_type_item' not in params or
                params['profile_type_item'] is None):
            raise ValueError("Missing the required parameter `profile_type_item` when calling `update_profile_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'profile_type_id' in params:
            path_params['ProfileTypeID'] = params['profile_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'profile_type_item' in params:
            body_params = params['profile_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ProfileType/{ProfileTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProfileTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_program(self, program_id, program_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Program in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_program(program_id, program_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_id: Numeric value of the programID (required)
        :param ProgramItem program_item: Program to update (required)
        :return: list[ProgramItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_program_with_http_info(program_id, program_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_program_with_http_info(program_id, program_item, **kwargs)  # noqa: E501
            return data

    def update_program_with_http_info(self, program_id, program_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Program in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_program_with_http_info(program_id, program_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_id: Numeric value of the programID (required)
        :param ProgramItem program_item: Program to update (required)
        :return: list[ProgramItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_id', 'program_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_program" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'program_id' is set
        if ('program_id' not in params or
                params['program_id'] is None):
            raise ValueError("Missing the required parameter `program_id` when calling `update_program`")  # noqa: E501
        # verify the required parameter 'program_item' is set
        if ('program_item' not in params or
                params['program_item'] is None):
            raise ValueError("Missing the required parameter `program_item` when calling `update_program`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'program_id' in params:
            path_params['ProgramID'] = params['program_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'program_item' in params:
            body_params = params['program_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Program/{ProgramID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProgramItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_program_custom_field(self, program_custom_field_id, program_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ProgramCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_program_custom_field(program_custom_field_id, program_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_custom_field_id: Numeric value of the programcustomfieldID (required)
        :param ProgramCustomFieldItem program_custom_field_item: ProgramCustomField to update (required)
        :return: list[ProgramCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_program_custom_field_with_http_info(program_custom_field_id, program_custom_field_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_program_custom_field_with_http_info(program_custom_field_id, program_custom_field_item, **kwargs)  # noqa: E501
            return data

    def update_program_custom_field_with_http_info(self, program_custom_field_id, program_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ProgramCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_program_custom_field_with_http_info(program_custom_field_id, program_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_custom_field_id: Numeric value of the programcustomfieldID (required)
        :param ProgramCustomFieldItem program_custom_field_item: ProgramCustomField to update (required)
        :return: list[ProgramCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_custom_field_id', 'program_custom_field_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_program_custom_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'program_custom_field_id' is set
        if ('program_custom_field_id' not in params or
                params['program_custom_field_id'] is None):
            raise ValueError("Missing the required parameter `program_custom_field_id` when calling `update_program_custom_field`")  # noqa: E501
        # verify the required parameter 'program_custom_field_item' is set
        if ('program_custom_field_item' not in params or
                params['program_custom_field_item'] is None):
            raise ValueError("Missing the required parameter `program_custom_field_item` when calling `update_program_custom_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'program_custom_field_id' in params:
            path_params['ProgramCustomFieldID'] = params['program_custom_field_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'program_custom_field_item' in params:
            body_params = params['program_custom_field_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ProgramCustomField/{ProgramCustomFieldID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProgramCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_program_entry(self, program_entry_id, program_entry_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ProgramEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_program_entry(program_entry_id, program_entry_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_entry_id: Numeric value of the programentryID (required)
        :param ProgramEntryItem program_entry_item: ProgramEntry to update (required)
        :return: list[ProgramEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_program_entry_with_http_info(program_entry_id, program_entry_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_program_entry_with_http_info(program_entry_id, program_entry_item, **kwargs)  # noqa: E501
            return data

    def update_program_entry_with_http_info(self, program_entry_id, program_entry_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ProgramEntry in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_program_entry_with_http_info(program_entry_id, program_entry_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_entry_id: Numeric value of the programentryID (required)
        :param ProgramEntryItem program_entry_item: ProgramEntry to update (required)
        :return: list[ProgramEntryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_entry_id', 'program_entry_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_program_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'program_entry_id' is set
        if ('program_entry_id' not in params or
                params['program_entry_id'] is None):
            raise ValueError("Missing the required parameter `program_entry_id` when calling `update_program_entry`")  # noqa: E501
        # verify the required parameter 'program_entry_item' is set
        if ('program_entry_item' not in params or
                params['program_entry_item'] is None):
            raise ValueError("Missing the required parameter `program_entry_item` when calling `update_program_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'program_entry_id' in params:
            path_params['ProgramEntryID'] = params['program_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'program_entry_item' in params:
            body_params = params['program_entry_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ProgramEntry/{ProgramEntryID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProgramEntryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_program_evaluation_type(self, program_evaluation_type_id, program_evaluation_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ProgramEvaluationType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_program_evaluation_type(program_evaluation_type_id, program_evaluation_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_evaluation_type_id: Numeric value of the programevaluationtypeID (required)
        :param ProgramEvaluationTypeItem program_evaluation_type_item: ProgramEvaluationType to update (required)
        :return: list[ProgramEvaluationTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_program_evaluation_type_with_http_info(program_evaluation_type_id, program_evaluation_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_program_evaluation_type_with_http_info(program_evaluation_type_id, program_evaluation_type_item, **kwargs)  # noqa: E501
            return data

    def update_program_evaluation_type_with_http_info(self, program_evaluation_type_id, program_evaluation_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ProgramEvaluationType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_program_evaluation_type_with_http_info(program_evaluation_type_id, program_evaluation_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_evaluation_type_id: Numeric value of the programevaluationtypeID (required)
        :param ProgramEvaluationTypeItem program_evaluation_type_item: ProgramEvaluationType to update (required)
        :return: list[ProgramEvaluationTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_evaluation_type_id', 'program_evaluation_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_program_evaluation_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'program_evaluation_type_id' is set
        if ('program_evaluation_type_id' not in params or
                params['program_evaluation_type_id'] is None):
            raise ValueError("Missing the required parameter `program_evaluation_type_id` when calling `update_program_evaluation_type`")  # noqa: E501
        # verify the required parameter 'program_evaluation_type_item' is set
        if ('program_evaluation_type_item' not in params or
                params['program_evaluation_type_item'] is None):
            raise ValueError("Missing the required parameter `program_evaluation_type_item` when calling `update_program_evaluation_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'program_evaluation_type_id' in params:
            path_params['ProgramEvaluationTypeID'] = params['program_evaluation_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'program_evaluation_type_item' in params:
            body_params = params['program_evaluation_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ProgramEvaluationType/{ProgramEvaluationTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProgramEvaluationTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_program_note(self, program_note_id, program_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ProgramNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_program_note(program_note_id, program_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_note_id: Numeric value of the programnoteID (required)
        :param ProgramNoteItem program_note_item: ProgramNote to update (required)
        :return: list[ProgramNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_program_note_with_http_info(program_note_id, program_note_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_program_note_with_http_info(program_note_id, program_note_item, **kwargs)  # noqa: E501
            return data

    def update_program_note_with_http_info(self, program_note_id, program_note_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ProgramNote in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_program_note_with_http_info(program_note_id, program_note_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_note_id: Numeric value of the programnoteID (required)
        :param ProgramNoteItem program_note_item: ProgramNote to update (required)
        :return: list[ProgramNoteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_note_id', 'program_note_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_program_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'program_note_id' is set
        if ('program_note_id' not in params or
                params['program_note_id'] is None):
            raise ValueError("Missing the required parameter `program_note_id` when calling `update_program_note`")  # noqa: E501
        # verify the required parameter 'program_note_item' is set
        if ('program_note_item' not in params or
                params['program_note_item'] is None):
            raise ValueError("Missing the required parameter `program_note_item` when calling `update_program_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'program_note_id' in params:
            path_params['ProgramNoteID'] = params['program_note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'program_note_item' in params:
            body_params = params['program_note_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ProgramNote/{ProgramNoteID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProgramNoteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_program_sub_type(self, program_sub_type_id, program_sub_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ProgramSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_program_sub_type(program_sub_type_id, program_sub_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_sub_type_id: Numeric value of the programsubtypeID (required)
        :param ProgramSubTypeItem program_sub_type_item: ProgramSubType to update (required)
        :return: list[ProgramSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_program_sub_type_with_http_info(program_sub_type_id, program_sub_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_program_sub_type_with_http_info(program_sub_type_id, program_sub_type_item, **kwargs)  # noqa: E501
            return data

    def update_program_sub_type_with_http_info(self, program_sub_type_id, program_sub_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ProgramSubType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_program_sub_type_with_http_info(program_sub_type_id, program_sub_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_sub_type_id: Numeric value of the programsubtypeID (required)
        :param ProgramSubTypeItem program_sub_type_item: ProgramSubType to update (required)
        :return: list[ProgramSubTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_sub_type_id', 'program_sub_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_program_sub_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'program_sub_type_id' is set
        if ('program_sub_type_id' not in params or
                params['program_sub_type_id'] is None):
            raise ValueError("Missing the required parameter `program_sub_type_id` when calling `update_program_sub_type`")  # noqa: E501
        # verify the required parameter 'program_sub_type_item' is set
        if ('program_sub_type_item' not in params or
                params['program_sub_type_item'] is None):
            raise ValueError("Missing the required parameter `program_sub_type_item` when calling `update_program_sub_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'program_sub_type_id' in params:
            path_params['ProgramSubTypeID'] = params['program_sub_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'program_sub_type_item' in params:
            body_params = params['program_sub_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ProgramSubType/{ProgramSubTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProgramSubTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_program_type(self, program_type_id, program_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ProgramType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_program_type(program_type_id, program_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_type_id: Numeric value of the programtypeID (required)
        :param ProgramTypeItem program_type_item: ProgramType to update (required)
        :return: list[ProgramTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_program_type_with_http_info(program_type_id, program_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_program_type_with_http_info(program_type_id, program_type_item, **kwargs)  # noqa: E501
            return data

    def update_program_type_with_http_info(self, program_type_id, program_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ProgramType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_program_type_with_http_info(program_type_id, program_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int program_type_id: Numeric value of the programtypeID (required)
        :param ProgramTypeItem program_type_item: ProgramType to update (required)
        :return: list[ProgramTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_type_id', 'program_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_program_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'program_type_id' is set
        if ('program_type_id' not in params or
                params['program_type_id'] is None):
            raise ValueError("Missing the required parameter `program_type_id` when calling `update_program_type`")  # noqa: E501
        # verify the required parameter 'program_type_item' is set
        if ('program_type_item' not in params or
                params['program_type_item'] is None):
            raise ValueError("Missing the required parameter `program_type_item` when calling `update_program_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'program_type_id' in params:
            path_params['ProgramTypeID'] = params['program_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'program_type_item' in params:
            body_params = params['program_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ProgramType/{ProgramTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProgramTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_promo_code(self, promo_code_id, promo_code_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PromoCode in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_promo_code(promo_code_id, promo_code_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int promo_code_id: Numeric value of the promocodeID (required)
        :param PromoCodeItem promo_code_item: PromoCode to update (required)
        :return: list[PromoCodeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_promo_code_with_http_info(promo_code_id, promo_code_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_promo_code_with_http_info(promo_code_id, promo_code_item, **kwargs)  # noqa: E501
            return data

    def update_promo_code_with_http_info(self, promo_code_id, promo_code_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PromoCode in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_promo_code_with_http_info(promo_code_id, promo_code_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int promo_code_id: Numeric value of the promocodeID (required)
        :param PromoCodeItem promo_code_item: PromoCode to update (required)
        :return: list[PromoCodeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['promo_code_id', 'promo_code_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_promo_code" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'promo_code_id' is set
        if ('promo_code_id' not in params or
                params['promo_code_id'] is None):
            raise ValueError("Missing the required parameter `promo_code_id` when calling `update_promo_code`")  # noqa: E501
        # verify the required parameter 'promo_code_item' is set
        if ('promo_code_item' not in params or
                params['promo_code_item'] is None):
            raise ValueError("Missing the required parameter `promo_code_item` when calling `update_promo_code`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'promo_code_id' in params:
            path_params['PromoCodeID'] = params['promo_code_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'promo_code_item' in params:
            body_params = params['promo_code_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PromoCode/{PromoCodeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PromoCodeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_promo_code_record(self, promo_code_record_id, promo_code_record_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PromoCodeRecord in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_promo_code_record(promo_code_record_id, promo_code_record_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int promo_code_record_id: Numeric value of the promocoderecordID (required)
        :param PromoCodeRecordItem promo_code_record_item: PromoCodeRecord to update (required)
        :return: list[PromoCodeRecordItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_promo_code_record_with_http_info(promo_code_record_id, promo_code_record_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_promo_code_record_with_http_info(promo_code_record_id, promo_code_record_item, **kwargs)  # noqa: E501
            return data

    def update_promo_code_record_with_http_info(self, promo_code_record_id, promo_code_record_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PromoCodeRecord in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_promo_code_record_with_http_info(promo_code_record_id, promo_code_record_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int promo_code_record_id: Numeric value of the promocoderecordID (required)
        :param PromoCodeRecordItem promo_code_record_item: PromoCodeRecord to update (required)
        :return: list[PromoCodeRecordItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['promo_code_record_id', 'promo_code_record_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_promo_code_record" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'promo_code_record_id' is set
        if ('promo_code_record_id' not in params or
                params['promo_code_record_id'] is None):
            raise ValueError("Missing the required parameter `promo_code_record_id` when calling `update_promo_code_record`")  # noqa: E501
        # verify the required parameter 'promo_code_record_item' is set
        if ('promo_code_record_item' not in params or
                params['promo_code_record_item'] is None):
            raise ValueError("Missing the required parameter `promo_code_record_item` when calling `update_promo_code_record`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'promo_code_record_id' in params:
            path_params['PromoCodeRecordID'] = params['promo_code_record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'promo_code_record_item' in params:
            body_params = params['promo_code_record_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PromoCodeRecord/{PromoCodeRecordID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PromoCodeRecordItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_promo_code_usage(self, promo_code_usage_id, promo_code_usage_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PromoCodeUsage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_promo_code_usage(promo_code_usage_id, promo_code_usage_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int promo_code_usage_id: Numeric value of the promocodeusageID (required)
        :param PromoCodeUsageItem promo_code_usage_item: PromoCodeUsage to update (required)
        :return: list[PromoCodeUsageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_promo_code_usage_with_http_info(promo_code_usage_id, promo_code_usage_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_promo_code_usage_with_http_info(promo_code_usage_id, promo_code_usage_item, **kwargs)  # noqa: E501
            return data

    def update_promo_code_usage_with_http_info(self, promo_code_usage_id, promo_code_usage_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an PromoCodeUsage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_promo_code_usage_with_http_info(promo_code_usage_id, promo_code_usage_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int promo_code_usage_id: Numeric value of the promocodeusageID (required)
        :param PromoCodeUsageItem promo_code_usage_item: PromoCodeUsage to update (required)
        :return: list[PromoCodeUsageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['promo_code_usage_id', 'promo_code_usage_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_promo_code_usage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'promo_code_usage_id' is set
        if ('promo_code_usage_id' not in params or
                params['promo_code_usage_id'] is None):
            raise ValueError("Missing the required parameter `promo_code_usage_id` when calling `update_promo_code_usage`")  # noqa: E501
        # verify the required parameter 'promo_code_usage_item' is set
        if ('promo_code_usage_item' not in params or
                params['promo_code_usage_item'] is None):
            raise ValueError("Missing the required parameter `promo_code_usage_item` when calling `update_promo_code_usage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'promo_code_usage_id' in params:
            path_params['PromoCodeUsageID'] = params['promo_code_usage_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'promo_code_usage_item' in params:
            body_params = params['promo_code_usage_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/PromoCodeUsage/{PromoCodeUsageID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PromoCodeUsageItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_record_attachment(self, record_attachment_id, record_attachment_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RecordAttachment in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_record_attachment(record_attachment_id, record_attachment_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int record_attachment_id: Numeric value of the recordattachmentID (required)
        :param RecordAttachmentItem record_attachment_item: RecordAttachment to update (required)
        :return: list[RecordAttachmentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_record_attachment_with_http_info(record_attachment_id, record_attachment_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_record_attachment_with_http_info(record_attachment_id, record_attachment_item, **kwargs)  # noqa: E501
            return data

    def update_record_attachment_with_http_info(self, record_attachment_id, record_attachment_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RecordAttachment in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_record_attachment_with_http_info(record_attachment_id, record_attachment_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int record_attachment_id: Numeric value of the recordattachmentID (required)
        :param RecordAttachmentItem record_attachment_item: RecordAttachment to update (required)
        :return: list[RecordAttachmentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['record_attachment_id', 'record_attachment_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_record_attachment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'record_attachment_id' is set
        if ('record_attachment_id' not in params or
                params['record_attachment_id'] is None):
            raise ValueError("Missing the required parameter `record_attachment_id` when calling `update_record_attachment`")  # noqa: E501
        # verify the required parameter 'record_attachment_item' is set
        if ('record_attachment_item' not in params or
                params['record_attachment_item'] is None):
            raise ValueError("Missing the required parameter `record_attachment_item` when calling `update_record_attachment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'record_attachment_id' in params:
            path_params['RecordAttachmentID'] = params['record_attachment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'record_attachment_item' in params:
            body_params = params['record_attachment_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RecordAttachment/{RecordAttachmentID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RecordAttachmentItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_refund_request(self, refund_request_id, refund_request_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RefundRequest in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_refund_request(refund_request_id, refund_request_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_id: Numeric value of the refundrequestID (required)
        :param RefundRequestItem refund_request_item: RefundRequest to update (required)
        :return: list[RefundRequestItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_refund_request_with_http_info(refund_request_id, refund_request_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_refund_request_with_http_info(refund_request_id, refund_request_item, **kwargs)  # noqa: E501
            return data

    def update_refund_request_with_http_info(self, refund_request_id, refund_request_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RefundRequest in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_refund_request_with_http_info(refund_request_id, refund_request_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_id: Numeric value of the refundrequestID (required)
        :param RefundRequestItem refund_request_item: RefundRequest to update (required)
        :return: list[RefundRequestItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['refund_request_id', 'refund_request_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_refund_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'refund_request_id' is set
        if ('refund_request_id' not in params or
                params['refund_request_id'] is None):
            raise ValueError("Missing the required parameter `refund_request_id` when calling `update_refund_request`")  # noqa: E501
        # verify the required parameter 'refund_request_item' is set
        if ('refund_request_item' not in params or
                params['refund_request_item'] is None):
            raise ValueError("Missing the required parameter `refund_request_item` when calling `update_refund_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'refund_request_id' in params:
            path_params['RefundRequestID'] = params['refund_request_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'refund_request_item' in params:
            body_params = params['refund_request_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RefundRequest/{RefundRequestID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RefundRequestItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_refund_request_batch_configuration(self, refund_request_batch_configuration_id, refund_request_batch_configuration_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RefundRequestBatchConfiguration in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_refund_request_batch_configuration(refund_request_batch_configuration_id, refund_request_batch_configuration_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_batch_configuration_id: Numeric value of the refundrequestbatchconfigurationID (required)
        :param RefundRequestBatchConfigurationItem refund_request_batch_configuration_item: RefundRequestBatchConfiguration to update (required)
        :return: list[RefundRequestBatchConfigurationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_refund_request_batch_configuration_with_http_info(refund_request_batch_configuration_id, refund_request_batch_configuration_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_refund_request_batch_configuration_with_http_info(refund_request_batch_configuration_id, refund_request_batch_configuration_item, **kwargs)  # noqa: E501
            return data

    def update_refund_request_batch_configuration_with_http_info(self, refund_request_batch_configuration_id, refund_request_batch_configuration_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RefundRequestBatchConfiguration in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_refund_request_batch_configuration_with_http_info(refund_request_batch_configuration_id, refund_request_batch_configuration_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_batch_configuration_id: Numeric value of the refundrequestbatchconfigurationID (required)
        :param RefundRequestBatchConfigurationItem refund_request_batch_configuration_item: RefundRequestBatchConfiguration to update (required)
        :return: list[RefundRequestBatchConfigurationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['refund_request_batch_configuration_id', 'refund_request_batch_configuration_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_refund_request_batch_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'refund_request_batch_configuration_id' is set
        if ('refund_request_batch_configuration_id' not in params or
                params['refund_request_batch_configuration_id'] is None):
            raise ValueError("Missing the required parameter `refund_request_batch_configuration_id` when calling `update_refund_request_batch_configuration`")  # noqa: E501
        # verify the required parameter 'refund_request_batch_configuration_item' is set
        if ('refund_request_batch_configuration_item' not in params or
                params['refund_request_batch_configuration_item'] is None):
            raise ValueError("Missing the required parameter `refund_request_batch_configuration_item` when calling `update_refund_request_batch_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'refund_request_batch_configuration_id' in params:
            path_params['RefundRequestBatchConfigurationID'] = params['refund_request_batch_configuration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'refund_request_batch_configuration_item' in params:
            body_params = params['refund_request_batch_configuration_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RefundRequestBatchConfiguration/{RefundRequestBatchConfigurationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RefundRequestBatchConfigurationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_refund_request_batch_configuration_item(self, refund_request_batch_configuration_item_id, refund_request_batch_configuration_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RefundRequestBatchConfigurationItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_refund_request_batch_configuration_item(refund_request_batch_configuration_item_id, refund_request_batch_configuration_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_batch_configuration_item_id: Numeric value of the refundrequestbatchconfigurationitemID (required)
        :param RefundRequestBatchConfigurationItemItem refund_request_batch_configuration_item_item: RefundRequestBatchConfigurationItem to update (required)
        :return: list[RefundRequestBatchConfigurationItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_refund_request_batch_configuration_item_with_http_info(refund_request_batch_configuration_item_id, refund_request_batch_configuration_item_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_refund_request_batch_configuration_item_with_http_info(refund_request_batch_configuration_item_id, refund_request_batch_configuration_item_item, **kwargs)  # noqa: E501
            return data

    def update_refund_request_batch_configuration_item_with_http_info(self, refund_request_batch_configuration_item_id, refund_request_batch_configuration_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RefundRequestBatchConfigurationItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_refund_request_batch_configuration_item_with_http_info(refund_request_batch_configuration_item_id, refund_request_batch_configuration_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_batch_configuration_item_id: Numeric value of the refundrequestbatchconfigurationitemID (required)
        :param RefundRequestBatchConfigurationItemItem refund_request_batch_configuration_item_item: RefundRequestBatchConfigurationItem to update (required)
        :return: list[RefundRequestBatchConfigurationItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['refund_request_batch_configuration_item_id', 'refund_request_batch_configuration_item_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_refund_request_batch_configuration_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'refund_request_batch_configuration_item_id' is set
        if ('refund_request_batch_configuration_item_id' not in params or
                params['refund_request_batch_configuration_item_id'] is None):
            raise ValueError("Missing the required parameter `refund_request_batch_configuration_item_id` when calling `update_refund_request_batch_configuration_item`")  # noqa: E501
        # verify the required parameter 'refund_request_batch_configuration_item_item' is set
        if ('refund_request_batch_configuration_item_item' not in params or
                params['refund_request_batch_configuration_item_item'] is None):
            raise ValueError("Missing the required parameter `refund_request_batch_configuration_item_item` when calling `update_refund_request_batch_configuration_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'refund_request_batch_configuration_item_id' in params:
            path_params['RefundRequestBatchConfigurationItemID'] = params['refund_request_batch_configuration_item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'refund_request_batch_configuration_item_item' in params:
            body_params = params['refund_request_batch_configuration_item_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RefundRequestBatchConfigurationItem/{RefundRequestBatchConfigurationItemID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RefundRequestBatchConfigurationItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_refund_request_break_up(self, refund_request_break_up_id, refund_request_break_up_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RefundRequestBreakUp in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_refund_request_break_up(refund_request_break_up_id, refund_request_break_up_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_break_up_id: Numeric value of the refundrequestbreakupID (required)
        :param RefundRequestBreakUpItem refund_request_break_up_item: RefundRequestBreakUp to update (required)
        :return: list[RefundRequestBreakUpItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_refund_request_break_up_with_http_info(refund_request_break_up_id, refund_request_break_up_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_refund_request_break_up_with_http_info(refund_request_break_up_id, refund_request_break_up_item, **kwargs)  # noqa: E501
            return data

    def update_refund_request_break_up_with_http_info(self, refund_request_break_up_id, refund_request_break_up_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RefundRequestBreakUp in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_refund_request_break_up_with_http_info(refund_request_break_up_id, refund_request_break_up_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_break_up_id: Numeric value of the refundrequestbreakupID (required)
        :param RefundRequestBreakUpItem refund_request_break_up_item: RefundRequestBreakUp to update (required)
        :return: list[RefundRequestBreakUpItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['refund_request_break_up_id', 'refund_request_break_up_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_refund_request_break_up" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'refund_request_break_up_id' is set
        if ('refund_request_break_up_id' not in params or
                params['refund_request_break_up_id'] is None):
            raise ValueError("Missing the required parameter `refund_request_break_up_id` when calling `update_refund_request_break_up`")  # noqa: E501
        # verify the required parameter 'refund_request_break_up_item' is set
        if ('refund_request_break_up_item' not in params or
                params['refund_request_break_up_item'] is None):
            raise ValueError("Missing the required parameter `refund_request_break_up_item` when calling `update_refund_request_break_up`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'refund_request_break_up_id' in params:
            path_params['RefundRequestBreakUpID'] = params['refund_request_break_up_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'refund_request_break_up_item' in params:
            body_params = params['refund_request_break_up_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RefundRequestBreakUp/{RefundRequestBreakUpID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RefundRequestBreakUpItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_refund_request_configuration(self, refund_request_configuration_id, refund_request_configuration_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RefundRequestConfiguration in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_refund_request_configuration(refund_request_configuration_id, refund_request_configuration_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_configuration_id: Numeric value of the refundrequestconfigurationID (required)
        :param RefundRequestConfigurationItem refund_request_configuration_item: RefundRequestConfiguration to update (required)
        :return: list[RefundRequestConfigurationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_refund_request_configuration_with_http_info(refund_request_configuration_id, refund_request_configuration_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_refund_request_configuration_with_http_info(refund_request_configuration_id, refund_request_configuration_item, **kwargs)  # noqa: E501
            return data

    def update_refund_request_configuration_with_http_info(self, refund_request_configuration_id, refund_request_configuration_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RefundRequestConfiguration in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_refund_request_configuration_with_http_info(refund_request_configuration_id, refund_request_configuration_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_configuration_id: Numeric value of the refundrequestconfigurationID (required)
        :param RefundRequestConfigurationItem refund_request_configuration_item: RefundRequestConfiguration to update (required)
        :return: list[RefundRequestConfigurationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['refund_request_configuration_id', 'refund_request_configuration_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_refund_request_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'refund_request_configuration_id' is set
        if ('refund_request_configuration_id' not in params or
                params['refund_request_configuration_id'] is None):
            raise ValueError("Missing the required parameter `refund_request_configuration_id` when calling `update_refund_request_configuration`")  # noqa: E501
        # verify the required parameter 'refund_request_configuration_item' is set
        if ('refund_request_configuration_item' not in params or
                params['refund_request_configuration_item'] is None):
            raise ValueError("Missing the required parameter `refund_request_configuration_item` when calling `update_refund_request_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'refund_request_configuration_id' in params:
            path_params['RefundRequestConfigurationID'] = params['refund_request_configuration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'refund_request_configuration_item' in params:
            body_params = params['refund_request_configuration_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RefundRequestConfiguration/{RefundRequestConfigurationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RefundRequestConfigurationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_refund_request_configuration_break_up(self, refund_request_configuration_break_up_id, refund_request_configuration_break_up_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RefundRequestConfigurationBreakUp in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_refund_request_configuration_break_up(refund_request_configuration_break_up_id, refund_request_configuration_break_up_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_configuration_break_up_id: Numeric value of the refundrequestconfigurationbreakupID (required)
        :param RefundRequestConfigurationBreakUpItem refund_request_configuration_break_up_item: RefundRequestConfigurationBreakUp to update (required)
        :return: list[RefundRequestConfigurationBreakUpItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_refund_request_configuration_break_up_with_http_info(refund_request_configuration_break_up_id, refund_request_configuration_break_up_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_refund_request_configuration_break_up_with_http_info(refund_request_configuration_break_up_id, refund_request_configuration_break_up_item, **kwargs)  # noqa: E501
            return data

    def update_refund_request_configuration_break_up_with_http_info(self, refund_request_configuration_break_up_id, refund_request_configuration_break_up_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RefundRequestConfigurationBreakUp in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_refund_request_configuration_break_up_with_http_info(refund_request_configuration_break_up_id, refund_request_configuration_break_up_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int refund_request_configuration_break_up_id: Numeric value of the refundrequestconfigurationbreakupID (required)
        :param RefundRequestConfigurationBreakUpItem refund_request_configuration_break_up_item: RefundRequestConfigurationBreakUp to update (required)
        :return: list[RefundRequestConfigurationBreakUpItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['refund_request_configuration_break_up_id', 'refund_request_configuration_break_up_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_refund_request_configuration_break_up" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'refund_request_configuration_break_up_id' is set
        if ('refund_request_configuration_break_up_id' not in params or
                params['refund_request_configuration_break_up_id'] is None):
            raise ValueError("Missing the required parameter `refund_request_configuration_break_up_id` when calling `update_refund_request_configuration_break_up`")  # noqa: E501
        # verify the required parameter 'refund_request_configuration_break_up_item' is set
        if ('refund_request_configuration_break_up_item' not in params or
                params['refund_request_configuration_break_up_item'] is None):
            raise ValueError("Missing the required parameter `refund_request_configuration_break_up_item` when calling `update_refund_request_configuration_break_up`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'refund_request_configuration_break_up_id' in params:
            path_params['RefundRequestConfigurationBreakUpID'] = params['refund_request_configuration_break_up_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'refund_request_configuration_break_up_item' in params:
            body_params = params['refund_request_configuration_break_up_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RefundRequestConfigurationBreakUp/{RefundRequestConfigurationBreakUpID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RefundRequestConfigurationBreakUpItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_region_of_birth(self, region_of_birth_id, region_of_birth_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RegionOfBirth in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_region_of_birth(region_of_birth_id, region_of_birth_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int region_of_birth_id: Numeric value of the regionofbirthID (required)
        :param RegionOfBirthItem region_of_birth_item: RegionOfBirth to update (required)
        :return: list[RegionOfBirthItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_region_of_birth_with_http_info(region_of_birth_id, region_of_birth_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_region_of_birth_with_http_info(region_of_birth_id, region_of_birth_item, **kwargs)  # noqa: E501
            return data

    def update_region_of_birth_with_http_info(self, region_of_birth_id, region_of_birth_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RegionOfBirth in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_region_of_birth_with_http_info(region_of_birth_id, region_of_birth_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int region_of_birth_id: Numeric value of the regionofbirthID (required)
        :param RegionOfBirthItem region_of_birth_item: RegionOfBirth to update (required)
        :return: list[RegionOfBirthItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['region_of_birth_id', 'region_of_birth_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_region_of_birth" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'region_of_birth_id' is set
        if ('region_of_birth_id' not in params or
                params['region_of_birth_id'] is None):
            raise ValueError("Missing the required parameter `region_of_birth_id` when calling `update_region_of_birth`")  # noqa: E501
        # verify the required parameter 'region_of_birth_item' is set
        if ('region_of_birth_item' not in params or
                params['region_of_birth_item'] is None):
            raise ValueError("Missing the required parameter `region_of_birth_item` when calling `update_region_of_birth`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'region_of_birth_id' in params:
            path_params['RegionOfBirthID'] = params['region_of_birth_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'region_of_birth_item' in params:
            body_params = params['region_of_birth_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RegionOfBirth/{RegionOfBirthID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RegionOfBirthItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_report(self, report_id, report_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Report in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_report(report_id, report_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_id: Numeric value of the reportID (required)
        :param ReportItem report_item: Report to update (required)
        :return: list[ReportItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_report_with_http_info(report_id, report_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_report_with_http_info(report_id, report_item, **kwargs)  # noqa: E501
            return data

    def update_report_with_http_info(self, report_id, report_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Report in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_report_with_http_info(report_id, report_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_id: Numeric value of the reportID (required)
        :param ReportItem report_item: Report to update (required)
        :return: list[ReportItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['report_id', 'report_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_report" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'report_id' is set
        if ('report_id' not in params or
                params['report_id'] is None):
            raise ValueError("Missing the required parameter `report_id` when calling `update_report`")  # noqa: E501
        # verify the required parameter 'report_item' is set
        if ('report_item' not in params or
                params['report_item'] is None):
            raise ValueError("Missing the required parameter `report_item` when calling `update_report`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'report_id' in params:
            path_params['ReportID'] = params['report_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'report_item' in params:
            body_params = params['report_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Report/{ReportID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ReportItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_report_detail(self, report_detail_id, report_detail_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ReportDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_report_detail(report_detail_id, report_detail_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_detail_id: Numeric value of the reportdetailID (required)
        :param ReportDetailItem report_detail_item: ReportDetail to update (required)
        :return: list[ReportDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_report_detail_with_http_info(report_detail_id, report_detail_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_report_detail_with_http_info(report_detail_id, report_detail_item, **kwargs)  # noqa: E501
            return data

    def update_report_detail_with_http_info(self, report_detail_id, report_detail_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ReportDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_report_detail_with_http_info(report_detail_id, report_detail_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_detail_id: Numeric value of the reportdetailID (required)
        :param ReportDetailItem report_detail_item: ReportDetail to update (required)
        :return: list[ReportDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['report_detail_id', 'report_detail_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_report_detail" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'report_detail_id' is set
        if ('report_detail_id' not in params or
                params['report_detail_id'] is None):
            raise ValueError("Missing the required parameter `report_detail_id` when calling `update_report_detail`")  # noqa: E501
        # verify the required parameter 'report_detail_item' is set
        if ('report_detail_item' not in params or
                params['report_detail_item'] is None):
            raise ValueError("Missing the required parameter `report_detail_item` when calling `update_report_detail`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'report_detail_id' in params:
            path_params['ReportDetailID'] = params['report_detail_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'report_detail_item' in params:
            body_params = params['report_detail_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ReportDetail/{ReportDetailID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ReportDetailItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_report_permission(self, report_permission_id, report_permission_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ReportPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_report_permission(report_permission_id, report_permission_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_permission_id: Numeric value of the reportpermissionID (required)
        :param ReportPermissionItem report_permission_item: ReportPermission to update (required)
        :return: list[ReportPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_report_permission_with_http_info(report_permission_id, report_permission_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_report_permission_with_http_info(report_permission_id, report_permission_item, **kwargs)  # noqa: E501
            return data

    def update_report_permission_with_http_info(self, report_permission_id, report_permission_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ReportPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_report_permission_with_http_info(report_permission_id, report_permission_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_permission_id: Numeric value of the reportpermissionID (required)
        :param ReportPermissionItem report_permission_item: ReportPermission to update (required)
        :return: list[ReportPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['report_permission_id', 'report_permission_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_report_permission" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'report_permission_id' is set
        if ('report_permission_id' not in params or
                params['report_permission_id'] is None):
            raise ValueError("Missing the required parameter `report_permission_id` when calling `update_report_permission`")  # noqa: E501
        # verify the required parameter 'report_permission_item' is set
        if ('report_permission_item' not in params or
                params['report_permission_item'] is None):
            raise ValueError("Missing the required parameter `report_permission_item` when calling `update_report_permission`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'report_permission_id' in params:
            path_params['ReportPermissionID'] = params['report_permission_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'report_permission_item' in params:
            body_params = params['report_permission_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ReportPermission/{ReportPermissionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ReportPermissionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_report_schedule(self, report_schedule_id, report_schedule_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ReportSchedule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_report_schedule(report_schedule_id, report_schedule_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_schedule_id: Numeric value of the reportscheduleID (required)
        :param ReportScheduleItem report_schedule_item: ReportSchedule to update (required)
        :return: list[ReportScheduleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_report_schedule_with_http_info(report_schedule_id, report_schedule_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_report_schedule_with_http_info(report_schedule_id, report_schedule_item, **kwargs)  # noqa: E501
            return data

    def update_report_schedule_with_http_info(self, report_schedule_id, report_schedule_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ReportSchedule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_report_schedule_with_http_info(report_schedule_id, report_schedule_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_schedule_id: Numeric value of the reportscheduleID (required)
        :param ReportScheduleItem report_schedule_item: ReportSchedule to update (required)
        :return: list[ReportScheduleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['report_schedule_id', 'report_schedule_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_report_schedule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'report_schedule_id' is set
        if ('report_schedule_id' not in params or
                params['report_schedule_id'] is None):
            raise ValueError("Missing the required parameter `report_schedule_id` when calling `update_report_schedule`")  # noqa: E501
        # verify the required parameter 'report_schedule_item' is set
        if ('report_schedule_item' not in params or
                params['report_schedule_item'] is None):
            raise ValueError("Missing the required parameter `report_schedule_item` when calling `update_report_schedule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'report_schedule_id' in params:
            path_params['ReportScheduleID'] = params['report_schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'report_schedule_item' in params:
            body_params = params['report_schedule_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ReportSchedule/{ReportScheduleID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ReportScheduleItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_report_setting(self, report_setting_id, report_setting_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ReportSetting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_report_setting(report_setting_id, report_setting_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_setting_id: Numeric value of the reportsettingID (required)
        :param ReportSettingItem report_setting_item: ReportSetting to update (required)
        :return: list[ReportSettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_report_setting_with_http_info(report_setting_id, report_setting_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_report_setting_with_http_info(report_setting_id, report_setting_item, **kwargs)  # noqa: E501
            return data

    def update_report_setting_with_http_info(self, report_setting_id, report_setting_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ReportSetting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_report_setting_with_http_info(report_setting_id, report_setting_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int report_setting_id: Numeric value of the reportsettingID (required)
        :param ReportSettingItem report_setting_item: ReportSetting to update (required)
        :return: list[ReportSettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['report_setting_id', 'report_setting_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_report_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'report_setting_id' is set
        if ('report_setting_id' not in params or
                params['report_setting_id'] is None):
            raise ValueError("Missing the required parameter `report_setting_id` when calling `update_report_setting`")  # noqa: E501
        # verify the required parameter 'report_setting_item' is set
        if ('report_setting_item' not in params or
                params['report_setting_item'] is None):
            raise ValueError("Missing the required parameter `report_setting_item` when calling `update_report_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'report_setting_id' in params:
            path_params['ReportSettingID'] = params['report_setting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'report_setting_item' in params:
            body_params = params['report_setting_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ReportSetting/{ReportSettingID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ReportSettingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_resource(self, resource_id, resource_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Resource in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_resource(resource_id, resource_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_id: Numeric value of the resourceID (required)
        :param ResourceItem resource_item: Resource to update (required)
        :return: list[ResourceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_resource_with_http_info(resource_id, resource_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_resource_with_http_info(resource_id, resource_item, **kwargs)  # noqa: E501
            return data

    def update_resource_with_http_info(self, resource_id, resource_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Resource in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_resource_with_http_info(resource_id, resource_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_id: Numeric value of the resourceID (required)
        :param ResourceItem resource_item: Resource to update (required)
        :return: list[ResourceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_id', 'resource_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_resource" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_id' is set
        if ('resource_id' not in params or
                params['resource_id'] is None):
            raise ValueError("Missing the required parameter `resource_id` when calling `update_resource`")  # noqa: E501
        # verify the required parameter 'resource_item' is set
        if ('resource_item' not in params or
                params['resource_item'] is None):
            raise ValueError("Missing the required parameter `resource_item` when calling `update_resource`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_id' in params:
            path_params['ResourceID'] = params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'resource_item' in params:
            body_params = params['resource_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Resource/{ResourceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ResourceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_resource_booking(self, resource_booking_id, resource_booking_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ResourceBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_resource_booking(resource_booking_id, resource_booking_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_booking_id: Numeric value of the resourcebookingID (required)
        :param ResourceBookingItem resource_booking_item: ResourceBooking to update (required)
        :return: list[ResourceBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_resource_booking_with_http_info(resource_booking_id, resource_booking_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_resource_booking_with_http_info(resource_booking_id, resource_booking_item, **kwargs)  # noqa: E501
            return data

    def update_resource_booking_with_http_info(self, resource_booking_id, resource_booking_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ResourceBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_resource_booking_with_http_info(resource_booking_id, resource_booking_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_booking_id: Numeric value of the resourcebookingID (required)
        :param ResourceBookingItem resource_booking_item: ResourceBooking to update (required)
        :return: list[ResourceBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_booking_id', 'resource_booking_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_resource_booking" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_booking_id' is set
        if ('resource_booking_id' not in params or
                params['resource_booking_id'] is None):
            raise ValueError("Missing the required parameter `resource_booking_id` when calling `update_resource_booking`")  # noqa: E501
        # verify the required parameter 'resource_booking_item' is set
        if ('resource_booking_item' not in params or
                params['resource_booking_item'] is None):
            raise ValueError("Missing the required parameter `resource_booking_item` when calling `update_resource_booking`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_booking_id' in params:
            path_params['ResourceBookingID'] = params['resource_booking_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'resource_booking_item' in params:
            body_params = params['resource_booking_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ResourceBooking/{ResourceBookingID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ResourceBookingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_resource_type(self, resource_type_id, resource_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ResourceType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_resource_type(resource_type_id, resource_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_type_id: Numeric value of the resourcetypeID (required)
        :param ResourceTypeItem resource_type_item: ResourceType to update (required)
        :return: list[ResourceTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_resource_type_with_http_info(resource_type_id, resource_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_resource_type_with_http_info(resource_type_id, resource_type_item, **kwargs)  # noqa: E501
            return data

    def update_resource_type_with_http_info(self, resource_type_id, resource_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ResourceType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_resource_type_with_http_info(resource_type_id, resource_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int resource_type_id: Numeric value of the resourcetypeID (required)
        :param ResourceTypeItem resource_type_item: ResourceType to update (required)
        :return: list[ResourceTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['resource_type_id', 'resource_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_resource_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'resource_type_id' is set
        if ('resource_type_id' not in params or
                params['resource_type_id'] is None):
            raise ValueError("Missing the required parameter `resource_type_id` when calling `update_resource_type`")  # noqa: E501
        # verify the required parameter 'resource_type_item' is set
        if ('resource_type_item' not in params or
                params['resource_type_item'] is None):
            raise ValueError("Missing the required parameter `resource_type_item` when calling `update_resource_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_type_id' in params:
            path_params['ResourceTypeID'] = params['resource_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'resource_type_item' in params:
            body_params = params['resource_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ResourceType/{ResourceTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ResourceTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_response_status(self, response_status_id, response_status_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ResponseStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_response_status(response_status_id, response_status_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int response_status_id: Numeric value of the responsestatusID (required)
        :param ResponseStatusItem response_status_item: ResponseStatus to update (required)
        :return: list[ResponseStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_response_status_with_http_info(response_status_id, response_status_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_response_status_with_http_info(response_status_id, response_status_item, **kwargs)  # noqa: E501
            return data

    def update_response_status_with_http_info(self, response_status_id, response_status_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ResponseStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_response_status_with_http_info(response_status_id, response_status_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int response_status_id: Numeric value of the responsestatusID (required)
        :param ResponseStatusItem response_status_item: ResponseStatus to update (required)
        :return: list[ResponseStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['response_status_id', 'response_status_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_response_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'response_status_id' is set
        if ('response_status_id' not in params or
                params['response_status_id'] is None):
            raise ValueError("Missing the required parameter `response_status_id` when calling `update_response_status`")  # noqa: E501
        # verify the required parameter 'response_status_item' is set
        if ('response_status_item' not in params or
                params['response_status_item'] is None):
            raise ValueError("Missing the required parameter `response_status_item` when calling `update_response_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'response_status_id' in params:
            path_params['ResponseStatusID'] = params['response_status_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'response_status_item' in params:
            body_params = params['response_status_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ResponseStatus/{ResponseStatusID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ResponseStatusItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room(self, room_id, room_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Room in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room(room_id, room_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_id: Numeric value of the roomID (required)
        :param RoomItem room_item: Room to update (required)
        :return: list[RoomItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_with_http_info(room_id, room_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_with_http_info(room_id, room_item, **kwargs)  # noqa: E501
            return data

    def update_room_with_http_info(self, room_id, room_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Room in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_with_http_info(room_id, room_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_id: Numeric value of the roomID (required)
        :param RoomItem room_item: Room to update (required)
        :return: list[RoomItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_id', 'room_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_id' is set
        if ('room_id' not in params or
                params['room_id'] is None):
            raise ValueError("Missing the required parameter `room_id` when calling `update_room`")  # noqa: E501
        # verify the required parameter 'room_item' is set
        if ('room_item' not in params or
                params['room_item'] is None):
            raise ValueError("Missing the required parameter `room_item` when calling `update_room`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_id' in params:
            path_params['RoomID'] = params['room_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_item' in params:
            body_params = params['room_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Room/{RoomID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_attribute(self, room_attribute_id, room_attribute_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomAttribute in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_attribute(room_attribute_id, room_attribute_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_attribute_id: Numeric value of the roomattributeID (required)
        :param RoomAttributeItem room_attribute_item: RoomAttribute to update (required)
        :return: list[RoomAttributeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_attribute_with_http_info(room_attribute_id, room_attribute_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_attribute_with_http_info(room_attribute_id, room_attribute_item, **kwargs)  # noqa: E501
            return data

    def update_room_attribute_with_http_info(self, room_attribute_id, room_attribute_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomAttribute in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_attribute_with_http_info(room_attribute_id, room_attribute_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_attribute_id: Numeric value of the roomattributeID (required)
        :param RoomAttributeItem room_attribute_item: RoomAttribute to update (required)
        :return: list[RoomAttributeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_attribute_id', 'room_attribute_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_attribute" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_attribute_id' is set
        if ('room_attribute_id' not in params or
                params['room_attribute_id'] is None):
            raise ValueError("Missing the required parameter `room_attribute_id` when calling `update_room_attribute`")  # noqa: E501
        # verify the required parameter 'room_attribute_item' is set
        if ('room_attribute_item' not in params or
                params['room_attribute_item'] is None):
            raise ValueError("Missing the required parameter `room_attribute_item` when calling `update_room_attribute`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_attribute_id' in params:
            path_params['RoomAttributeID'] = params['room_attribute_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_attribute_item' in params:
            body_params = params['room_attribute_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomAttribute/{RoomAttributeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomAttributeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_base(self, room_base_id, room_base_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomBase in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_base(room_base_id, room_base_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_base_id: Numeric value of the roombaseID (required)
        :param RoomBaseItem room_base_item: RoomBase to update (required)
        :return: list[RoomBaseItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_base_with_http_info(room_base_id, room_base_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_base_with_http_info(room_base_id, room_base_item, **kwargs)  # noqa: E501
            return data

    def update_room_base_with_http_info(self, room_base_id, room_base_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomBase in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_base_with_http_info(room_base_id, room_base_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_base_id: Numeric value of the roombaseID (required)
        :param RoomBaseItem room_base_item: RoomBase to update (required)
        :return: list[RoomBaseItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_base_id', 'room_base_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_base" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_base_id' is set
        if ('room_base_id' not in params or
                params['room_base_id'] is None):
            raise ValueError("Missing the required parameter `room_base_id` when calling `update_room_base`")  # noqa: E501
        # verify the required parameter 'room_base_item' is set
        if ('room_base_item' not in params or
                params['room_base_item'] is None):
            raise ValueError("Missing the required parameter `room_base_item` when calling `update_room_base`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_base_id' in params:
            path_params['RoomBaseID'] = params['room_base_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_base_item' in params:
            body_params = params['room_base_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomBase/{RoomBaseID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomBaseItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_base_gender(self, room_base_gender_id, room_base_gender_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomBaseGender in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_base_gender(room_base_gender_id, room_base_gender_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_base_gender_id: Numeric value of the roombasegenderID (required)
        :param RoomBaseGenderItem room_base_gender_item: RoomBaseGender to update (required)
        :return: list[RoomBaseGenderItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_base_gender_with_http_info(room_base_gender_id, room_base_gender_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_base_gender_with_http_info(room_base_gender_id, room_base_gender_item, **kwargs)  # noqa: E501
            return data

    def update_room_base_gender_with_http_info(self, room_base_gender_id, room_base_gender_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomBaseGender in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_base_gender_with_http_info(room_base_gender_id, room_base_gender_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_base_gender_id: Numeric value of the roombasegenderID (required)
        :param RoomBaseGenderItem room_base_gender_item: RoomBaseGender to update (required)
        :return: list[RoomBaseGenderItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_base_gender_id', 'room_base_gender_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_base_gender" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_base_gender_id' is set
        if ('room_base_gender_id' not in params or
                params['room_base_gender_id'] is None):
            raise ValueError("Missing the required parameter `room_base_gender_id` when calling `update_room_base_gender`")  # noqa: E501
        # verify the required parameter 'room_base_gender_item' is set
        if ('room_base_gender_item' not in params or
                params['room_base_gender_item'] is None):
            raise ValueError("Missing the required parameter `room_base_gender_item` when calling `update_room_base_gender`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_base_gender_id' in params:
            path_params['RoomBaseGenderID'] = params['room_base_gender_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_base_gender_item' in params:
            body_params = params['room_base_gender_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomBaseGender/{RoomBaseGenderID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomBaseGenderItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_classification(self, room_classification_id, room_classification_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_classification(room_classification_id, room_classification_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_classification_id: Numeric value of the roomclassificationID (required)
        :param RoomClassificationItem room_classification_item: RoomClassification to update (required)
        :return: list[RoomClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_classification_with_http_info(room_classification_id, room_classification_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_classification_with_http_info(room_classification_id, room_classification_item, **kwargs)  # noqa: E501
            return data

    def update_room_classification_with_http_info(self, room_classification_id, room_classification_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_classification_with_http_info(room_classification_id, room_classification_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_classification_id: Numeric value of the roomclassificationID (required)
        :param RoomClassificationItem room_classification_item: RoomClassification to update (required)
        :return: list[RoomClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_classification_id', 'room_classification_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_classification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_classification_id' is set
        if ('room_classification_id' not in params or
                params['room_classification_id'] is None):
            raise ValueError("Missing the required parameter `room_classification_id` when calling `update_room_classification`")  # noqa: E501
        # verify the required parameter 'room_classification_item' is set
        if ('room_classification_item' not in params or
                params['room_classification_item'] is None):
            raise ValueError("Missing the required parameter `room_classification_item` when calling `update_room_classification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_classification_id' in params:
            path_params['RoomClassificationID'] = params['room_classification_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_classification_item' in params:
            body_params = params['room_classification_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomClassification/{RoomClassificationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomClassificationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_configuration(self, room_configuration_id, room_configuration_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomConfiguration in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_configuration(room_configuration_id, room_configuration_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_id: Numeric value of the roomconfigurationID (required)
        :param RoomConfigurationItem room_configuration_item: RoomConfiguration to update (required)
        :return: list[RoomConfigurationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_configuration_with_http_info(room_configuration_id, room_configuration_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_configuration_with_http_info(room_configuration_id, room_configuration_item, **kwargs)  # noqa: E501
            return data

    def update_room_configuration_with_http_info(self, room_configuration_id, room_configuration_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomConfiguration in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_configuration_with_http_info(room_configuration_id, room_configuration_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_id: Numeric value of the roomconfigurationID (required)
        :param RoomConfigurationItem room_configuration_item: RoomConfiguration to update (required)
        :return: list[RoomConfigurationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_configuration_id', 'room_configuration_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_configuration_id' is set
        if ('room_configuration_id' not in params or
                params['room_configuration_id'] is None):
            raise ValueError("Missing the required parameter `room_configuration_id` when calling `update_room_configuration`")  # noqa: E501
        # verify the required parameter 'room_configuration_item' is set
        if ('room_configuration_item' not in params or
                params['room_configuration_item'] is None):
            raise ValueError("Missing the required parameter `room_configuration_item` when calling `update_room_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_configuration_id' in params:
            path_params['RoomConfigurationID'] = params['room_configuration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_configuration_item' in params:
            body_params = params['room_configuration_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomConfiguration/{RoomConfigurationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomConfigurationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_configuration_attribute(self, room_configuration_attribute_id, room_configuration_attribute_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomConfigurationAttribute in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_configuration_attribute(room_configuration_attribute_id, room_configuration_attribute_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_attribute_id: Numeric value of the roomconfigurationattributeID (required)
        :param RoomConfigurationAttributeItem room_configuration_attribute_item: RoomConfigurationAttribute to update (required)
        :return: list[RoomConfigurationAttributeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_configuration_attribute_with_http_info(room_configuration_attribute_id, room_configuration_attribute_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_configuration_attribute_with_http_info(room_configuration_attribute_id, room_configuration_attribute_item, **kwargs)  # noqa: E501
            return data

    def update_room_configuration_attribute_with_http_info(self, room_configuration_attribute_id, room_configuration_attribute_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomConfigurationAttribute in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_configuration_attribute_with_http_info(room_configuration_attribute_id, room_configuration_attribute_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_attribute_id: Numeric value of the roomconfigurationattributeID (required)
        :param RoomConfigurationAttributeItem room_configuration_attribute_item: RoomConfigurationAttribute to update (required)
        :return: list[RoomConfigurationAttributeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_configuration_attribute_id', 'room_configuration_attribute_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_configuration_attribute" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_configuration_attribute_id' is set
        if ('room_configuration_attribute_id' not in params or
                params['room_configuration_attribute_id'] is None):
            raise ValueError("Missing the required parameter `room_configuration_attribute_id` when calling `update_room_configuration_attribute`")  # noqa: E501
        # verify the required parameter 'room_configuration_attribute_item' is set
        if ('room_configuration_attribute_item' not in params or
                params['room_configuration_attribute_item'] is None):
            raise ValueError("Missing the required parameter `room_configuration_attribute_item` when calling `update_room_configuration_attribute`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_configuration_attribute_id' in params:
            path_params['RoomConfigurationAttributeID'] = params['room_configuration_attribute_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_configuration_attribute_item' in params:
            body_params = params['room_configuration_attribute_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomConfigurationAttribute/{RoomConfigurationAttributeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomConfigurationAttributeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_configuration_classification(self, room_configuration_classification_id, room_configuration_classification_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomConfigurationClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_configuration_classification(room_configuration_classification_id, room_configuration_classification_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_classification_id: Numeric value of the roomconfigurationclassificationID (required)
        :param RoomConfigurationClassificationItem room_configuration_classification_item: RoomConfigurationClassification to update (required)
        :return: list[RoomConfigurationClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_configuration_classification_with_http_info(room_configuration_classification_id, room_configuration_classification_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_configuration_classification_with_http_info(room_configuration_classification_id, room_configuration_classification_item, **kwargs)  # noqa: E501
            return data

    def update_room_configuration_classification_with_http_info(self, room_configuration_classification_id, room_configuration_classification_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomConfigurationClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_configuration_classification_with_http_info(room_configuration_classification_id, room_configuration_classification_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_classification_id: Numeric value of the roomconfigurationclassificationID (required)
        :param RoomConfigurationClassificationItem room_configuration_classification_item: RoomConfigurationClassification to update (required)
        :return: list[RoomConfigurationClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_configuration_classification_id', 'room_configuration_classification_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_configuration_classification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_configuration_classification_id' is set
        if ('room_configuration_classification_id' not in params or
                params['room_configuration_classification_id'] is None):
            raise ValueError("Missing the required parameter `room_configuration_classification_id` when calling `update_room_configuration_classification`")  # noqa: E501
        # verify the required parameter 'room_configuration_classification_item' is set
        if ('room_configuration_classification_item' not in params or
                params['room_configuration_classification_item'] is None):
            raise ValueError("Missing the required parameter `room_configuration_classification_item` when calling `update_room_configuration_classification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_configuration_classification_id' in params:
            path_params['RoomConfigurationClassificationID'] = params['room_configuration_classification_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_configuration_classification_item' in params:
            body_params = params['room_configuration_classification_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomConfigurationClassification/{RoomConfigurationClassificationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomConfigurationClassificationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_configuration_profile(self, room_configuration_profile_id, room_configuration_profile_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomConfigurationProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_configuration_profile(room_configuration_profile_id, room_configuration_profile_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_profile_id: Numeric value of the roomconfigurationprofileID (required)
        :param RoomConfigurationProfileItem room_configuration_profile_item: RoomConfigurationProfile to update (required)
        :return: list[RoomConfigurationProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_configuration_profile_with_http_info(room_configuration_profile_id, room_configuration_profile_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_configuration_profile_with_http_info(room_configuration_profile_id, room_configuration_profile_item, **kwargs)  # noqa: E501
            return data

    def update_room_configuration_profile_with_http_info(self, room_configuration_profile_id, room_configuration_profile_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomConfigurationProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_configuration_profile_with_http_info(room_configuration_profile_id, room_configuration_profile_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_profile_id: Numeric value of the roomconfigurationprofileID (required)
        :param RoomConfigurationProfileItem room_configuration_profile_item: RoomConfigurationProfile to update (required)
        :return: list[RoomConfigurationProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_configuration_profile_id', 'room_configuration_profile_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_configuration_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_configuration_profile_id' is set
        if ('room_configuration_profile_id' not in params or
                params['room_configuration_profile_id'] is None):
            raise ValueError("Missing the required parameter `room_configuration_profile_id` when calling `update_room_configuration_profile`")  # noqa: E501
        # verify the required parameter 'room_configuration_profile_item' is set
        if ('room_configuration_profile_item' not in params or
                params['room_configuration_profile_item'] is None):
            raise ValueError("Missing the required parameter `room_configuration_profile_item` when calling `update_room_configuration_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_configuration_profile_id' in params:
            path_params['RoomConfigurationProfileID'] = params['room_configuration_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_configuration_profile_item' in params:
            body_params = params['room_configuration_profile_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomConfigurationProfile/{RoomConfigurationProfileID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomConfigurationProfileItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_configuration_room_sort(self, room_configuration_room_sort_id, room_configuration_room_sort_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomConfigurationRoomSort in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_configuration_room_sort(room_configuration_room_sort_id, room_configuration_room_sort_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_room_sort_id: Numeric value of the roomconfigurationroomsortID (required)
        :param RoomConfigurationRoomSortItem room_configuration_room_sort_item: RoomConfigurationRoomSort to update (required)
        :return: list[RoomConfigurationRoomSortItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_configuration_room_sort_with_http_info(room_configuration_room_sort_id, room_configuration_room_sort_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_configuration_room_sort_with_http_info(room_configuration_room_sort_id, room_configuration_room_sort_item, **kwargs)  # noqa: E501
            return data

    def update_room_configuration_room_sort_with_http_info(self, room_configuration_room_sort_id, room_configuration_room_sort_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomConfigurationRoomSort in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_configuration_room_sort_with_http_info(room_configuration_room_sort_id, room_configuration_room_sort_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_room_sort_id: Numeric value of the roomconfigurationroomsortID (required)
        :param RoomConfigurationRoomSortItem room_configuration_room_sort_item: RoomConfigurationRoomSort to update (required)
        :return: list[RoomConfigurationRoomSortItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_configuration_room_sort_id', 'room_configuration_room_sort_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_configuration_room_sort" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_configuration_room_sort_id' is set
        if ('room_configuration_room_sort_id' not in params or
                params['room_configuration_room_sort_id'] is None):
            raise ValueError("Missing the required parameter `room_configuration_room_sort_id` when calling `update_room_configuration_room_sort`")  # noqa: E501
        # verify the required parameter 'room_configuration_room_sort_item' is set
        if ('room_configuration_room_sort_item' not in params or
                params['room_configuration_room_sort_item'] is None):
            raise ValueError("Missing the required parameter `room_configuration_room_sort_item` when calling `update_room_configuration_room_sort`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_configuration_room_sort_id' in params:
            path_params['RoomConfigurationRoomSortID'] = params['room_configuration_room_sort_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_configuration_room_sort_item' in params:
            body_params = params['room_configuration_room_sort_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomConfigurationRoomSort/{RoomConfigurationRoomSortID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomConfigurationRoomSortItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_configuration_term_type(self, room_configuration_term_type_id, room_configuration_term_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomConfigurationTermType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_configuration_term_type(room_configuration_term_type_id, room_configuration_term_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_term_type_id: Numeric value of the roomconfigurationtermtypeID (required)
        :param RoomConfigurationTermTypeItem room_configuration_term_type_item: RoomConfigurationTermType to update (required)
        :return: list[RoomConfigurationTermTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_configuration_term_type_with_http_info(room_configuration_term_type_id, room_configuration_term_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_configuration_term_type_with_http_info(room_configuration_term_type_id, room_configuration_term_type_item, **kwargs)  # noqa: E501
            return data

    def update_room_configuration_term_type_with_http_info(self, room_configuration_term_type_id, room_configuration_term_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomConfigurationTermType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_configuration_term_type_with_http_info(room_configuration_term_type_id, room_configuration_term_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_configuration_term_type_id: Numeric value of the roomconfigurationtermtypeID (required)
        :param RoomConfigurationTermTypeItem room_configuration_term_type_item: RoomConfigurationTermType to update (required)
        :return: list[RoomConfigurationTermTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_configuration_term_type_id', 'room_configuration_term_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_configuration_term_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_configuration_term_type_id' is set
        if ('room_configuration_term_type_id' not in params or
                params['room_configuration_term_type_id'] is None):
            raise ValueError("Missing the required parameter `room_configuration_term_type_id` when calling `update_room_configuration_term_type`")  # noqa: E501
        # verify the required parameter 'room_configuration_term_type_item' is set
        if ('room_configuration_term_type_item' not in params or
                params['room_configuration_term_type_item'] is None):
            raise ValueError("Missing the required parameter `room_configuration_term_type_item` when calling `update_room_configuration_term_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_configuration_term_type_id' in params:
            path_params['RoomConfigurationTermTypeID'] = params['room_configuration_term_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_configuration_term_type_item' in params:
            body_params = params['room_configuration_term_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomConfigurationTermType/{RoomConfigurationTermTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomConfigurationTermTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_location(self, room_location_id, room_location_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomLocation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_location(room_location_id, room_location_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_id: Numeric value of the roomlocationID (required)
        :param RoomLocationItem room_location_item: RoomLocation to update (required)
        :return: list[RoomLocationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_location_with_http_info(room_location_id, room_location_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_location_with_http_info(room_location_id, room_location_item, **kwargs)  # noqa: E501
            return data

    def update_room_location_with_http_info(self, room_location_id, room_location_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomLocation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_location_with_http_info(room_location_id, room_location_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_id: Numeric value of the roomlocationID (required)
        :param RoomLocationItem room_location_item: RoomLocation to update (required)
        :return: list[RoomLocationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_location_id', 'room_location_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_location" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_location_id' is set
        if ('room_location_id' not in params or
                params['room_location_id'] is None):
            raise ValueError("Missing the required parameter `room_location_id` when calling `update_room_location`")  # noqa: E501
        # verify the required parameter 'room_location_item' is set
        if ('room_location_item' not in params or
                params['room_location_item'] is None):
            raise ValueError("Missing the required parameter `room_location_item` when calling `update_room_location`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_location_id' in params:
            path_params['RoomLocationID'] = params['room_location_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_location_item' in params:
            body_params = params['room_location_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomLocation/{RoomLocationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomLocationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_location_area(self, room_location_area_id, room_location_area_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomLocationArea in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_location_area(room_location_area_id, room_location_area_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_area_id: Numeric value of the roomlocationareaID (required)
        :param RoomLocationAreaItem room_location_area_item: RoomLocationArea to update (required)
        :return: list[RoomLocationAreaItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_location_area_with_http_info(room_location_area_id, room_location_area_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_location_area_with_http_info(room_location_area_id, room_location_area_item, **kwargs)  # noqa: E501
            return data

    def update_room_location_area_with_http_info(self, room_location_area_id, room_location_area_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomLocationArea in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_location_area_with_http_info(room_location_area_id, room_location_area_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_area_id: Numeric value of the roomlocationareaID (required)
        :param RoomLocationAreaItem room_location_area_item: RoomLocationArea to update (required)
        :return: list[RoomLocationAreaItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_location_area_id', 'room_location_area_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_location_area" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_location_area_id' is set
        if ('room_location_area_id' not in params or
                params['room_location_area_id'] is None):
            raise ValueError("Missing the required parameter `room_location_area_id` when calling `update_room_location_area`")  # noqa: E501
        # verify the required parameter 'room_location_area_item' is set
        if ('room_location_area_item' not in params or
                params['room_location_area_item'] is None):
            raise ValueError("Missing the required parameter `room_location_area_item` when calling `update_room_location_area`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_location_area_id' in params:
            path_params['RoomLocationAreaID'] = params['room_location_area_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_location_area_item' in params:
            body_params = params['room_location_area_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomLocationArea/{RoomLocationAreaID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomLocationAreaItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_location_classification(self, room_location_classification_id, room_location_classification_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomLocationClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_location_classification(room_location_classification_id, room_location_classification_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_classification_id: Numeric value of the roomlocationclassificationID (required)
        :param RoomLocationClassificationItem room_location_classification_item: RoomLocationClassification to update (required)
        :return: list[RoomLocationClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_location_classification_with_http_info(room_location_classification_id, room_location_classification_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_location_classification_with_http_info(room_location_classification_id, room_location_classification_item, **kwargs)  # noqa: E501
            return data

    def update_room_location_classification_with_http_info(self, room_location_classification_id, room_location_classification_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomLocationClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_location_classification_with_http_info(room_location_classification_id, room_location_classification_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_classification_id: Numeric value of the roomlocationclassificationID (required)
        :param RoomLocationClassificationItem room_location_classification_item: RoomLocationClassification to update (required)
        :return: list[RoomLocationClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_location_classification_id', 'room_location_classification_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_location_classification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_location_classification_id' is set
        if ('room_location_classification_id' not in params or
                params['room_location_classification_id'] is None):
            raise ValueError("Missing the required parameter `room_location_classification_id` when calling `update_room_location_classification`")  # noqa: E501
        # verify the required parameter 'room_location_classification_item' is set
        if ('room_location_classification_item' not in params or
                params['room_location_classification_item'] is None):
            raise ValueError("Missing the required parameter `room_location_classification_item` when calling `update_room_location_classification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_location_classification_id' in params:
            path_params['RoomLocationClassificationID'] = params['room_location_classification_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_location_classification_item' in params:
            body_params = params['room_location_classification_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomLocationClassification/{RoomLocationClassificationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomLocationClassificationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_location_floor_suite(self, room_location_floor_suite_id, room_location_floor_suite_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomLocationFloorSuite in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_location_floor_suite(room_location_floor_suite_id, room_location_floor_suite_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_floor_suite_id: Numeric value of the roomlocationfloorsuiteID (required)
        :param RoomLocationFloorSuiteItem room_location_floor_suite_item: RoomLocationFloorSuite to update (required)
        :return: list[RoomLocationFloorSuiteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_location_floor_suite_with_http_info(room_location_floor_suite_id, room_location_floor_suite_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_location_floor_suite_with_http_info(room_location_floor_suite_id, room_location_floor_suite_item, **kwargs)  # noqa: E501
            return data

    def update_room_location_floor_suite_with_http_info(self, room_location_floor_suite_id, room_location_floor_suite_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomLocationFloorSuite in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_location_floor_suite_with_http_info(room_location_floor_suite_id, room_location_floor_suite_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_floor_suite_id: Numeric value of the roomlocationfloorsuiteID (required)
        :param RoomLocationFloorSuiteItem room_location_floor_suite_item: RoomLocationFloorSuite to update (required)
        :return: list[RoomLocationFloorSuiteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_location_floor_suite_id', 'room_location_floor_suite_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_location_floor_suite" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_location_floor_suite_id' is set
        if ('room_location_floor_suite_id' not in params or
                params['room_location_floor_suite_id'] is None):
            raise ValueError("Missing the required parameter `room_location_floor_suite_id` when calling `update_room_location_floor_suite`")  # noqa: E501
        # verify the required parameter 'room_location_floor_suite_item' is set
        if ('room_location_floor_suite_item' not in params or
                params['room_location_floor_suite_item'] is None):
            raise ValueError("Missing the required parameter `room_location_floor_suite_item` when calling `update_room_location_floor_suite`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_location_floor_suite_id' in params:
            path_params['RoomLocationFloorSuiteID'] = params['room_location_floor_suite_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_location_floor_suite_item' in params:
            body_params = params['room_location_floor_suite_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomLocationFloorSuite/{RoomLocationFloorSuiteID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomLocationFloorSuiteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_location_section(self, room_location_section_id, room_location_section_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomLocationSection in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_location_section(room_location_section_id, room_location_section_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_section_id: Numeric value of the roomlocationsectionID (required)
        :param RoomLocationSectionItem room_location_section_item: RoomLocationSection to update (required)
        :return: list[RoomLocationSectionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_location_section_with_http_info(room_location_section_id, room_location_section_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_location_section_with_http_info(room_location_section_id, room_location_section_item, **kwargs)  # noqa: E501
            return data

    def update_room_location_section_with_http_info(self, room_location_section_id, room_location_section_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomLocationSection in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_location_section_with_http_info(room_location_section_id, room_location_section_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_location_section_id: Numeric value of the roomlocationsectionID (required)
        :param RoomLocationSectionItem room_location_section_item: RoomLocationSection to update (required)
        :return: list[RoomLocationSectionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_location_section_id', 'room_location_section_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_location_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_location_section_id' is set
        if ('room_location_section_id' not in params or
                params['room_location_section_id'] is None):
            raise ValueError("Missing the required parameter `room_location_section_id` when calling `update_room_location_section`")  # noqa: E501
        # verify the required parameter 'room_location_section_item' is set
        if ('room_location_section_item' not in params or
                params['room_location_section_item'] is None):
            raise ValueError("Missing the required parameter `room_location_section_item` when calling `update_room_location_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_location_section_id' in params:
            path_params['RoomLocationSectionID'] = params['room_location_section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_location_section_item' in params:
            body_params = params['room_location_section_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomLocationSection/{RoomLocationSectionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomLocationSectionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_manager(self, room_manager_id, room_manager_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomManager in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_manager(room_manager_id, room_manager_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_manager_id: Numeric value of the roommanagerID (required)
        :param RoomManagerItem room_manager_item: RoomManager to update (required)
        :return: list[RoomManagerItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_manager_with_http_info(room_manager_id, room_manager_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_manager_with_http_info(room_manager_id, room_manager_item, **kwargs)  # noqa: E501
            return data

    def update_room_manager_with_http_info(self, room_manager_id, room_manager_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomManager in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_manager_with_http_info(room_manager_id, room_manager_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_manager_id: Numeric value of the roommanagerID (required)
        :param RoomManagerItem room_manager_item: RoomManager to update (required)
        :return: list[RoomManagerItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_manager_id', 'room_manager_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_manager" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_manager_id' is set
        if ('room_manager_id' not in params or
                params['room_manager_id'] is None):
            raise ValueError("Missing the required parameter `room_manager_id` when calling `update_room_manager`")  # noqa: E501
        # verify the required parameter 'room_manager_item' is set
        if ('room_manager_item' not in params or
                params['room_manager_item'] is None):
            raise ValueError("Missing the required parameter `room_manager_item` when calling `update_room_manager`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_manager_id' in params:
            path_params['RoomManagerID'] = params['room_manager_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_manager_item' in params:
            body_params = params['room_manager_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomManager/{RoomManagerID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomManagerItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_preference(self, room_preference_id, room_preference_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomPreference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_preference(room_preference_id, room_preference_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_preference_id: Numeric value of the roompreferenceID (required)
        :param RoomPreferenceItem room_preference_item: RoomPreference to update (required)
        :return: list[RoomPreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_preference_with_http_info(room_preference_id, room_preference_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_preference_with_http_info(room_preference_id, room_preference_item, **kwargs)  # noqa: E501
            return data

    def update_room_preference_with_http_info(self, room_preference_id, room_preference_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomPreference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_preference_with_http_info(room_preference_id, room_preference_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_preference_id: Numeric value of the roompreferenceID (required)
        :param RoomPreferenceItem room_preference_item: RoomPreference to update (required)
        :return: list[RoomPreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_preference_id', 'room_preference_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_preference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_preference_id' is set
        if ('room_preference_id' not in params or
                params['room_preference_id'] is None):
            raise ValueError("Missing the required parameter `room_preference_id` when calling `update_room_preference`")  # noqa: E501
        # verify the required parameter 'room_preference_item' is set
        if ('room_preference_item' not in params or
                params['room_preference_item'] is None):
            raise ValueError("Missing the required parameter `room_preference_item` when calling `update_room_preference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_preference_id' in params:
            path_params['RoomPreferenceID'] = params['room_preference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_preference_item' in params:
            body_params = params['room_preference_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomPreference/{RoomPreferenceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomPreferenceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_profile(self, room_profile_id, room_profile_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_profile(room_profile_id, room_profile_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_profile_id: Numeric value of the roomprofileID (required)
        :param RoomProfileItem room_profile_item: RoomProfile to update (required)
        :return: list[RoomProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_profile_with_http_info(room_profile_id, room_profile_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_profile_with_http_info(room_profile_id, room_profile_item, **kwargs)  # noqa: E501
            return data

    def update_room_profile_with_http_info(self, room_profile_id, room_profile_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_profile_with_http_info(room_profile_id, room_profile_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_profile_id: Numeric value of the roomprofileID (required)
        :param RoomProfileItem room_profile_item: RoomProfile to update (required)
        :return: list[RoomProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_profile_id', 'room_profile_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_profile_id' is set
        if ('room_profile_id' not in params or
                params['room_profile_id'] is None):
            raise ValueError("Missing the required parameter `room_profile_id` when calling `update_room_profile`")  # noqa: E501
        # verify the required parameter 'room_profile_item' is set
        if ('room_profile_item' not in params or
                params['room_profile_item'] is None):
            raise ValueError("Missing the required parameter `room_profile_item` when calling `update_room_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_profile_id' in params:
            path_params['RoomProfileID'] = params['room_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_profile_item' in params:
            body_params = params['room_profile_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomProfile/{RoomProfileID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomProfileItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_rate(self, room_rate_id, room_rate_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomRate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_rate(room_rate_id, room_rate_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_rate_id: Numeric value of the roomrateID (required)
        :param RoomRateItem room_rate_item: RoomRate to update (required)
        :return: list[RoomRateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_rate_with_http_info(room_rate_id, room_rate_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_rate_with_http_info(room_rate_id, room_rate_item, **kwargs)  # noqa: E501
            return data

    def update_room_rate_with_http_info(self, room_rate_id, room_rate_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomRate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_rate_with_http_info(room_rate_id, room_rate_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_rate_id: Numeric value of the roomrateID (required)
        :param RoomRateItem room_rate_item: RoomRate to update (required)
        :return: list[RoomRateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_rate_id', 'room_rate_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_rate" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_rate_id' is set
        if ('room_rate_id' not in params or
                params['room_rate_id'] is None):
            raise ValueError("Missing the required parameter `room_rate_id` when calling `update_room_rate`")  # noqa: E501
        # verify the required parameter 'room_rate_item' is set
        if ('room_rate_item' not in params or
                params['room_rate_item'] is None):
            raise ValueError("Missing the required parameter `room_rate_item` when calling `update_room_rate`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_rate_id' in params:
            path_params['RoomRateID'] = params['room_rate_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_rate_item' in params:
            body_params = params['room_rate_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomRate/{RoomRateID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomRateItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_rate_charge(self, room_rate_charge_id, room_rate_charge_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomRateCharge in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_rate_charge(room_rate_charge_id, room_rate_charge_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_rate_charge_id: Numeric value of the roomratechargeID (required)
        :param RoomRateChargeItem room_rate_charge_item: RoomRateCharge to update (required)
        :return: list[RoomRateChargeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_rate_charge_with_http_info(room_rate_charge_id, room_rate_charge_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_rate_charge_with_http_info(room_rate_charge_id, room_rate_charge_item, **kwargs)  # noqa: E501
            return data

    def update_room_rate_charge_with_http_info(self, room_rate_charge_id, room_rate_charge_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomRateCharge in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_rate_charge_with_http_info(room_rate_charge_id, room_rate_charge_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_rate_charge_id: Numeric value of the roomratechargeID (required)
        :param RoomRateChargeItem room_rate_charge_item: RoomRateCharge to update (required)
        :return: list[RoomRateChargeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_rate_charge_id', 'room_rate_charge_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_rate_charge" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_rate_charge_id' is set
        if ('room_rate_charge_id' not in params or
                params['room_rate_charge_id'] is None):
            raise ValueError("Missing the required parameter `room_rate_charge_id` when calling `update_room_rate_charge`")  # noqa: E501
        # verify the required parameter 'room_rate_charge_item' is set
        if ('room_rate_charge_item' not in params or
                params['room_rate_charge_item'] is None):
            raise ValueError("Missing the required parameter `room_rate_charge_item` when calling `update_room_rate_charge`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_rate_charge_id' in params:
            path_params['RoomRateChargeID'] = params['room_rate_charge_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_rate_charge_item' in params:
            body_params = params['room_rate_charge_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomRateCharge/{RoomRateChargeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomRateChargeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_rate_room_type_location(self, room_rate_room_type_location_id, room_rate_room_type_location_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomRateRoomTypeLocation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_rate_room_type_location(room_rate_room_type_location_id, room_rate_room_type_location_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_rate_room_type_location_id: Numeric value of the roomrateroomtypelocationID (required)
        :param RoomRateRoomTypeLocationItem room_rate_room_type_location_item: RoomRateRoomTypeLocation to update (required)
        :return: list[RoomRateRoomTypeLocationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_rate_room_type_location_with_http_info(room_rate_room_type_location_id, room_rate_room_type_location_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_rate_room_type_location_with_http_info(room_rate_room_type_location_id, room_rate_room_type_location_item, **kwargs)  # noqa: E501
            return data

    def update_room_rate_room_type_location_with_http_info(self, room_rate_room_type_location_id, room_rate_room_type_location_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomRateRoomTypeLocation in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_rate_room_type_location_with_http_info(room_rate_room_type_location_id, room_rate_room_type_location_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_rate_room_type_location_id: Numeric value of the roomrateroomtypelocationID (required)
        :param RoomRateRoomTypeLocationItem room_rate_room_type_location_item: RoomRateRoomTypeLocation to update (required)
        :return: list[RoomRateRoomTypeLocationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_rate_room_type_location_id', 'room_rate_room_type_location_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_rate_room_type_location" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_rate_room_type_location_id' is set
        if ('room_rate_room_type_location_id' not in params or
                params['room_rate_room_type_location_id'] is None):
            raise ValueError("Missing the required parameter `room_rate_room_type_location_id` when calling `update_room_rate_room_type_location`")  # noqa: E501
        # verify the required parameter 'room_rate_room_type_location_item' is set
        if ('room_rate_room_type_location_item' not in params or
                params['room_rate_room_type_location_item'] is None):
            raise ValueError("Missing the required parameter `room_rate_room_type_location_item` when calling `update_room_rate_room_type_location`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_rate_room_type_location_id' in params:
            path_params['RoomRateRoomTypeLocationID'] = params['room_rate_room_type_location_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_rate_room_type_location_item' in params:
            body_params = params['room_rate_room_type_location_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomRateRoomTypeLocation/{RoomRateRoomTypeLocationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomRateRoomTypeLocationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_rate_session(self, room_rate_session_id, room_rate_session_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomRateSession in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_rate_session(room_rate_session_id, room_rate_session_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_rate_session_id: Numeric value of the roomratesessionID (required)
        :param RoomRateSessionItem room_rate_session_item: RoomRateSession to update (required)
        :return: list[RoomRateSessionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_rate_session_with_http_info(room_rate_session_id, room_rate_session_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_rate_session_with_http_info(room_rate_session_id, room_rate_session_item, **kwargs)  # noqa: E501
            return data

    def update_room_rate_session_with_http_info(self, room_rate_session_id, room_rate_session_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomRateSession in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_rate_session_with_http_info(room_rate_session_id, room_rate_session_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_rate_session_id: Numeric value of the roomratesessionID (required)
        :param RoomRateSessionItem room_rate_session_item: RoomRateSession to update (required)
        :return: list[RoomRateSessionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_rate_session_id', 'room_rate_session_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_rate_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_rate_session_id' is set
        if ('room_rate_session_id' not in params or
                params['room_rate_session_id'] is None):
            raise ValueError("Missing the required parameter `room_rate_session_id` when calling `update_room_rate_session`")  # noqa: E501
        # verify the required parameter 'room_rate_session_item' is set
        if ('room_rate_session_item' not in params or
                params['room_rate_session_item'] is None):
            raise ValueError("Missing the required parameter `room_rate_session_item` when calling `update_room_rate_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_rate_session_id' in params:
            path_params['RoomRateSessionID'] = params['room_rate_session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_rate_session_item' in params:
            body_params = params['room_rate_session_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomRateSession/{RoomRateSessionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomRateSessionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_sort_configuration(self, room_sort_configuration_id, room_sort_configuration_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSortConfiguration in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_sort_configuration(room_sort_configuration_id, room_sort_configuration_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_sort_configuration_id: Numeric value of the roomsortconfigurationID (required)
        :param RoomSortConfigurationItem room_sort_configuration_item: RoomSortConfiguration to update (required)
        :return: list[RoomSortConfigurationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_sort_configuration_with_http_info(room_sort_configuration_id, room_sort_configuration_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_sort_configuration_with_http_info(room_sort_configuration_id, room_sort_configuration_item, **kwargs)  # noqa: E501
            return data

    def update_room_sort_configuration_with_http_info(self, room_sort_configuration_id, room_sort_configuration_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSortConfiguration in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_sort_configuration_with_http_info(room_sort_configuration_id, room_sort_configuration_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_sort_configuration_id: Numeric value of the roomsortconfigurationID (required)
        :param RoomSortConfigurationItem room_sort_configuration_item: RoomSortConfiguration to update (required)
        :return: list[RoomSortConfigurationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_sort_configuration_id', 'room_sort_configuration_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_sort_configuration" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_sort_configuration_id' is set
        if ('room_sort_configuration_id' not in params or
                params['room_sort_configuration_id'] is None):
            raise ValueError("Missing the required parameter `room_sort_configuration_id` when calling `update_room_sort_configuration`")  # noqa: E501
        # verify the required parameter 'room_sort_configuration_item' is set
        if ('room_sort_configuration_item' not in params or
                params['room_sort_configuration_item'] is None):
            raise ValueError("Missing the required parameter `room_sort_configuration_item` when calling `update_room_sort_configuration`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_sort_configuration_id' in params:
            path_params['RoomSortConfigurationID'] = params['room_sort_configuration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_sort_configuration_item' in params:
            body_params = params['room_sort_configuration_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSortConfiguration/{RoomSortConfigurationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSortConfigurationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_sort_profile(self, room_sort_profile_id, room_sort_profile_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSortProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_sort_profile(room_sort_profile_id, room_sort_profile_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_sort_profile_id: Numeric value of the roomsortprofileID (required)
        :param RoomSortProfileItem room_sort_profile_item: RoomSortProfile to update (required)
        :return: list[RoomSortProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_sort_profile_with_http_info(room_sort_profile_id, room_sort_profile_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_sort_profile_with_http_info(room_sort_profile_id, room_sort_profile_item, **kwargs)  # noqa: E501
            return data

    def update_room_sort_profile_with_http_info(self, room_sort_profile_id, room_sort_profile_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSortProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_sort_profile_with_http_info(room_sort_profile_id, room_sort_profile_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_sort_profile_id: Numeric value of the roomsortprofileID (required)
        :param RoomSortProfileItem room_sort_profile_item: RoomSortProfile to update (required)
        :return: list[RoomSortProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_sort_profile_id', 'room_sort_profile_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_sort_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_sort_profile_id' is set
        if ('room_sort_profile_id' not in params or
                params['room_sort_profile_id'] is None):
            raise ValueError("Missing the required parameter `room_sort_profile_id` when calling `update_room_sort_profile`")  # noqa: E501
        # verify the required parameter 'room_sort_profile_item' is set
        if ('room_sort_profile_item' not in params or
                params['room_sort_profile_item'] is None):
            raise ValueError("Missing the required parameter `room_sort_profile_item` when calling `update_room_sort_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_sort_profile_id' in params:
            path_params['RoomSortProfileID'] = params['room_sort_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_sort_profile_item' in params:
            body_params = params['room_sort_profile_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSortProfile/{RoomSortProfileID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSortProfileItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_sort_profile_item(self, room_sort_profile_item_id, room_sort_profile_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSortProfileItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_sort_profile_item(room_sort_profile_item_id, room_sort_profile_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_sort_profile_item_id: Numeric value of the roomsortprofileitemID (required)
        :param RoomSortProfileItemItem room_sort_profile_item_item: RoomSortProfileItem to update (required)
        :return: list[RoomSortProfileItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_sort_profile_item_with_http_info(room_sort_profile_item_id, room_sort_profile_item_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_sort_profile_item_with_http_info(room_sort_profile_item_id, room_sort_profile_item_item, **kwargs)  # noqa: E501
            return data

    def update_room_sort_profile_item_with_http_info(self, room_sort_profile_item_id, room_sort_profile_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSortProfileItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_sort_profile_item_with_http_info(room_sort_profile_item_id, room_sort_profile_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_sort_profile_item_id: Numeric value of the roomsortprofileitemID (required)
        :param RoomSortProfileItemItem room_sort_profile_item_item: RoomSortProfileItem to update (required)
        :return: list[RoomSortProfileItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_sort_profile_item_id', 'room_sort_profile_item_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_sort_profile_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_sort_profile_item_id' is set
        if ('room_sort_profile_item_id' not in params or
                params['room_sort_profile_item_id'] is None):
            raise ValueError("Missing the required parameter `room_sort_profile_item_id` when calling `update_room_sort_profile_item`")  # noqa: E501
        # verify the required parameter 'room_sort_profile_item_item' is set
        if ('room_sort_profile_item_item' not in params or
                params['room_sort_profile_item_item'] is None):
            raise ValueError("Missing the required parameter `room_sort_profile_item_item` when calling `update_room_sort_profile_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_sort_profile_item_id' in params:
            path_params['RoomSortProfileItemID'] = params['room_sort_profile_item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_sort_profile_item_item' in params:
            body_params = params['room_sort_profile_item_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSortProfileItem/{RoomSortProfileItemID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSortProfileItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space(self, room_space_id, room_space_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpace in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space(room_space_id, room_space_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_id: Numeric value of the roomspaceID (required)
        :param RoomSpaceItem room_space_item: RoomSpace to update (required)
        :return: list[RoomSpaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_with_http_info(room_space_id, room_space_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_with_http_info(room_space_id, room_space_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_with_http_info(self, room_space_id, room_space_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpace in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_with_http_info(room_space_id, room_space_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_id: Numeric value of the roomspaceID (required)
        :param RoomSpaceItem room_space_item: RoomSpace to update (required)
        :return: list[RoomSpaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_id', 'room_space_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_id' is set
        if ('room_space_id' not in params or
                params['room_space_id'] is None):
            raise ValueError("Missing the required parameter `room_space_id` when calling `update_room_space`")  # noqa: E501
        # verify the required parameter 'room_space_item' is set
        if ('room_space_item' not in params or
                params['room_space_item'] is None):
            raise ValueError("Missing the required parameter `room_space_item` when calling `update_room_space`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_id' in params:
            path_params['RoomSpaceID'] = params['room_space_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_item' in params:
            body_params = params['room_space_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpace/{RoomSpaceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_closed(self, room_space_closed_id, room_space_closed_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceClosed in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_closed(room_space_closed_id, room_space_closed_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_closed_id: Numeric value of the roomspaceclosedID (required)
        :param RoomSpaceClosedItem room_space_closed_item: RoomSpaceClosed to update (required)
        :return: list[RoomSpaceClosedItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_closed_with_http_info(room_space_closed_id, room_space_closed_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_closed_with_http_info(room_space_closed_id, room_space_closed_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_closed_with_http_info(self, room_space_closed_id, room_space_closed_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceClosed in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_closed_with_http_info(room_space_closed_id, room_space_closed_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_closed_id: Numeric value of the roomspaceclosedID (required)
        :param RoomSpaceClosedItem room_space_closed_item: RoomSpaceClosed to update (required)
        :return: list[RoomSpaceClosedItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_closed_id', 'room_space_closed_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_closed" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_closed_id' is set
        if ('room_space_closed_id' not in params or
                params['room_space_closed_id'] is None):
            raise ValueError("Missing the required parameter `room_space_closed_id` when calling `update_room_space_closed`")  # noqa: E501
        # verify the required parameter 'room_space_closed_item' is set
        if ('room_space_closed_item' not in params or
                params['room_space_closed_item'] is None):
            raise ValueError("Missing the required parameter `room_space_closed_item` when calling `update_room_space_closed`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_closed_id' in params:
            path_params['RoomSpaceClosedID'] = params['room_space_closed_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_closed_item' in params:
            body_params = params['room_space_closed_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceClosed/{RoomSpaceClosedID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceClosedItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_detail(self, room_space_detail_id, room_space_detail_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_detail(room_space_detail_id, room_space_detail_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_detail_id: Numeric value of the roomspacedetailID (required)
        :param RoomSpaceDetailItem room_space_detail_item: RoomSpaceDetail to update (required)
        :return: list[RoomSpaceDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_detail_with_http_info(room_space_detail_id, room_space_detail_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_detail_with_http_info(room_space_detail_id, room_space_detail_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_detail_with_http_info(self, room_space_detail_id, room_space_detail_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceDetail in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_detail_with_http_info(room_space_detail_id, room_space_detail_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_detail_id: Numeric value of the roomspacedetailID (required)
        :param RoomSpaceDetailItem room_space_detail_item: RoomSpaceDetail to update (required)
        :return: list[RoomSpaceDetailItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_detail_id', 'room_space_detail_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_detail" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_detail_id' is set
        if ('room_space_detail_id' not in params or
                params['room_space_detail_id'] is None):
            raise ValueError("Missing the required parameter `room_space_detail_id` when calling `update_room_space_detail`")  # noqa: E501
        # verify the required parameter 'room_space_detail_item' is set
        if ('room_space_detail_item' not in params or
                params['room_space_detail_item'] is None):
            raise ValueError("Missing the required parameter `room_space_detail_item` when calling `update_room_space_detail`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_detail_id' in params:
            path_params['RoomSpaceDetailID'] = params['room_space_detail_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_detail_item' in params:
            body_params = params['room_space_detail_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceDetail/{RoomSpaceDetailID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceDetailItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_inventory(self, room_space_inventory_id, room_space_inventory_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceInventory in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_inventory(room_space_inventory_id, room_space_inventory_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_id: Numeric value of the roomspaceinventoryID (required)
        :param RoomSpaceInventoryItem room_space_inventory_item: RoomSpaceInventory to update (required)
        :return: list[RoomSpaceInventoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_inventory_with_http_info(room_space_inventory_id, room_space_inventory_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_inventory_with_http_info(room_space_inventory_id, room_space_inventory_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_inventory_with_http_info(self, room_space_inventory_id, room_space_inventory_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceInventory in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_inventory_with_http_info(room_space_inventory_id, room_space_inventory_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_id: Numeric value of the roomspaceinventoryID (required)
        :param RoomSpaceInventoryItem room_space_inventory_item: RoomSpaceInventory to update (required)
        :return: list[RoomSpaceInventoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_inventory_id', 'room_space_inventory_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_inventory" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_inventory_id' is set
        if ('room_space_inventory_id' not in params or
                params['room_space_inventory_id'] is None):
            raise ValueError("Missing the required parameter `room_space_inventory_id` when calling `update_room_space_inventory`")  # noqa: E501
        # verify the required parameter 'room_space_inventory_item' is set
        if ('room_space_inventory_item' not in params or
                params['room_space_inventory_item'] is None):
            raise ValueError("Missing the required parameter `room_space_inventory_item` when calling `update_room_space_inventory`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_inventory_id' in params:
            path_params['RoomSpaceInventoryID'] = params['room_space_inventory_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_inventory_item' in params:
            body_params = params['room_space_inventory_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceInventory/{RoomSpaceInventoryID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceInventoryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_inventory_condition(self, room_space_inventory_condition_id, room_space_inventory_condition_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceInventoryCondition in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_inventory_condition(room_space_inventory_condition_id, room_space_inventory_condition_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_condition_id: Numeric value of the roomspaceinventoryconditionID (required)
        :param RoomSpaceInventoryConditionItem room_space_inventory_condition_item: RoomSpaceInventoryCondition to update (required)
        :return: list[RoomSpaceInventoryConditionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_inventory_condition_with_http_info(room_space_inventory_condition_id, room_space_inventory_condition_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_inventory_condition_with_http_info(room_space_inventory_condition_id, room_space_inventory_condition_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_inventory_condition_with_http_info(self, room_space_inventory_condition_id, room_space_inventory_condition_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceInventoryCondition in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_inventory_condition_with_http_info(room_space_inventory_condition_id, room_space_inventory_condition_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_condition_id: Numeric value of the roomspaceinventoryconditionID (required)
        :param RoomSpaceInventoryConditionItem room_space_inventory_condition_item: RoomSpaceInventoryCondition to update (required)
        :return: list[RoomSpaceInventoryConditionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_inventory_condition_id', 'room_space_inventory_condition_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_inventory_condition" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_inventory_condition_id' is set
        if ('room_space_inventory_condition_id' not in params or
                params['room_space_inventory_condition_id'] is None):
            raise ValueError("Missing the required parameter `room_space_inventory_condition_id` when calling `update_room_space_inventory_condition`")  # noqa: E501
        # verify the required parameter 'room_space_inventory_condition_item' is set
        if ('room_space_inventory_condition_item' not in params or
                params['room_space_inventory_condition_item'] is None):
            raise ValueError("Missing the required parameter `room_space_inventory_condition_item` when calling `update_room_space_inventory_condition`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_inventory_condition_id' in params:
            path_params['RoomSpaceInventoryConditionID'] = params['room_space_inventory_condition_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_inventory_condition_item' in params:
            body_params = params['room_space_inventory_condition_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceInventoryCondition/{RoomSpaceInventoryConditionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceInventoryConditionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_inventory_inspection(self, room_space_inventory_inspection_id, room_space_inventory_inspection_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceInventoryInspection in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_inventory_inspection(room_space_inventory_inspection_id, room_space_inventory_inspection_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_inspection_id: Numeric value of the roomspaceinventoryinspectionID (required)
        :param RoomSpaceInventoryInspectionItem room_space_inventory_inspection_item: RoomSpaceInventoryInspection to update (required)
        :return: list[RoomSpaceInventoryInspectionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_inventory_inspection_with_http_info(room_space_inventory_inspection_id, room_space_inventory_inspection_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_inventory_inspection_with_http_info(room_space_inventory_inspection_id, room_space_inventory_inspection_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_inventory_inspection_with_http_info(self, room_space_inventory_inspection_id, room_space_inventory_inspection_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceInventoryInspection in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_inventory_inspection_with_http_info(room_space_inventory_inspection_id, room_space_inventory_inspection_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_inspection_id: Numeric value of the roomspaceinventoryinspectionID (required)
        :param RoomSpaceInventoryInspectionItem room_space_inventory_inspection_item: RoomSpaceInventoryInspection to update (required)
        :return: list[RoomSpaceInventoryInspectionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_inventory_inspection_id', 'room_space_inventory_inspection_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_inventory_inspection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_inventory_inspection_id' is set
        if ('room_space_inventory_inspection_id' not in params or
                params['room_space_inventory_inspection_id'] is None):
            raise ValueError("Missing the required parameter `room_space_inventory_inspection_id` when calling `update_room_space_inventory_inspection`")  # noqa: E501
        # verify the required parameter 'room_space_inventory_inspection_item' is set
        if ('room_space_inventory_inspection_item' not in params or
                params['room_space_inventory_inspection_item'] is None):
            raise ValueError("Missing the required parameter `room_space_inventory_inspection_item` when calling `update_room_space_inventory_inspection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_inventory_inspection_id' in params:
            path_params['RoomSpaceInventoryInspectionID'] = params['room_space_inventory_inspection_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_inventory_inspection_item' in params:
            body_params = params['room_space_inventory_inspection_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceInventoryInspection/{RoomSpaceInventoryInspectionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceInventoryInspectionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_inventory_inspection_item(self, room_space_inventory_inspection_item_id, room_space_inventory_inspection_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceInventoryInspectionItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_inventory_inspection_item(room_space_inventory_inspection_item_id, room_space_inventory_inspection_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_inspection_item_id: Numeric value of the roomspaceinventoryinspectionitemID (required)
        :param RoomSpaceInventoryInspectionItemItem room_space_inventory_inspection_item_item: RoomSpaceInventoryInspectionItem to update (required)
        :return: list[RoomSpaceInventoryInspectionItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_inventory_inspection_item_with_http_info(room_space_inventory_inspection_item_id, room_space_inventory_inspection_item_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_inventory_inspection_item_with_http_info(room_space_inventory_inspection_item_id, room_space_inventory_inspection_item_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_inventory_inspection_item_with_http_info(self, room_space_inventory_inspection_item_id, room_space_inventory_inspection_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceInventoryInspectionItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_inventory_inspection_item_with_http_info(room_space_inventory_inspection_item_id, room_space_inventory_inspection_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_inspection_item_id: Numeric value of the roomspaceinventoryinspectionitemID (required)
        :param RoomSpaceInventoryInspectionItemItem room_space_inventory_inspection_item_item: RoomSpaceInventoryInspectionItem to update (required)
        :return: list[RoomSpaceInventoryInspectionItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_inventory_inspection_item_id', 'room_space_inventory_inspection_item_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_inventory_inspection_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_inventory_inspection_item_id' is set
        if ('room_space_inventory_inspection_item_id' not in params or
                params['room_space_inventory_inspection_item_id'] is None):
            raise ValueError("Missing the required parameter `room_space_inventory_inspection_item_id` when calling `update_room_space_inventory_inspection_item`")  # noqa: E501
        # verify the required parameter 'room_space_inventory_inspection_item_item' is set
        if ('room_space_inventory_inspection_item_item' not in params or
                params['room_space_inventory_inspection_item_item'] is None):
            raise ValueError("Missing the required parameter `room_space_inventory_inspection_item_item` when calling `update_room_space_inventory_inspection_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_inventory_inspection_item_id' in params:
            path_params['RoomSpaceInventoryInspectionItemID'] = params['room_space_inventory_inspection_item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_inventory_inspection_item_item' in params:
            body_params = params['room_space_inventory_inspection_item_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceInventoryInspectionItem/{RoomSpaceInventoryInspectionItemID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceInventoryInspectionItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_inventory_inspection_run(self, room_space_inventory_inspection_run_id, room_space_inventory_inspection_run_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceInventoryInspectionRun in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_inventory_inspection_run(room_space_inventory_inspection_run_id, room_space_inventory_inspection_run_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_inspection_run_id: Numeric value of the roomspaceinventoryinspectionrunID (required)
        :param RoomSpaceInventoryInspectionRunItem room_space_inventory_inspection_run_item: RoomSpaceInventoryInspectionRun to update (required)
        :return: list[RoomSpaceInventoryInspectionRunItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_inventory_inspection_run_with_http_info(room_space_inventory_inspection_run_id, room_space_inventory_inspection_run_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_inventory_inspection_run_with_http_info(room_space_inventory_inspection_run_id, room_space_inventory_inspection_run_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_inventory_inspection_run_with_http_info(self, room_space_inventory_inspection_run_id, room_space_inventory_inspection_run_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceInventoryInspectionRun in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_inventory_inspection_run_with_http_info(room_space_inventory_inspection_run_id, room_space_inventory_inspection_run_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_inspection_run_id: Numeric value of the roomspaceinventoryinspectionrunID (required)
        :param RoomSpaceInventoryInspectionRunItem room_space_inventory_inspection_run_item: RoomSpaceInventoryInspectionRun to update (required)
        :return: list[RoomSpaceInventoryInspectionRunItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_inventory_inspection_run_id', 'room_space_inventory_inspection_run_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_inventory_inspection_run" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_inventory_inspection_run_id' is set
        if ('room_space_inventory_inspection_run_id' not in params or
                params['room_space_inventory_inspection_run_id'] is None):
            raise ValueError("Missing the required parameter `room_space_inventory_inspection_run_id` when calling `update_room_space_inventory_inspection_run`")  # noqa: E501
        # verify the required parameter 'room_space_inventory_inspection_run_item' is set
        if ('room_space_inventory_inspection_run_item' not in params or
                params['room_space_inventory_inspection_run_item'] is None):
            raise ValueError("Missing the required parameter `room_space_inventory_inspection_run_item` when calling `update_room_space_inventory_inspection_run`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_inventory_inspection_run_id' in params:
            path_params['RoomSpaceInventoryInspectionRunID'] = params['room_space_inventory_inspection_run_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_inventory_inspection_run_item' in params:
            body_params = params['room_space_inventory_inspection_run_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceInventoryInspectionRun/{RoomSpaceInventoryInspectionRunID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceInventoryInspectionRunItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_inventory_status(self, room_space_inventory_status_id, room_space_inventory_status_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceInventoryStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_inventory_status(room_space_inventory_status_id, room_space_inventory_status_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_status_id: Numeric value of the roomspaceinventorystatusID (required)
        :param RoomSpaceInventoryStatusItem room_space_inventory_status_item: RoomSpaceInventoryStatus to update (required)
        :return: list[RoomSpaceInventoryStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_inventory_status_with_http_info(room_space_inventory_status_id, room_space_inventory_status_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_inventory_status_with_http_info(room_space_inventory_status_id, room_space_inventory_status_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_inventory_status_with_http_info(self, room_space_inventory_status_id, room_space_inventory_status_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceInventoryStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_inventory_status_with_http_info(room_space_inventory_status_id, room_space_inventory_status_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_status_id: Numeric value of the roomspaceinventorystatusID (required)
        :param RoomSpaceInventoryStatusItem room_space_inventory_status_item: RoomSpaceInventoryStatus to update (required)
        :return: list[RoomSpaceInventoryStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_inventory_status_id', 'room_space_inventory_status_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_inventory_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_inventory_status_id' is set
        if ('room_space_inventory_status_id' not in params or
                params['room_space_inventory_status_id'] is None):
            raise ValueError("Missing the required parameter `room_space_inventory_status_id` when calling `update_room_space_inventory_status`")  # noqa: E501
        # verify the required parameter 'room_space_inventory_status_item' is set
        if ('room_space_inventory_status_item' not in params or
                params['room_space_inventory_status_item'] is None):
            raise ValueError("Missing the required parameter `room_space_inventory_status_item` when calling `update_room_space_inventory_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_inventory_status_id' in params:
            path_params['RoomSpaceInventoryStatusID'] = params['room_space_inventory_status_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_inventory_status_item' in params:
            body_params = params['room_space_inventory_status_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceInventoryStatus/{RoomSpaceInventoryStatusID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceInventoryStatusItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_inventory_type(self, room_space_inventory_type_id, room_space_inventory_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceInventoryType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_inventory_type(room_space_inventory_type_id, room_space_inventory_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_type_id: Numeric value of the roomspaceinventorytypeID (required)
        :param RoomSpaceInventoryTypeItem room_space_inventory_type_item: RoomSpaceInventoryType to update (required)
        :return: list[RoomSpaceInventoryTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_inventory_type_with_http_info(room_space_inventory_type_id, room_space_inventory_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_inventory_type_with_http_info(room_space_inventory_type_id, room_space_inventory_type_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_inventory_type_with_http_info(self, room_space_inventory_type_id, room_space_inventory_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceInventoryType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_inventory_type_with_http_info(room_space_inventory_type_id, room_space_inventory_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_inventory_type_id: Numeric value of the roomspaceinventorytypeID (required)
        :param RoomSpaceInventoryTypeItem room_space_inventory_type_item: RoomSpaceInventoryType to update (required)
        :return: list[RoomSpaceInventoryTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_inventory_type_id', 'room_space_inventory_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_inventory_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_inventory_type_id' is set
        if ('room_space_inventory_type_id' not in params or
                params['room_space_inventory_type_id'] is None):
            raise ValueError("Missing the required parameter `room_space_inventory_type_id` when calling `update_room_space_inventory_type`")  # noqa: E501
        # verify the required parameter 'room_space_inventory_type_item' is set
        if ('room_space_inventory_type_item' not in params or
                params['room_space_inventory_type_item'] is None):
            raise ValueError("Missing the required parameter `room_space_inventory_type_item` when calling `update_room_space_inventory_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_inventory_type_id' in params:
            path_params['RoomSpaceInventoryTypeID'] = params['room_space_inventory_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_inventory_type_item' in params:
            body_params = params['room_space_inventory_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceInventoryType/{RoomSpaceInventoryTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceInventoryTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_key(self, room_space_key_id, room_space_key_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceKey in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_key(room_space_key_id, room_space_key_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_key_id: Numeric value of the roomspacekeyID (required)
        :param RoomSpaceKeyItem room_space_key_item: RoomSpaceKey to update (required)
        :return: list[RoomSpaceKeyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_key_with_http_info(room_space_key_id, room_space_key_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_key_with_http_info(room_space_key_id, room_space_key_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_key_with_http_info(self, room_space_key_id, room_space_key_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceKey in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_key_with_http_info(room_space_key_id, room_space_key_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_key_id: Numeric value of the roomspacekeyID (required)
        :param RoomSpaceKeyItem room_space_key_item: RoomSpaceKey to update (required)
        :return: list[RoomSpaceKeyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_key_id', 'room_space_key_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_key_id' is set
        if ('room_space_key_id' not in params or
                params['room_space_key_id'] is None):
            raise ValueError("Missing the required parameter `room_space_key_id` when calling `update_room_space_key`")  # noqa: E501
        # verify the required parameter 'room_space_key_item' is set
        if ('room_space_key_item' not in params or
                params['room_space_key_item'] is None):
            raise ValueError("Missing the required parameter `room_space_key_item` when calling `update_room_space_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_key_id' in params:
            path_params['RoomSpaceKeyID'] = params['room_space_key_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_key_item' in params:
            body_params = params['room_space_key_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceKey/{RoomSpaceKeyID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceKeyItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_key_booking(self, room_space_key_booking_id, room_space_key_booking_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceKeyBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_key_booking(room_space_key_booking_id, room_space_key_booking_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_key_booking_id: Numeric value of the roomspacekeybookingID (required)
        :param RoomSpaceKeyBookingItem room_space_key_booking_item: RoomSpaceKeyBooking to update (required)
        :return: list[RoomSpaceKeyBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_key_booking_with_http_info(room_space_key_booking_id, room_space_key_booking_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_key_booking_with_http_info(room_space_key_booking_id, room_space_key_booking_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_key_booking_with_http_info(self, room_space_key_booking_id, room_space_key_booking_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceKeyBooking in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_key_booking_with_http_info(room_space_key_booking_id, room_space_key_booking_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_key_booking_id: Numeric value of the roomspacekeybookingID (required)
        :param RoomSpaceKeyBookingItem room_space_key_booking_item: RoomSpaceKeyBooking to update (required)
        :return: list[RoomSpaceKeyBookingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_key_booking_id', 'room_space_key_booking_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_key_booking" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_key_booking_id' is set
        if ('room_space_key_booking_id' not in params or
                params['room_space_key_booking_id'] is None):
            raise ValueError("Missing the required parameter `room_space_key_booking_id` when calling `update_room_space_key_booking`")  # noqa: E501
        # verify the required parameter 'room_space_key_booking_item' is set
        if ('room_space_key_booking_item' not in params or
                params['room_space_key_booking_item'] is None):
            raise ValueError("Missing the required parameter `room_space_key_booking_item` when calling `update_room_space_key_booking`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_key_booking_id' in params:
            path_params['RoomSpaceKeyBookingID'] = params['room_space_key_booking_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_key_booking_item' in params:
            body_params = params['room_space_key_booking_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceKeyBooking/{RoomSpaceKeyBookingID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceKeyBookingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_key_type(self, room_space_key_type_id, room_space_key_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceKeyType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_key_type(room_space_key_type_id, room_space_key_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_key_type_id: Numeric value of the roomspacekeytypeID (required)
        :param RoomSpaceKeyTypeItem room_space_key_type_item: RoomSpaceKeyType to update (required)
        :return: list[RoomSpaceKeyTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_key_type_with_http_info(room_space_key_type_id, room_space_key_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_key_type_with_http_info(room_space_key_type_id, room_space_key_type_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_key_type_with_http_info(self, room_space_key_type_id, room_space_key_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceKeyType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_key_type_with_http_info(room_space_key_type_id, room_space_key_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_key_type_id: Numeric value of the roomspacekeytypeID (required)
        :param RoomSpaceKeyTypeItem room_space_key_type_item: RoomSpaceKeyType to update (required)
        :return: list[RoomSpaceKeyTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_key_type_id', 'room_space_key_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_key_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_key_type_id' is set
        if ('room_space_key_type_id' not in params or
                params['room_space_key_type_id'] is None):
            raise ValueError("Missing the required parameter `room_space_key_type_id` when calling `update_room_space_key_type`")  # noqa: E501
        # verify the required parameter 'room_space_key_type_item' is set
        if ('room_space_key_type_item' not in params or
                params['room_space_key_type_item'] is None):
            raise ValueError("Missing the required parameter `room_space_key_type_item` when calling `update_room_space_key_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_key_type_id' in params:
            path_params['RoomSpaceKeyTypeID'] = params['room_space_key_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_key_type_item' in params:
            body_params = params['room_space_key_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceKeyType/{RoomSpaceKeyTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceKeyTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_maintenance(self, room_space_maintenance_id, room_space_maintenance_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceMaintenance in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_maintenance(room_space_maintenance_id, room_space_maintenance_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_id: Numeric value of the roomspacemaintenanceID (required)
        :param RoomSpaceMaintenanceItem room_space_maintenance_item: RoomSpaceMaintenance to update (required)
        :return: list[RoomSpaceMaintenanceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_maintenance_with_http_info(room_space_maintenance_id, room_space_maintenance_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_maintenance_with_http_info(room_space_maintenance_id, room_space_maintenance_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_maintenance_with_http_info(self, room_space_maintenance_id, room_space_maintenance_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceMaintenance in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_maintenance_with_http_info(room_space_maintenance_id, room_space_maintenance_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_id: Numeric value of the roomspacemaintenanceID (required)
        :param RoomSpaceMaintenanceItem room_space_maintenance_item: RoomSpaceMaintenance to update (required)
        :return: list[RoomSpaceMaintenanceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_maintenance_id', 'room_space_maintenance_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_maintenance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_maintenance_id' is set
        if ('room_space_maintenance_id' not in params or
                params['room_space_maintenance_id'] is None):
            raise ValueError("Missing the required parameter `room_space_maintenance_id` when calling `update_room_space_maintenance`")  # noqa: E501
        # verify the required parameter 'room_space_maintenance_item' is set
        if ('room_space_maintenance_item' not in params or
                params['room_space_maintenance_item'] is None):
            raise ValueError("Missing the required parameter `room_space_maintenance_item` when calling `update_room_space_maintenance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_maintenance_id' in params:
            path_params['RoomSpaceMaintenanceID'] = params['room_space_maintenance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_maintenance_item' in params:
            body_params = params['room_space_maintenance_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceMaintenance/{RoomSpaceMaintenanceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceMaintenanceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_maintenance_category(self, room_space_maintenance_category_id, room_space_maintenance_category_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceMaintenanceCategory in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_maintenance_category(room_space_maintenance_category_id, room_space_maintenance_category_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_category_id: Numeric value of the roomspacemaintenancecategoryID (required)
        :param RoomSpaceMaintenanceCategoryItem room_space_maintenance_category_item: RoomSpaceMaintenanceCategory to update (required)
        :return: list[RoomSpaceMaintenanceCategoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_maintenance_category_with_http_info(room_space_maintenance_category_id, room_space_maintenance_category_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_maintenance_category_with_http_info(room_space_maintenance_category_id, room_space_maintenance_category_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_maintenance_category_with_http_info(self, room_space_maintenance_category_id, room_space_maintenance_category_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceMaintenanceCategory in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_maintenance_category_with_http_info(room_space_maintenance_category_id, room_space_maintenance_category_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_category_id: Numeric value of the roomspacemaintenancecategoryID (required)
        :param RoomSpaceMaintenanceCategoryItem room_space_maintenance_category_item: RoomSpaceMaintenanceCategory to update (required)
        :return: list[RoomSpaceMaintenanceCategoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_maintenance_category_id', 'room_space_maintenance_category_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_maintenance_category" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_maintenance_category_id' is set
        if ('room_space_maintenance_category_id' not in params or
                params['room_space_maintenance_category_id'] is None):
            raise ValueError("Missing the required parameter `room_space_maintenance_category_id` when calling `update_room_space_maintenance_category`")  # noqa: E501
        # verify the required parameter 'room_space_maintenance_category_item' is set
        if ('room_space_maintenance_category_item' not in params or
                params['room_space_maintenance_category_item'] is None):
            raise ValueError("Missing the required parameter `room_space_maintenance_category_item` when calling `update_room_space_maintenance_category`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_maintenance_category_id' in params:
            path_params['RoomSpaceMaintenanceCategoryID'] = params['room_space_maintenance_category_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_maintenance_category_item' in params:
            body_params = params['room_space_maintenance_category_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceMaintenanceCategory/{RoomSpaceMaintenanceCategoryID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceMaintenanceCategoryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_maintenance_item(self, room_space_maintenance_item_id, room_space_maintenance_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceMaintenanceItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_maintenance_item(room_space_maintenance_item_id, room_space_maintenance_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_item_id: Numeric value of the roomspacemaintenanceitemID (required)
        :param RoomSpaceMaintenanceItemItem room_space_maintenance_item_item: RoomSpaceMaintenanceItem to update (required)
        :return: list[RoomSpaceMaintenanceItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_maintenance_item_with_http_info(room_space_maintenance_item_id, room_space_maintenance_item_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_maintenance_item_with_http_info(room_space_maintenance_item_id, room_space_maintenance_item_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_maintenance_item_with_http_info(self, room_space_maintenance_item_id, room_space_maintenance_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceMaintenanceItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_maintenance_item_with_http_info(room_space_maintenance_item_id, room_space_maintenance_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_item_id: Numeric value of the roomspacemaintenanceitemID (required)
        :param RoomSpaceMaintenanceItemItem room_space_maintenance_item_item: RoomSpaceMaintenanceItem to update (required)
        :return: list[RoomSpaceMaintenanceItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_maintenance_item_id', 'room_space_maintenance_item_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_maintenance_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_maintenance_item_id' is set
        if ('room_space_maintenance_item_id' not in params or
                params['room_space_maintenance_item_id'] is None):
            raise ValueError("Missing the required parameter `room_space_maintenance_item_id` when calling `update_room_space_maintenance_item`")  # noqa: E501
        # verify the required parameter 'room_space_maintenance_item_item' is set
        if ('room_space_maintenance_item_item' not in params or
                params['room_space_maintenance_item_item'] is None):
            raise ValueError("Missing the required parameter `room_space_maintenance_item_item` when calling `update_room_space_maintenance_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_maintenance_item_id' in params:
            path_params['RoomSpaceMaintenanceItemID'] = params['room_space_maintenance_item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_maintenance_item_item' in params:
            body_params = params['room_space_maintenance_item_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceMaintenanceItem/{RoomSpaceMaintenanceItemID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceMaintenanceItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_maintenance_job_action(self, room_space_maintenance_job_action_id, room_space_maintenance_job_action_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceMaintenanceJobAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_maintenance_job_action(room_space_maintenance_job_action_id, room_space_maintenance_job_action_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_job_action_id: Numeric value of the roomspacemaintenancejobactionID (required)
        :param RoomSpaceMaintenanceJobActionItem room_space_maintenance_job_action_item: RoomSpaceMaintenanceJobAction to update (required)
        :return: list[RoomSpaceMaintenanceJobActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_maintenance_job_action_with_http_info(room_space_maintenance_job_action_id, room_space_maintenance_job_action_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_maintenance_job_action_with_http_info(room_space_maintenance_job_action_id, room_space_maintenance_job_action_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_maintenance_job_action_with_http_info(self, room_space_maintenance_job_action_id, room_space_maintenance_job_action_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceMaintenanceJobAction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_maintenance_job_action_with_http_info(room_space_maintenance_job_action_id, room_space_maintenance_job_action_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_job_action_id: Numeric value of the roomspacemaintenancejobactionID (required)
        :param RoomSpaceMaintenanceJobActionItem room_space_maintenance_job_action_item: RoomSpaceMaintenanceJobAction to update (required)
        :return: list[RoomSpaceMaintenanceJobActionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_maintenance_job_action_id', 'room_space_maintenance_job_action_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_maintenance_job_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_maintenance_job_action_id' is set
        if ('room_space_maintenance_job_action_id' not in params or
                params['room_space_maintenance_job_action_id'] is None):
            raise ValueError("Missing the required parameter `room_space_maintenance_job_action_id` when calling `update_room_space_maintenance_job_action`")  # noqa: E501
        # verify the required parameter 'room_space_maintenance_job_action_item' is set
        if ('room_space_maintenance_job_action_item' not in params or
                params['room_space_maintenance_job_action_item'] is None):
            raise ValueError("Missing the required parameter `room_space_maintenance_job_action_item` when calling `update_room_space_maintenance_job_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_maintenance_job_action_id' in params:
            path_params['RoomSpaceMaintenanceJobActionID'] = params['room_space_maintenance_job_action_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_maintenance_job_action_item' in params:
            body_params = params['room_space_maintenance_job_action_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceMaintenanceJobAction/{RoomSpaceMaintenanceJobActionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceMaintenanceJobActionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_maintenance_materials(self, room_space_maintenance_materials_id, room_space_maintenance_materials_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceMaintenanceMaterials in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_maintenance_materials(room_space_maintenance_materials_id, room_space_maintenance_materials_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_materials_id: Numeric value of the roomspacemaintenancematerialsID (required)
        :param RoomSpaceMaintenanceMaterialsItem room_space_maintenance_materials_item: RoomSpaceMaintenanceMaterials to update (required)
        :return: list[RoomSpaceMaintenanceMaterialsItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_maintenance_materials_with_http_info(room_space_maintenance_materials_id, room_space_maintenance_materials_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_maintenance_materials_with_http_info(room_space_maintenance_materials_id, room_space_maintenance_materials_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_maintenance_materials_with_http_info(self, room_space_maintenance_materials_id, room_space_maintenance_materials_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceMaintenanceMaterials in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_maintenance_materials_with_http_info(room_space_maintenance_materials_id, room_space_maintenance_materials_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_maintenance_materials_id: Numeric value of the roomspacemaintenancematerialsID (required)
        :param RoomSpaceMaintenanceMaterialsItem room_space_maintenance_materials_item: RoomSpaceMaintenanceMaterials to update (required)
        :return: list[RoomSpaceMaintenanceMaterialsItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_maintenance_materials_id', 'room_space_maintenance_materials_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_maintenance_materials" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_maintenance_materials_id' is set
        if ('room_space_maintenance_materials_id' not in params or
                params['room_space_maintenance_materials_id'] is None):
            raise ValueError("Missing the required parameter `room_space_maintenance_materials_id` when calling `update_room_space_maintenance_materials`")  # noqa: E501
        # verify the required parameter 'room_space_maintenance_materials_item' is set
        if ('room_space_maintenance_materials_item' not in params or
                params['room_space_maintenance_materials_item'] is None):
            raise ValueError("Missing the required parameter `room_space_maintenance_materials_item` when calling `update_room_space_maintenance_materials`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_maintenance_materials_id' in params:
            path_params['RoomSpaceMaintenanceMaterialsID'] = params['room_space_maintenance_materials_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_maintenance_materials_item' in params:
            body_params = params['room_space_maintenance_materials_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceMaintenanceMaterials/{RoomSpaceMaintenanceMaterialsID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceMaintenanceMaterialsItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_swap(self, room_space_swap_id, room_space_swap_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceSwap in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_swap(room_space_swap_id, room_space_swap_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_swap_id: Numeric value of the roomspaceswapID (required)
        :param RoomSpaceSwapItem room_space_swap_item: RoomSpaceSwap to update (required)
        :return: list[RoomSpaceSwapItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_swap_with_http_info(room_space_swap_id, room_space_swap_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_swap_with_http_info(room_space_swap_id, room_space_swap_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_swap_with_http_info(self, room_space_swap_id, room_space_swap_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceSwap in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_swap_with_http_info(room_space_swap_id, room_space_swap_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_swap_id: Numeric value of the roomspaceswapID (required)
        :param RoomSpaceSwapItem room_space_swap_item: RoomSpaceSwap to update (required)
        :return: list[RoomSpaceSwapItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_swap_id', 'room_space_swap_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_swap" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_swap_id' is set
        if ('room_space_swap_id' not in params or
                params['room_space_swap_id'] is None):
            raise ValueError("Missing the required parameter `room_space_swap_id` when calling `update_room_space_swap`")  # noqa: E501
        # verify the required parameter 'room_space_swap_item' is set
        if ('room_space_swap_item' not in params or
                params['room_space_swap_item'] is None):
            raise ValueError("Missing the required parameter `room_space_swap_item` when calling `update_room_space_swap`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_swap_id' in params:
            path_params['RoomSpaceSwapID'] = params['room_space_swap_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_swap_item' in params:
            body_params = params['room_space_swap_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceSwap/{RoomSpaceSwapID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceSwapItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_space_swap_preference(self, room_space_swap_preference_id, room_space_swap_preference_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceSwapPreference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_swap_preference(room_space_swap_preference_id, room_space_swap_preference_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_swap_preference_id: Numeric value of the roomspaceswappreferenceID (required)
        :param RoomSpaceSwapPreferenceItem room_space_swap_preference_item: RoomSpaceSwapPreference to update (required)
        :return: list[RoomSpaceSwapPreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_space_swap_preference_with_http_info(room_space_swap_preference_id, room_space_swap_preference_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_space_swap_preference_with_http_info(room_space_swap_preference_id, room_space_swap_preference_item, **kwargs)  # noqa: E501
            return data

    def update_room_space_swap_preference_with_http_info(self, room_space_swap_preference_id, room_space_swap_preference_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomSpaceSwapPreference in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_space_swap_preference_with_http_info(room_space_swap_preference_id, room_space_swap_preference_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_space_swap_preference_id: Numeric value of the roomspaceswappreferenceID (required)
        :param RoomSpaceSwapPreferenceItem room_space_swap_preference_item: RoomSpaceSwapPreference to update (required)
        :return: list[RoomSpaceSwapPreferenceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_space_swap_preference_id', 'room_space_swap_preference_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_space_swap_preference" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_space_swap_preference_id' is set
        if ('room_space_swap_preference_id' not in params or
                params['room_space_swap_preference_id'] is None):
            raise ValueError("Missing the required parameter `room_space_swap_preference_id` when calling `update_room_space_swap_preference`")  # noqa: E501
        # verify the required parameter 'room_space_swap_preference_item' is set
        if ('room_space_swap_preference_item' not in params or
                params['room_space_swap_preference_item'] is None):
            raise ValueError("Missing the required parameter `room_space_swap_preference_item` when calling `update_room_space_swap_preference`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_space_swap_preference_id' in params:
            path_params['RoomSpaceSwapPreferenceID'] = params['room_space_swap_preference_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_space_swap_preference_item' in params:
            body_params = params['room_space_swap_preference_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomSpaceSwapPreference/{RoomSpaceSwapPreferenceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomSpaceSwapPreferenceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_term_type(self, room_term_type_id, room_term_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomTermType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_term_type(room_term_type_id, room_term_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_term_type_id: Numeric value of the roomtermtypeID (required)
        :param RoomTermTypeItem room_term_type_item: RoomTermType to update (required)
        :return: list[RoomTermTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_term_type_with_http_info(room_term_type_id, room_term_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_term_type_with_http_info(room_term_type_id, room_term_type_item, **kwargs)  # noqa: E501
            return data

    def update_room_term_type_with_http_info(self, room_term_type_id, room_term_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomTermType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_term_type_with_http_info(room_term_type_id, room_term_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_term_type_id: Numeric value of the roomtermtypeID (required)
        :param RoomTermTypeItem room_term_type_item: RoomTermType to update (required)
        :return: list[RoomTermTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_term_type_id', 'room_term_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_term_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_term_type_id' is set
        if ('room_term_type_id' not in params or
                params['room_term_type_id'] is None):
            raise ValueError("Missing the required parameter `room_term_type_id` when calling `update_room_term_type`")  # noqa: E501
        # verify the required parameter 'room_term_type_item' is set
        if ('room_term_type_item' not in params or
                params['room_term_type_item'] is None):
            raise ValueError("Missing the required parameter `room_term_type_item` when calling `update_room_term_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_term_type_id' in params:
            path_params['RoomTermTypeID'] = params['room_term_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_term_type_item' in params:
            body_params = params['room_term_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomTermType/{RoomTermTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomTermTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_type(self, room_type_id, room_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_type(room_type_id, room_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_type_id: Numeric value of the roomtypeID (required)
        :param RoomTypeItem room_type_item: RoomType to update (required)
        :return: list[RoomTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_type_with_http_info(room_type_id, room_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_type_with_http_info(room_type_id, room_type_item, **kwargs)  # noqa: E501
            return data

    def update_room_type_with_http_info(self, room_type_id, room_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_type_with_http_info(room_type_id, room_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_type_id: Numeric value of the roomtypeID (required)
        :param RoomTypeItem room_type_item: RoomType to update (required)
        :return: list[RoomTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_type_id', 'room_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_type_id' is set
        if ('room_type_id' not in params or
                params['room_type_id'] is None):
            raise ValueError("Missing the required parameter `room_type_id` when calling `update_room_type`")  # noqa: E501
        # verify the required parameter 'room_type_item' is set
        if ('room_type_item' not in params or
                params['room_type_item'] is None):
            raise ValueError("Missing the required parameter `room_type_item` when calling `update_room_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_type_id' in params:
            path_params['RoomTypeID'] = params['room_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_type_item' in params:
            body_params = params['room_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomType/{RoomTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_room_type_capacity(self, room_type_capacity_id, room_type_capacity_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomTypeCapacity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_type_capacity(room_type_capacity_id, room_type_capacity_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_type_capacity_id: Numeric value of the roomtypecapacityID (required)
        :param RoomTypeCapacityItem room_type_capacity_item: RoomTypeCapacity to update (required)
        :return: list[RoomTypeCapacityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_room_type_capacity_with_http_info(room_type_capacity_id, room_type_capacity_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_room_type_capacity_with_http_info(room_type_capacity_id, room_type_capacity_item, **kwargs)  # noqa: E501
            return data

    def update_room_type_capacity_with_http_info(self, room_type_capacity_id, room_type_capacity_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoomTypeCapacity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_room_type_capacity_with_http_info(room_type_capacity_id, room_type_capacity_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int room_type_capacity_id: Numeric value of the roomtypecapacityID (required)
        :param RoomTypeCapacityItem room_type_capacity_item: RoomTypeCapacity to update (required)
        :return: list[RoomTypeCapacityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['room_type_capacity_id', 'room_type_capacity_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_room_type_capacity" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'room_type_capacity_id' is set
        if ('room_type_capacity_id' not in params or
                params['room_type_capacity_id'] is None):
            raise ValueError("Missing the required parameter `room_type_capacity_id` when calling `update_room_type_capacity`")  # noqa: E501
        # verify the required parameter 'room_type_capacity_item' is set
        if ('room_type_capacity_item' not in params or
                params['room_type_capacity_item'] is None):
            raise ValueError("Missing the required parameter `room_type_capacity_item` when calling `update_room_type_capacity`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'room_type_capacity_id' in params:
            path_params['RoomTypeCapacityID'] = params['room_type_capacity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'room_type_capacity_item' in params:
            body_params = params['room_type_capacity_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoomTypeCapacity/{RoomTypeCapacityID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoomTypeCapacityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_roommate_group(self, roommate_group_id, roommate_group_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoommateGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_roommate_group(roommate_group_id, roommate_group_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int roommate_group_id: Numeric value of the roommategroupID (required)
        :param RoommateGroupItem roommate_group_item: RoommateGroup to update (required)
        :return: list[RoommateGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_roommate_group_with_http_info(roommate_group_id, roommate_group_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_roommate_group_with_http_info(roommate_group_id, roommate_group_item, **kwargs)  # noqa: E501
            return data

    def update_roommate_group_with_http_info(self, roommate_group_id, roommate_group_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoommateGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_roommate_group_with_http_info(roommate_group_id, roommate_group_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int roommate_group_id: Numeric value of the roommategroupID (required)
        :param RoommateGroupItem roommate_group_item: RoommateGroup to update (required)
        :return: list[RoommateGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['roommate_group_id', 'roommate_group_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_roommate_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'roommate_group_id' is set
        if ('roommate_group_id' not in params or
                params['roommate_group_id'] is None):
            raise ValueError("Missing the required parameter `roommate_group_id` when calling `update_roommate_group`")  # noqa: E501
        # verify the required parameter 'roommate_group_item' is set
        if ('roommate_group_item' not in params or
                params['roommate_group_item'] is None):
            raise ValueError("Missing the required parameter `roommate_group_item` when calling `update_roommate_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'roommate_group_id' in params:
            path_params['RoommateGroupID'] = params['roommate_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'roommate_group_item' in params:
            body_params = params['roommate_group_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoommateGroup/{RoommateGroupID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoommateGroupItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_roommate_group_mandatory_profile(self, roommate_group_mandatory_profile_id, roommate_group_mandatory_profile_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoommateGroupMandatoryProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_roommate_group_mandatory_profile(roommate_group_mandatory_profile_id, roommate_group_mandatory_profile_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int roommate_group_mandatory_profile_id: Numeric value of the roommategroupmandatoryprofileID (required)
        :param RoommateGroupMandatoryProfileItem roommate_group_mandatory_profile_item: RoommateGroupMandatoryProfile to update (required)
        :return: list[RoommateGroupMandatoryProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_roommate_group_mandatory_profile_with_http_info(roommate_group_mandatory_profile_id, roommate_group_mandatory_profile_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_roommate_group_mandatory_profile_with_http_info(roommate_group_mandatory_profile_id, roommate_group_mandatory_profile_item, **kwargs)  # noqa: E501
            return data

    def update_roommate_group_mandatory_profile_with_http_info(self, roommate_group_mandatory_profile_id, roommate_group_mandatory_profile_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoommateGroupMandatoryProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_roommate_group_mandatory_profile_with_http_info(roommate_group_mandatory_profile_id, roommate_group_mandatory_profile_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int roommate_group_mandatory_profile_id: Numeric value of the roommategroupmandatoryprofileID (required)
        :param RoommateGroupMandatoryProfileItem roommate_group_mandatory_profile_item: RoommateGroupMandatoryProfile to update (required)
        :return: list[RoommateGroupMandatoryProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['roommate_group_mandatory_profile_id', 'roommate_group_mandatory_profile_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_roommate_group_mandatory_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'roommate_group_mandatory_profile_id' is set
        if ('roommate_group_mandatory_profile_id' not in params or
                params['roommate_group_mandatory_profile_id'] is None):
            raise ValueError("Missing the required parameter `roommate_group_mandatory_profile_id` when calling `update_roommate_group_mandatory_profile`")  # noqa: E501
        # verify the required parameter 'roommate_group_mandatory_profile_item' is set
        if ('roommate_group_mandatory_profile_item' not in params or
                params['roommate_group_mandatory_profile_item'] is None):
            raise ValueError("Missing the required parameter `roommate_group_mandatory_profile_item` when calling `update_roommate_group_mandatory_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'roommate_group_mandatory_profile_id' in params:
            path_params['RoommateGroupMandatoryProfileID'] = params['roommate_group_mandatory_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'roommate_group_mandatory_profile_item' in params:
            body_params = params['roommate_group_mandatory_profile_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoommateGroupMandatoryProfile/{RoommateGroupMandatoryProfileID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoommateGroupMandatoryProfileItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_roommate_group_request(self, roommate_group_request_id, roommate_group_request_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoommateGroupRequest in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_roommate_group_request(roommate_group_request_id, roommate_group_request_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int roommate_group_request_id: Numeric value of the roommategrouprequestID (required)
        :param RoommateGroupRequestItem roommate_group_request_item: RoommateGroupRequest to update (required)
        :return: list[RoommateGroupRequestItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_roommate_group_request_with_http_info(roommate_group_request_id, roommate_group_request_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_roommate_group_request_with_http_info(roommate_group_request_id, roommate_group_request_item, **kwargs)  # noqa: E501
            return data

    def update_roommate_group_request_with_http_info(self, roommate_group_request_id, roommate_group_request_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an RoommateGroupRequest in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_roommate_group_request_with_http_info(roommate_group_request_id, roommate_group_request_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int roommate_group_request_id: Numeric value of the roommategrouprequestID (required)
        :param RoommateGroupRequestItem roommate_group_request_item: RoommateGroupRequest to update (required)
        :return: list[RoommateGroupRequestItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['roommate_group_request_id', 'roommate_group_request_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_roommate_group_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'roommate_group_request_id' is set
        if ('roommate_group_request_id' not in params or
                params['roommate_group_request_id'] is None):
            raise ValueError("Missing the required parameter `roommate_group_request_id` when calling `update_roommate_group_request`")  # noqa: E501
        # verify the required parameter 'roommate_group_request_item' is set
        if ('roommate_group_request_item' not in params or
                params['roommate_group_request_item'] is None):
            raise ValueError("Missing the required parameter `roommate_group_request_item` when calling `update_roommate_group_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'roommate_group_request_id' in params:
            path_params['RoommateGroupRequestID'] = params['roommate_group_request_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'roommate_group_request_item' in params:
            body_params = params['roommate_group_request_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/RoommateGroupRequest/{RoommateGroupRequestID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RoommateGroupRequestItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_saved_list(self, saved_list_id, saved_list_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SavedList in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_saved_list(saved_list_id, saved_list_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int saved_list_id: Numeric value of the savedlistID (required)
        :param SavedListItem saved_list_item: SavedList to update (required)
        :return: list[SavedListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_saved_list_with_http_info(saved_list_id, saved_list_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_saved_list_with_http_info(saved_list_id, saved_list_item, **kwargs)  # noqa: E501
            return data

    def update_saved_list_with_http_info(self, saved_list_id, saved_list_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SavedList in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_saved_list_with_http_info(saved_list_id, saved_list_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int saved_list_id: Numeric value of the savedlistID (required)
        :param SavedListItem saved_list_item: SavedList to update (required)
        :return: list[SavedListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['saved_list_id', 'saved_list_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_saved_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'saved_list_id' is set
        if ('saved_list_id' not in params or
                params['saved_list_id'] is None):
            raise ValueError("Missing the required parameter `saved_list_id` when calling `update_saved_list`")  # noqa: E501
        # verify the required parameter 'saved_list_item' is set
        if ('saved_list_item' not in params or
                params['saved_list_item'] is None):
            raise ValueError("Missing the required parameter `saved_list_item` when calling `update_saved_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'saved_list_id' in params:
            path_params['SavedListID'] = params['saved_list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'saved_list_item' in params:
            body_params = params['saved_list_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/SavedList/{SavedListID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SavedListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_saved_list_item(self, saved_list_item_id, saved_list_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SavedListItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_saved_list_item(saved_list_item_id, saved_list_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int saved_list_item_id: Numeric value of the savedlistitemID (required)
        :param SavedListItemItem saved_list_item_item: SavedListItem to update (required)
        :return: list[SavedListItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_saved_list_item_with_http_info(saved_list_item_id, saved_list_item_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_saved_list_item_with_http_info(saved_list_item_id, saved_list_item_item, **kwargs)  # noqa: E501
            return data

    def update_saved_list_item_with_http_info(self, saved_list_item_id, saved_list_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SavedListItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_saved_list_item_with_http_info(saved_list_item_id, saved_list_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int saved_list_item_id: Numeric value of the savedlistitemID (required)
        :param SavedListItemItem saved_list_item_item: SavedListItem to update (required)
        :return: list[SavedListItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['saved_list_item_id', 'saved_list_item_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_saved_list_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'saved_list_item_id' is set
        if ('saved_list_item_id' not in params or
                params['saved_list_item_id'] is None):
            raise ValueError("Missing the required parameter `saved_list_item_id` when calling `update_saved_list_item`")  # noqa: E501
        # verify the required parameter 'saved_list_item_item' is set
        if ('saved_list_item_item' not in params or
                params['saved_list_item_item'] is None):
            raise ValueError("Missing the required parameter `saved_list_item_item` when calling `update_saved_list_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'saved_list_item_id' in params:
            path_params['SavedListItemID'] = params['saved_list_item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'saved_list_item_item' in params:
            body_params = params['saved_list_item_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/SavedListItem/{SavedListItemID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SavedListItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_school(self, school_id, school_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an School in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_school(school_id, school_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int school_id: Numeric value of the schoolID (required)
        :param SchoolItem school_item: School to update (required)
        :return: list[SchoolItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_school_with_http_info(school_id, school_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_school_with_http_info(school_id, school_item, **kwargs)  # noqa: E501
            return data

    def update_school_with_http_info(self, school_id, school_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an School in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_school_with_http_info(school_id, school_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int school_id: Numeric value of the schoolID (required)
        :param SchoolItem school_item: School to update (required)
        :return: list[SchoolItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['school_id', 'school_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_school" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'school_id' is set
        if ('school_id' not in params or
                params['school_id'] is None):
            raise ValueError("Missing the required parameter `school_id` when calling `update_school`")  # noqa: E501
        # verify the required parameter 'school_item' is set
        if ('school_item' not in params or
                params['school_item'] is None):
            raise ValueError("Missing the required parameter `school_item` when calling `update_school`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'school_id' in params:
            path_params['SchoolID'] = params['school_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'school_item' in params:
            body_params = params['school_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/School/{SchoolID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SchoolItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_sdas_charge_rate(self, sdas_charge_rate_id, sdas_charge_rate_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SDASChargeRate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_sdas_charge_rate(sdas_charge_rate_id, sdas_charge_rate_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int sdas_charge_rate_id: Numeric value of the sdaschargerateID (required)
        :param SDASChargeRateItem sdas_charge_rate_item: SDASChargeRate to update (required)
        :return: list[SDASChargeRateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_sdas_charge_rate_with_http_info(sdas_charge_rate_id, sdas_charge_rate_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_sdas_charge_rate_with_http_info(sdas_charge_rate_id, sdas_charge_rate_item, **kwargs)  # noqa: E501
            return data

    def update_sdas_charge_rate_with_http_info(self, sdas_charge_rate_id, sdas_charge_rate_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SDASChargeRate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_sdas_charge_rate_with_http_info(sdas_charge_rate_id, sdas_charge_rate_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int sdas_charge_rate_id: Numeric value of the sdaschargerateID (required)
        :param SDASChargeRateItem sdas_charge_rate_item: SDASChargeRate to update (required)
        :return: list[SDASChargeRateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sdas_charge_rate_id', 'sdas_charge_rate_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_sdas_charge_rate" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'sdas_charge_rate_id' is set
        if ('sdas_charge_rate_id' not in params or
                params['sdas_charge_rate_id'] is None):
            raise ValueError("Missing the required parameter `sdas_charge_rate_id` when calling `update_sdas_charge_rate`")  # noqa: E501
        # verify the required parameter 'sdas_charge_rate_item' is set
        if ('sdas_charge_rate_item' not in params or
                params['sdas_charge_rate_item'] is None):
            raise ValueError("Missing the required parameter `sdas_charge_rate_item` when calling `update_sdas_charge_rate`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'sdas_charge_rate_id' in params:
            path_params['SDASChargeRateID'] = params['sdas_charge_rate_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sdas_charge_rate_item' in params:
            body_params = params['sdas_charge_rate_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/SDASChargeRate/{SDASChargeRateID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SDASChargeRateItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_sdas_data(self, sdas_data_id, sdas_data_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SDASData in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_sdas_data(sdas_data_id, sdas_data_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int sdas_data_id: Numeric value of the sdasdataID (required)
        :param SDASDataItem sdas_data_item: SDASData to update (required)
        :return: list[SDASDataItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_sdas_data_with_http_info(sdas_data_id, sdas_data_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_sdas_data_with_http_info(sdas_data_id, sdas_data_item, **kwargs)  # noqa: E501
            return data

    def update_sdas_data_with_http_info(self, sdas_data_id, sdas_data_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SDASData in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_sdas_data_with_http_info(sdas_data_id, sdas_data_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int sdas_data_id: Numeric value of the sdasdataID (required)
        :param SDASDataItem sdas_data_item: SDASData to update (required)
        :return: list[SDASDataItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sdas_data_id', 'sdas_data_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_sdas_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'sdas_data_id' is set
        if ('sdas_data_id' not in params or
                params['sdas_data_id'] is None):
            raise ValueError("Missing the required parameter `sdas_data_id` when calling `update_sdas_data`")  # noqa: E501
        # verify the required parameter 'sdas_data_item' is set
        if ('sdas_data_item' not in params or
                params['sdas_data_item'] is None):
            raise ValueError("Missing the required parameter `sdas_data_item` when calling `update_sdas_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'sdas_data_id' in params:
            path_params['SDASDataID'] = params['sdas_data_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'sdas_data_item' in params:
            body_params = params['sdas_data_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/SDASData/{SDASDataID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SDASDataItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_setting(self, setting_id, setting_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Setting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_setting(setting_id, setting_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int setting_id: Numeric value of the settingID (required)
        :param SettingItem setting_item: Setting to update (required)
        :return: list[SettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_setting_with_http_info(setting_id, setting_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_setting_with_http_info(setting_id, setting_item, **kwargs)  # noqa: E501
            return data

    def update_setting_with_http_info(self, setting_id, setting_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Setting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_setting_with_http_info(setting_id, setting_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int setting_id: Numeric value of the settingID (required)
        :param SettingItem setting_item: Setting to update (required)
        :return: list[SettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['setting_id', 'setting_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'setting_id' is set
        if ('setting_id' not in params or
                params['setting_id'] is None):
            raise ValueError("Missing the required parameter `setting_id` when calling `update_setting`")  # noqa: E501
        # verify the required parameter 'setting_item' is set
        if ('setting_item' not in params or
                params['setting_item'] is None):
            raise ValueError("Missing the required parameter `setting_item` when calling `update_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'setting_id' in params:
            path_params['SettingID'] = params['setting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'setting_item' in params:
            body_params = params['setting_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Setting/{SettingID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SettingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_shipping_type(self, shipping_type_id, shipping_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ShippingType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_shipping_type(shipping_type_id, shipping_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int shipping_type_id: Numeric value of the shippingtypeID (required)
        :param ShippingTypeItem shipping_type_item: ShippingType to update (required)
        :return: list[ShippingTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_shipping_type_with_http_info(shipping_type_id, shipping_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_shipping_type_with_http_info(shipping_type_id, shipping_type_item, **kwargs)  # noqa: E501
            return data

    def update_shipping_type_with_http_info(self, shipping_type_id, shipping_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ShippingType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_shipping_type_with_http_info(shipping_type_id, shipping_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int shipping_type_id: Numeric value of the shippingtypeID (required)
        :param ShippingTypeItem shipping_type_item: ShippingType to update (required)
        :return: list[ShippingTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['shipping_type_id', 'shipping_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_shipping_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'shipping_type_id' is set
        if ('shipping_type_id' not in params or
                params['shipping_type_id'] is None):
            raise ValueError("Missing the required parameter `shipping_type_id` when calling `update_shipping_type`")  # noqa: E501
        # verify the required parameter 'shipping_type_item' is set
        if ('shipping_type_item' not in params or
                params['shipping_type_item'] is None):
            raise ValueError("Missing the required parameter `shipping_type_item` when calling `update_shipping_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'shipping_type_id' in params:
            path_params['ShippingTypeID'] = params['shipping_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'shipping_type_item' in params:
            body_params = params['shipping_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ShippingType/{ShippingTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ShippingTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_shopping_cart_item(self, shopping_cart_item_id, shopping_cart_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ShoppingCartItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_shopping_cart_item(shopping_cart_item_id, shopping_cart_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int shopping_cart_item_id: Numeric value of the shoppingcartitemID (required)
        :param ShoppingCartItemItem shopping_cart_item_item: ShoppingCartItem to update (required)
        :return: list[ShoppingCartItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_shopping_cart_item_with_http_info(shopping_cart_item_id, shopping_cart_item_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_shopping_cart_item_with_http_info(shopping_cart_item_id, shopping_cart_item_item, **kwargs)  # noqa: E501
            return data

    def update_shopping_cart_item_with_http_info(self, shopping_cart_item_id, shopping_cart_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ShoppingCartItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_shopping_cart_item_with_http_info(shopping_cart_item_id, shopping_cart_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int shopping_cart_item_id: Numeric value of the shoppingcartitemID (required)
        :param ShoppingCartItemItem shopping_cart_item_item: ShoppingCartItem to update (required)
        :return: list[ShoppingCartItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['shopping_cart_item_id', 'shopping_cart_item_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_shopping_cart_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'shopping_cart_item_id' is set
        if ('shopping_cart_item_id' not in params or
                params['shopping_cart_item_id'] is None):
            raise ValueError("Missing the required parameter `shopping_cart_item_id` when calling `update_shopping_cart_item`")  # noqa: E501
        # verify the required parameter 'shopping_cart_item_item' is set
        if ('shopping_cart_item_item' not in params or
                params['shopping_cart_item_item'] is None):
            raise ValueError("Missing the required parameter `shopping_cart_item_item` when calling `update_shopping_cart_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'shopping_cart_item_id' in params:
            path_params['ShoppingCartItemID'] = params['shopping_cart_item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'shopping_cart_item_item' in params:
            body_params = params['shopping_cart_item_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ShoppingCartItem/{ShoppingCartItemID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ShoppingCartItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_shopping_cart_item_hold(self, shopping_cart_item_hold_id, shopping_cart_item_hold_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ShoppingCartItemHold in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_shopping_cart_item_hold(shopping_cart_item_hold_id, shopping_cart_item_hold_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int shopping_cart_item_hold_id: Numeric value of the shoppingcartitemholdID (required)
        :param ShoppingCartItemHoldItem shopping_cart_item_hold_item: ShoppingCartItemHold to update (required)
        :return: list[ShoppingCartItemHoldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_shopping_cart_item_hold_with_http_info(shopping_cart_item_hold_id, shopping_cart_item_hold_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_shopping_cart_item_hold_with_http_info(shopping_cart_item_hold_id, shopping_cart_item_hold_item, **kwargs)  # noqa: E501
            return data

    def update_shopping_cart_item_hold_with_http_info(self, shopping_cart_item_hold_id, shopping_cart_item_hold_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ShoppingCartItemHold in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_shopping_cart_item_hold_with_http_info(shopping_cart_item_hold_id, shopping_cart_item_hold_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int shopping_cart_item_hold_id: Numeric value of the shoppingcartitemholdID (required)
        :param ShoppingCartItemHoldItem shopping_cart_item_hold_item: ShoppingCartItemHold to update (required)
        :return: list[ShoppingCartItemHoldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['shopping_cart_item_hold_id', 'shopping_cart_item_hold_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_shopping_cart_item_hold" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'shopping_cart_item_hold_id' is set
        if ('shopping_cart_item_hold_id' not in params or
                params['shopping_cart_item_hold_id'] is None):
            raise ValueError("Missing the required parameter `shopping_cart_item_hold_id` when calling `update_shopping_cart_item_hold`")  # noqa: E501
        # verify the required parameter 'shopping_cart_item_hold_item' is set
        if ('shopping_cart_item_hold_item' not in params or
                params['shopping_cart_item_hold_item'] is None):
            raise ValueError("Missing the required parameter `shopping_cart_item_hold_item` when calling `update_shopping_cart_item_hold`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'shopping_cart_item_hold_id' in params:
            path_params['ShoppingCartItemHoldID'] = params['shopping_cart_item_hold_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'shopping_cart_item_hold_item' in params:
            body_params = params['shopping_cart_item_hold_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ShoppingCartItemHold/{ShoppingCartItemHoldID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ShoppingCartItemHoldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_staff(self, staff_id, staff_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Staff in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_staff(staff_id, staff_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int staff_id: Numeric value of the staffID (required)
        :param StaffItem staff_item: Staff to update (required)
        :return: list[StaffItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_staff_with_http_info(staff_id, staff_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_staff_with_http_info(staff_id, staff_item, **kwargs)  # noqa: E501
            return data

    def update_staff_with_http_info(self, staff_id, staff_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Staff in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_staff_with_http_info(staff_id, staff_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int staff_id: Numeric value of the staffID (required)
        :param StaffItem staff_item: Staff to update (required)
        :return: list[StaffItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['staff_id', 'staff_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_staff" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'staff_id' is set
        if ('staff_id' not in params or
                params['staff_id'] is None):
            raise ValueError("Missing the required parameter `staff_id` when calling `update_staff`")  # noqa: E501
        # verify the required parameter 'staff_item' is set
        if ('staff_item' not in params or
                params['staff_item'] is None):
            raise ValueError("Missing the required parameter `staff_item` when calling `update_staff`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'staff_id' in params:
            path_params['StaffID'] = params['staff_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'staff_item' in params:
            body_params = params['staff_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Staff/{StaffID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StaffItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_survey(self, survey_id, survey_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Survey in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_survey(survey_id, survey_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_id: Numeric value of the surveyID (required)
        :param SurveyItem survey_item: Survey to update (required)
        :return: list[SurveyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_survey_with_http_info(survey_id, survey_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_survey_with_http_info(survey_id, survey_item, **kwargs)  # noqa: E501
            return data

    def update_survey_with_http_info(self, survey_id, survey_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Survey in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_survey_with_http_info(survey_id, survey_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_id: Numeric value of the surveyID (required)
        :param SurveyItem survey_item: Survey to update (required)
        :return: list[SurveyItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['survey_id', 'survey_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_survey" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'survey_id' is set
        if ('survey_id' not in params or
                params['survey_id'] is None):
            raise ValueError("Missing the required parameter `survey_id` when calling `update_survey`")  # noqa: E501
        # verify the required parameter 'survey_item' is set
        if ('survey_item' not in params or
                params['survey_item'] is None):
            raise ValueError("Missing the required parameter `survey_item` when calling `update_survey`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'survey_id' in params:
            path_params['SurveyID'] = params['survey_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'survey_item' in params:
            body_params = params['survey_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Survey/{SurveyID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SurveyItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_survey_question(self, survey_question_id, survey_question_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SurveyQuestion in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_survey_question(survey_question_id, survey_question_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_question_id: Numeric value of the surveyquestionID (required)
        :param SurveyQuestionItem survey_question_item: SurveyQuestion to update (required)
        :return: list[SurveyQuestionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_survey_question_with_http_info(survey_question_id, survey_question_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_survey_question_with_http_info(survey_question_id, survey_question_item, **kwargs)  # noqa: E501
            return data

    def update_survey_question_with_http_info(self, survey_question_id, survey_question_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SurveyQuestion in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_survey_question_with_http_info(survey_question_id, survey_question_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_question_id: Numeric value of the surveyquestionID (required)
        :param SurveyQuestionItem survey_question_item: SurveyQuestion to update (required)
        :return: list[SurveyQuestionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['survey_question_id', 'survey_question_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_survey_question" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'survey_question_id' is set
        if ('survey_question_id' not in params or
                params['survey_question_id'] is None):
            raise ValueError("Missing the required parameter `survey_question_id` when calling `update_survey_question`")  # noqa: E501
        # verify the required parameter 'survey_question_item' is set
        if ('survey_question_item' not in params or
                params['survey_question_item'] is None):
            raise ValueError("Missing the required parameter `survey_question_item` when calling `update_survey_question`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'survey_question_id' in params:
            path_params['SurveyQuestionID'] = params['survey_question_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'survey_question_item' in params:
            body_params = params['survey_question_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/SurveyQuestion/{SurveyQuestionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SurveyQuestionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_survey_question_response(self, survey_question_response_id, survey_question_response_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SurveyQuestionResponse in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_survey_question_response(survey_question_response_id, survey_question_response_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_question_response_id: Numeric value of the surveyquestionresponseID (required)
        :param SurveyQuestionResponseItem survey_question_response_item: SurveyQuestionResponse to update (required)
        :return: list[SurveyQuestionResponseItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_survey_question_response_with_http_info(survey_question_response_id, survey_question_response_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_survey_question_response_with_http_info(survey_question_response_id, survey_question_response_item, **kwargs)  # noqa: E501
            return data

    def update_survey_question_response_with_http_info(self, survey_question_response_id, survey_question_response_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SurveyQuestionResponse in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_survey_question_response_with_http_info(survey_question_response_id, survey_question_response_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_question_response_id: Numeric value of the surveyquestionresponseID (required)
        :param SurveyQuestionResponseItem survey_question_response_item: SurveyQuestionResponse to update (required)
        :return: list[SurveyQuestionResponseItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['survey_question_response_id', 'survey_question_response_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_survey_question_response" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'survey_question_response_id' is set
        if ('survey_question_response_id' not in params or
                params['survey_question_response_id'] is None):
            raise ValueError("Missing the required parameter `survey_question_response_id` when calling `update_survey_question_response`")  # noqa: E501
        # verify the required parameter 'survey_question_response_item' is set
        if ('survey_question_response_item' not in params or
                params['survey_question_response_item'] is None):
            raise ValueError("Missing the required parameter `survey_question_response_item` when calling `update_survey_question_response`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'survey_question_response_id' in params:
            path_params['SurveyQuestionResponseID'] = params['survey_question_response_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'survey_question_response_item' in params:
            body_params = params['survey_question_response_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/SurveyQuestionResponse/{SurveyQuestionResponseID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SurveyQuestionResponseItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_survey_response(self, survey_response_id, survey_response_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SurveyResponse in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_survey_response(survey_response_id, survey_response_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_response_id: Numeric value of the surveyresponseID (required)
        :param SurveyResponseItem survey_response_item: SurveyResponse to update (required)
        :return: list[SurveyResponseItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_survey_response_with_http_info(survey_response_id, survey_response_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_survey_response_with_http_info(survey_response_id, survey_response_item, **kwargs)  # noqa: E501
            return data

    def update_survey_response_with_http_info(self, survey_response_id, survey_response_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SurveyResponse in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_survey_response_with_http_info(survey_response_id, survey_response_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_response_id: Numeric value of the surveyresponseID (required)
        :param SurveyResponseItem survey_response_item: SurveyResponse to update (required)
        :return: list[SurveyResponseItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['survey_response_id', 'survey_response_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_survey_response" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'survey_response_id' is set
        if ('survey_response_id' not in params or
                params['survey_response_id'] is None):
            raise ValueError("Missing the required parameter `survey_response_id` when calling `update_survey_response`")  # noqa: E501
        # verify the required parameter 'survey_response_item' is set
        if ('survey_response_item' not in params or
                params['survey_response_item'] is None):
            raise ValueError("Missing the required parameter `survey_response_item` when calling `update_survey_response`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'survey_response_id' in params:
            path_params['SurveyResponseID'] = params['survey_response_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'survey_response_item' in params:
            body_params = params['survey_response_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/SurveyResponse/{SurveyResponseID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SurveyResponseItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_survey_type(self, survey_type_id, survey_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SurveyType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_survey_type(survey_type_id, survey_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_type_id: Numeric value of the surveytypeID (required)
        :param SurveyTypeItem survey_type_item: SurveyType to update (required)
        :return: list[SurveyTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_survey_type_with_http_info(survey_type_id, survey_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_survey_type_with_http_info(survey_type_id, survey_type_item, **kwargs)  # noqa: E501
            return data

    def update_survey_type_with_http_info(self, survey_type_id, survey_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SurveyType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_survey_type_with_http_info(survey_type_id, survey_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int survey_type_id: Numeric value of the surveytypeID (required)
        :param SurveyTypeItem survey_type_item: SurveyType to update (required)
        :return: list[SurveyTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['survey_type_id', 'survey_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_survey_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'survey_type_id' is set
        if ('survey_type_id' not in params or
                params['survey_type_id'] is None):
            raise ValueError("Missing the required parameter `survey_type_id` when calling `update_survey_type`")  # noqa: E501
        # verify the required parameter 'survey_type_item' is set
        if ('survey_type_item' not in params or
                params['survey_type_item'] is None):
            raise ValueError("Missing the required parameter `survey_type_item` when calling `update_survey_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'survey_type_id' in params:
            path_params['SurveyTypeID'] = params['survey_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'survey_type_item' in params:
            body_params = params['survey_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/SurveyType/{SurveyTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SurveyTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_system_activity(self, system_activity_id, system_activity_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SystemActivity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_system_activity(system_activity_id, system_activity_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int system_activity_id: Numeric value of the systemactivityID (required)
        :param SystemActivityItem system_activity_item: SystemActivity to update (required)
        :return: list[SystemActivityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_system_activity_with_http_info(system_activity_id, system_activity_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_system_activity_with_http_info(system_activity_id, system_activity_item, **kwargs)  # noqa: E501
            return data

    def update_system_activity_with_http_info(self, system_activity_id, system_activity_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an SystemActivity in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_system_activity_with_http_info(system_activity_id, system_activity_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int system_activity_id: Numeric value of the systemactivityID (required)
        :param SystemActivityItem system_activity_item: SystemActivity to update (required)
        :return: list[SystemActivityItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_activity_id', 'system_activity_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_system_activity" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system_activity_id' is set
        if ('system_activity_id' not in params or
                params['system_activity_id'] is None):
            raise ValueError("Missing the required parameter `system_activity_id` when calling `update_system_activity`")  # noqa: E501
        # verify the required parameter 'system_activity_item' is set
        if ('system_activity_item' not in params or
                params['system_activity_item'] is None):
            raise ValueError("Missing the required parameter `system_activity_item` when calling `update_system_activity`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'system_activity_id' in params:
            path_params['SystemActivityID'] = params['system_activity_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'system_activity_item' in params:
            body_params = params['system_activity_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/SystemActivity/{SystemActivityID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SystemActivityItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_task(self, task_id, task_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Task in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_task(task_id, task_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_id: Numeric value of the taskID (required)
        :param TaskItem task_item: Task to update (required)
        :return: list[TaskItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_task_with_http_info(task_id, task_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_task_with_http_info(task_id, task_item, **kwargs)  # noqa: E501
            return data

    def update_task_with_http_info(self, task_id, task_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Task in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_task_with_http_info(task_id, task_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_id: Numeric value of the taskID (required)
        :param TaskItem task_item: Task to update (required)
        :return: list[TaskItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_id', 'task_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_task" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_id' is set
        if ('task_id' not in params or
                params['task_id'] is None):
            raise ValueError("Missing the required parameter `task_id` when calling `update_task`")  # noqa: E501
        # verify the required parameter 'task_item' is set
        if ('task_item' not in params or
                params['task_item'] is None):
            raise ValueError("Missing the required parameter `task_item` when calling `update_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_id' in params:
            path_params['TaskID'] = params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'task_item' in params:
            body_params = params['task_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Task/{TaskID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TaskItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_task_runner_history(self, task_runner_history_id, task_runner_history_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TaskRunnerHistory in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_task_runner_history(task_runner_history_id, task_runner_history_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_runner_history_id: Numeric value of the taskrunnerhistoryID (required)
        :param TaskRunnerHistoryItem task_runner_history_item: TaskRunnerHistory to update (required)
        :return: list[TaskRunnerHistoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_task_runner_history_with_http_info(task_runner_history_id, task_runner_history_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_task_runner_history_with_http_info(task_runner_history_id, task_runner_history_item, **kwargs)  # noqa: E501
            return data

    def update_task_runner_history_with_http_info(self, task_runner_history_id, task_runner_history_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TaskRunnerHistory in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_task_runner_history_with_http_info(task_runner_history_id, task_runner_history_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_runner_history_id: Numeric value of the taskrunnerhistoryID (required)
        :param TaskRunnerHistoryItem task_runner_history_item: TaskRunnerHistory to update (required)
        :return: list[TaskRunnerHistoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_runner_history_id', 'task_runner_history_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_task_runner_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_runner_history_id' is set
        if ('task_runner_history_id' not in params or
                params['task_runner_history_id'] is None):
            raise ValueError("Missing the required parameter `task_runner_history_id` when calling `update_task_runner_history`")  # noqa: E501
        # verify the required parameter 'task_runner_history_item' is set
        if ('task_runner_history_item' not in params or
                params['task_runner_history_item'] is None):
            raise ValueError("Missing the required parameter `task_runner_history_item` when calling `update_task_runner_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_runner_history_id' in params:
            path_params['TaskRunnerHistoryID'] = params['task_runner_history_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'task_runner_history_item' in params:
            body_params = params['task_runner_history_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TaskRunnerHistory/{TaskRunnerHistoryID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TaskRunnerHistoryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_task_status(self, task_status_id, task_status_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TaskStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_task_status(task_status_id, task_status_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_status_id: Numeric value of the taskstatusID (required)
        :param TaskStatusItem task_status_item: TaskStatus to update (required)
        :return: list[TaskStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_task_status_with_http_info(task_status_id, task_status_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_task_status_with_http_info(task_status_id, task_status_item, **kwargs)  # noqa: E501
            return data

    def update_task_status_with_http_info(self, task_status_id, task_status_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TaskStatus in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_task_status_with_http_info(task_status_id, task_status_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_status_id: Numeric value of the taskstatusID (required)
        :param TaskStatusItem task_status_item: TaskStatus to update (required)
        :return: list[TaskStatusItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_status_id', 'task_status_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_task_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_status_id' is set
        if ('task_status_id' not in params or
                params['task_status_id'] is None):
            raise ValueError("Missing the required parameter `task_status_id` when calling `update_task_status`")  # noqa: E501
        # verify the required parameter 'task_status_item' is set
        if ('task_status_item' not in params or
                params['task_status_item'] is None):
            raise ValueError("Missing the required parameter `task_status_item` when calling `update_task_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_status_id' in params:
            path_params['TaskStatusID'] = params['task_status_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'task_status_item' in params:
            body_params = params['task_status_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TaskStatus/{TaskStatusID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TaskStatusItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_task_template(self, task_template_id, task_template_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TaskTemplate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_task_template(task_template_id, task_template_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_template_id: Numeric value of the tasktemplateID (required)
        :param TaskTemplateItem task_template_item: TaskTemplate to update (required)
        :return: list[TaskTemplateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_task_template_with_http_info(task_template_id, task_template_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_task_template_with_http_info(task_template_id, task_template_item, **kwargs)  # noqa: E501
            return data

    def update_task_template_with_http_info(self, task_template_id, task_template_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TaskTemplate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_task_template_with_http_info(task_template_id, task_template_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_template_id: Numeric value of the tasktemplateID (required)
        :param TaskTemplateItem task_template_item: TaskTemplate to update (required)
        :return: list[TaskTemplateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_template_id', 'task_template_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_task_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_template_id' is set
        if ('task_template_id' not in params or
                params['task_template_id'] is None):
            raise ValueError("Missing the required parameter `task_template_id` when calling `update_task_template`")  # noqa: E501
        # verify the required parameter 'task_template_item' is set
        if ('task_template_item' not in params or
                params['task_template_item'] is None):
            raise ValueError("Missing the required parameter `task_template_item` when calling `update_task_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_template_id' in params:
            path_params['TaskTemplateID'] = params['task_template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'task_template_item' in params:
            body_params = params['task_template_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TaskTemplate/{TaskTemplateID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TaskTemplateItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_task_template_item(self, task_template_item_id, task_template_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TaskTemplateItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_task_template_item(task_template_item_id, task_template_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_template_item_id: Numeric value of the tasktemplateitemID (required)
        :param TaskTemplateItemItem task_template_item_item: TaskTemplateItem to update (required)
        :return: list[TaskTemplateItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_task_template_item_with_http_info(task_template_item_id, task_template_item_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_task_template_item_with_http_info(task_template_item_id, task_template_item_item, **kwargs)  # noqa: E501
            return data

    def update_task_template_item_with_http_info(self, task_template_item_id, task_template_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TaskTemplateItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_task_template_item_with_http_info(task_template_item_id, task_template_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_template_item_id: Numeric value of the tasktemplateitemID (required)
        :param TaskTemplateItemItem task_template_item_item: TaskTemplateItem to update (required)
        :return: list[TaskTemplateItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_template_item_id', 'task_template_item_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_task_template_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_template_item_id' is set
        if ('task_template_item_id' not in params or
                params['task_template_item_id'] is None):
            raise ValueError("Missing the required parameter `task_template_item_id` when calling `update_task_template_item`")  # noqa: E501
        # verify the required parameter 'task_template_item_item' is set
        if ('task_template_item_item' not in params or
                params['task_template_item_item'] is None):
            raise ValueError("Missing the required parameter `task_template_item_item` when calling `update_task_template_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_template_item_id' in params:
            path_params['TaskTemplateItemID'] = params['task_template_item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'task_template_item_item' in params:
            body_params = params['task_template_item_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TaskTemplateItem/{TaskTemplateItemID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TaskTemplateItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_task_type(self, task_type_id, task_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TaskType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_task_type(task_type_id, task_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_type_id: Numeric value of the tasktypeID (required)
        :param TaskTypeItem task_type_item: TaskType to update (required)
        :return: list[TaskTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_task_type_with_http_info(task_type_id, task_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_task_type_with_http_info(task_type_id, task_type_item, **kwargs)  # noqa: E501
            return data

    def update_task_type_with_http_info(self, task_type_id, task_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TaskType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_task_type_with_http_info(task_type_id, task_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int task_type_id: Numeric value of the tasktypeID (required)
        :param TaskTypeItem task_type_item: TaskType to update (required)
        :return: list[TaskTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['task_type_id', 'task_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_task_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'task_type_id' is set
        if ('task_type_id' not in params or
                params['task_type_id'] is None):
            raise ValueError("Missing the required parameter `task_type_id` when calling `update_task_type`")  # noqa: E501
        # verify the required parameter 'task_type_item' is set
        if ('task_type_item' not in params or
                params['task_type_item'] is None):
            raise ValueError("Missing the required parameter `task_type_item` when calling `update_task_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'task_type_id' in params:
            path_params['TaskTypeID'] = params['task_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'task_type_item' in params:
            body_params = params['task_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TaskType/{TaskTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TaskTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_template(self, template_id, template_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Template in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_template(template_id, template_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int template_id: Numeric value of the templateID (required)
        :param TemplateItem template_item: Template to update (required)
        :return: list[TemplateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_template_with_http_info(template_id, template_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_template_with_http_info(template_id, template_item, **kwargs)  # noqa: E501
            return data

    def update_template_with_http_info(self, template_id, template_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Template in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_template_with_http_info(template_id, template_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int template_id: Numeric value of the templateID (required)
        :param TemplateItem template_item: Template to update (required)
        :return: list[TemplateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_id', 'template_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'template_id' is set
        if ('template_id' not in params or
                params['template_id'] is None):
            raise ValueError("Missing the required parameter `template_id` when calling `update_template`")  # noqa: E501
        # verify the required parameter 'template_item' is set
        if ('template_item' not in params or
                params['template_item'] is None):
            raise ValueError("Missing the required parameter `template_item` when calling `update_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_id' in params:
            path_params['TemplateID'] = params['template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'template_item' in params:
            body_params = params['template_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Template/{TemplateID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TemplateItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_template_permission(self, template_permission_id, template_permission_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TemplatePermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_template_permission(template_permission_id, template_permission_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int template_permission_id: Numeric value of the templatepermissionID (required)
        :param TemplatePermissionItem template_permission_item: TemplatePermission to update (required)
        :return: list[TemplatePermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_template_permission_with_http_info(template_permission_id, template_permission_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_template_permission_with_http_info(template_permission_id, template_permission_item, **kwargs)  # noqa: E501
            return data

    def update_template_permission_with_http_info(self, template_permission_id, template_permission_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TemplatePermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_template_permission_with_http_info(template_permission_id, template_permission_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int template_permission_id: Numeric value of the templatepermissionID (required)
        :param TemplatePermissionItem template_permission_item: TemplatePermission to update (required)
        :return: list[TemplatePermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['template_permission_id', 'template_permission_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_template_permission" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'template_permission_id' is set
        if ('template_permission_id' not in params or
                params['template_permission_id'] is None):
            raise ValueError("Missing the required parameter `template_permission_id` when calling `update_template_permission`")  # noqa: E501
        # verify the required parameter 'template_permission_item' is set
        if ('template_permission_item' not in params or
                params['template_permission_item'] is None):
            raise ValueError("Missing the required parameter `template_permission_item` when calling `update_template_permission`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'template_permission_id' in params:
            path_params['TemplatePermissionID'] = params['template_permission_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'template_permission_item' in params:
            body_params = params['template_permission_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TemplatePermission/{TemplatePermissionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TemplatePermissionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_term(self, term_id, term_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Term in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_term(term_id, term_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_id: Numeric value of the termID (required)
        :param TermItem term_item: Term to update (required)
        :return: list[TermItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_term_with_http_info(term_id, term_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_term_with_http_info(term_id, term_item, **kwargs)  # noqa: E501
            return data

    def update_term_with_http_info(self, term_id, term_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Term in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_term_with_http_info(term_id, term_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_id: Numeric value of the termID (required)
        :param TermItem term_item: Term to update (required)
        :return: list[TermItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['term_id', 'term_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_term" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'term_id' is set
        if ('term_id' not in params or
                params['term_id'] is None):
            raise ValueError("Missing the required parameter `term_id` when calling `update_term`")  # noqa: E501
        # verify the required parameter 'term_item' is set
        if ('term_item' not in params or
                params['term_item'] is None):
            raise ValueError("Missing the required parameter `term_item` when calling `update_term`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'term_id' in params:
            path_params['TermID'] = params['term_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'term_item' in params:
            body_params = params['term_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Term/{TermID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TermItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_term_rule(self, term_rule_id, term_rule_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TermRule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_term_rule(term_rule_id, term_rule_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_rule_id: Numeric value of the termruleID (required)
        :param TermRuleItem term_rule_item: TermRule to update (required)
        :return: list[TermRuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_term_rule_with_http_info(term_rule_id, term_rule_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_term_rule_with_http_info(term_rule_id, term_rule_item, **kwargs)  # noqa: E501
            return data

    def update_term_rule_with_http_info(self, term_rule_id, term_rule_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TermRule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_term_rule_with_http_info(term_rule_id, term_rule_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_rule_id: Numeric value of the termruleID (required)
        :param TermRuleItem term_rule_item: TermRule to update (required)
        :return: list[TermRuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['term_rule_id', 'term_rule_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_term_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'term_rule_id' is set
        if ('term_rule_id' not in params or
                params['term_rule_id'] is None):
            raise ValueError("Missing the required parameter `term_rule_id` when calling `update_term_rule`")  # noqa: E501
        # verify the required parameter 'term_rule_item' is set
        if ('term_rule_item' not in params or
                params['term_rule_item'] is None):
            raise ValueError("Missing the required parameter `term_rule_item` when calling `update_term_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'term_rule_id' in params:
            path_params['TermRuleID'] = params['term_rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'term_rule_item' in params:
            body_params = params['term_rule_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TermRule/{TermRuleID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TermRuleItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_term_session(self, term_session_id, term_session_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TermSession in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_term_session(term_session_id, term_session_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_session_id: Numeric value of the termsessionID (required)
        :param TermSessionItem term_session_item: TermSession to update (required)
        :return: list[TermSessionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_term_session_with_http_info(term_session_id, term_session_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_term_session_with_http_info(term_session_id, term_session_item, **kwargs)  # noqa: E501
            return data

    def update_term_session_with_http_info(self, term_session_id, term_session_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TermSession in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_term_session_with_http_info(term_session_id, term_session_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_session_id: Numeric value of the termsessionID (required)
        :param TermSessionItem term_session_item: TermSession to update (required)
        :return: list[TermSessionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['term_session_id', 'term_session_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_term_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'term_session_id' is set
        if ('term_session_id' not in params or
                params['term_session_id'] is None):
            raise ValueError("Missing the required parameter `term_session_id` when calling `update_term_session`")  # noqa: E501
        # verify the required parameter 'term_session_item' is set
        if ('term_session_item' not in params or
                params['term_session_item'] is None):
            raise ValueError("Missing the required parameter `term_session_item` when calling `update_term_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'term_session_id' in params:
            path_params['TermSessionID'] = params['term_session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'term_session_item' in params:
            body_params = params['term_session_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TermSession/{TermSessionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TermSessionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_term_session_free(self, term_session_free_id, term_session_free_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TermSessionFree in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_term_session_free(term_session_free_id, term_session_free_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_session_free_id: Numeric value of the termsessionfreeID (required)
        :param TermSessionFreeItem term_session_free_item: TermSessionFree to update (required)
        :return: list[TermSessionFreeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_term_session_free_with_http_info(term_session_free_id, term_session_free_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_term_session_free_with_http_info(term_session_free_id, term_session_free_item, **kwargs)  # noqa: E501
            return data

    def update_term_session_free_with_http_info(self, term_session_free_id, term_session_free_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TermSessionFree in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_term_session_free_with_http_info(term_session_free_id, term_session_free_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_session_free_id: Numeric value of the termsessionfreeID (required)
        :param TermSessionFreeItem term_session_free_item: TermSessionFree to update (required)
        :return: list[TermSessionFreeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['term_session_free_id', 'term_session_free_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_term_session_free" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'term_session_free_id' is set
        if ('term_session_free_id' not in params or
                params['term_session_free_id'] is None):
            raise ValueError("Missing the required parameter `term_session_free_id` when calling `update_term_session_free`")  # noqa: E501
        # verify the required parameter 'term_session_free_item' is set
        if ('term_session_free_item' not in params or
                params['term_session_free_item'] is None):
            raise ValueError("Missing the required parameter `term_session_free_item` when calling `update_term_session_free`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'term_session_free_id' in params:
            path_params['TermSessionFreeID'] = params['term_session_free_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'term_session_free_item' in params:
            body_params = params['term_session_free_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TermSessionFree/{TermSessionFreeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TermSessionFreeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_term_type(self, term_type_id, term_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TermType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_term_type(term_type_id, term_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_type_id: Numeric value of the termtypeID (required)
        :param TermTypeItem term_type_item: TermType to update (required)
        :return: list[TermTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_term_type_with_http_info(term_type_id, term_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_term_type_with_http_info(term_type_id, term_type_item, **kwargs)  # noqa: E501
            return data

    def update_term_type_with_http_info(self, term_type_id, term_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TermType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_term_type_with_http_info(term_type_id, term_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int term_type_id: Numeric value of the termtypeID (required)
        :param TermTypeItem term_type_item: TermType to update (required)
        :return: list[TermTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['term_type_id', 'term_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_term_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'term_type_id' is set
        if ('term_type_id' not in params or
                params['term_type_id'] is None):
            raise ValueError("Missing the required parameter `term_type_id` when calling `update_term_type`")  # noqa: E501
        # verify the required parameter 'term_type_item' is set
        if ('term_type_item' not in params or
                params['term_type_item'] is None):
            raise ValueError("Missing the required parameter `term_type_item` when calling `update_term_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'term_type_id' in params:
            path_params['TermTypeID'] = params['term_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'term_type_item' in params:
            body_params = params['term_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TermType/{TermTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TermTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_time_slot(self, time_slot_id, time_slot_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TimeSlot in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_time_slot(time_slot_id, time_slot_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int time_slot_id: Numeric value of the timeslotID (required)
        :param TimeSlotItem time_slot_item: TimeSlot to update (required)
        :return: list[TimeSlotItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_time_slot_with_http_info(time_slot_id, time_slot_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_time_slot_with_http_info(time_slot_id, time_slot_item, **kwargs)  # noqa: E501
            return data

    def update_time_slot_with_http_info(self, time_slot_id, time_slot_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TimeSlot in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_time_slot_with_http_info(time_slot_id, time_slot_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int time_slot_id: Numeric value of the timeslotID (required)
        :param TimeSlotItem time_slot_item: TimeSlot to update (required)
        :return: list[TimeSlotItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['time_slot_id', 'time_slot_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_time_slot" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'time_slot_id' is set
        if ('time_slot_id' not in params or
                params['time_slot_id'] is None):
            raise ValueError("Missing the required parameter `time_slot_id` when calling `update_time_slot`")  # noqa: E501
        # verify the required parameter 'time_slot_item' is set
        if ('time_slot_item' not in params or
                params['time_slot_item'] is None):
            raise ValueError("Missing the required parameter `time_slot_item` when calling `update_time_slot`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'time_slot_id' in params:
            path_params['TimeSlotID'] = params['time_slot_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'time_slot_item' in params:
            body_params = params['time_slot_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TimeSlot/{TimeSlotID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TimeSlotItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_title(self, title_id, title_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Title in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_title(title_id, title_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int title_id: Numeric value of the titleID (required)
        :param TitleItem title_item: Title to update (required)
        :return: list[TitleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_title_with_http_info(title_id, title_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_title_with_http_info(title_id, title_item, **kwargs)  # noqa: E501
            return data

    def update_title_with_http_info(self, title_id, title_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Title in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_title_with_http_info(title_id, title_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int title_id: Numeric value of the titleID (required)
        :param TitleItem title_item: Title to update (required)
        :return: list[TitleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['title_id', 'title_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_title" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'title_id' is set
        if ('title_id' not in params or
                params['title_id'] is None):
            raise ValueError("Missing the required parameter `title_id` when calling `update_title`")  # noqa: E501
        # verify the required parameter 'title_item' is set
        if ('title_item' not in params or
                params['title_item'] is None):
            raise ValueError("Missing the required parameter `title_item` when calling `update_title`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'title_id' in params:
            path_params['TitleID'] = params['title_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'title_item' in params:
            body_params = params['title_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Title/{TitleID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TitleItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_total(self, total_id, total_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Total in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_total(total_id, total_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int total_id: Numeric value of the totalID (required)
        :param TotalItem total_item: Total to update (required)
        :return: list[TotalItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_total_with_http_info(total_id, total_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_total_with_http_info(total_id, total_item, **kwargs)  # noqa: E501
            return data

    def update_total_with_http_info(self, total_id, total_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Total in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_total_with_http_info(total_id, total_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int total_id: Numeric value of the totalID (required)
        :param TotalItem total_item: Total to update (required)
        :return: list[TotalItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['total_id', 'total_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_total" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'total_id' is set
        if ('total_id' not in params or
                params['total_id'] is None):
            raise ValueError("Missing the required parameter `total_id` when calling `update_total`")  # noqa: E501
        # verify the required parameter 'total_item' is set
        if ('total_item' not in params or
                params['total_item'] is None):
            raise ValueError("Missing the required parameter `total_item` when calling `update_total`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'total_id' in params:
            path_params['TotalID'] = params['total_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'total_item' in params:
            body_params = params['total_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Total/{TotalID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TotalItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transaction(self, transaction_id, transaction_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Transaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction(transaction_id, transaction_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_id: Numeric value of the transactionID (required)
        :param TransactionItem transaction_item: Transaction to update (required)
        :return: list[TransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_transaction_with_http_info(transaction_id, transaction_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transaction_with_http_info(transaction_id, transaction_item, **kwargs)  # noqa: E501
            return data

    def update_transaction_with_http_info(self, transaction_id, transaction_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Transaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction_with_http_info(transaction_id, transaction_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_id: Numeric value of the transactionID (required)
        :param TransactionItem transaction_item: Transaction to update (required)
        :return: list[TransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_id', 'transaction_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transaction_id' is set
        if ('transaction_id' not in params or
                params['transaction_id'] is None):
            raise ValueError("Missing the required parameter `transaction_id` when calling `update_transaction`")  # noqa: E501
        # verify the required parameter 'transaction_item' is set
        if ('transaction_item' not in params or
                params['transaction_item'] is None):
            raise ValueError("Missing the required parameter `transaction_item` when calling `update_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transaction_id' in params:
            path_params['TransactionID'] = params['transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transaction_item' in params:
            body_params = params['transaction_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Transaction/{TransactionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transaction_dispute(self, transaction_dispute_id, transaction_dispute_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TransactionDispute in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction_dispute(transaction_dispute_id, transaction_dispute_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_dispute_id: Numeric value of the transactiondisputeID (required)
        :param TransactionDisputeItem transaction_dispute_item: TransactionDispute to update (required)
        :return: list[TransactionDisputeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_transaction_dispute_with_http_info(transaction_dispute_id, transaction_dispute_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transaction_dispute_with_http_info(transaction_dispute_id, transaction_dispute_item, **kwargs)  # noqa: E501
            return data

    def update_transaction_dispute_with_http_info(self, transaction_dispute_id, transaction_dispute_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TransactionDispute in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction_dispute_with_http_info(transaction_dispute_id, transaction_dispute_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_dispute_id: Numeric value of the transactiondisputeID (required)
        :param TransactionDisputeItem transaction_dispute_item: TransactionDispute to update (required)
        :return: list[TransactionDisputeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_dispute_id', 'transaction_dispute_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transaction_dispute" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transaction_dispute_id' is set
        if ('transaction_dispute_id' not in params or
                params['transaction_dispute_id'] is None):
            raise ValueError("Missing the required parameter `transaction_dispute_id` when calling `update_transaction_dispute`")  # noqa: E501
        # verify the required parameter 'transaction_dispute_item' is set
        if ('transaction_dispute_item' not in params or
                params['transaction_dispute_item'] is None):
            raise ValueError("Missing the required parameter `transaction_dispute_item` when calling `update_transaction_dispute`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transaction_dispute_id' in params:
            path_params['TransactionDisputeID'] = params['transaction_dispute_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transaction_dispute_item' in params:
            body_params = params['transaction_dispute_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TransactionDispute/{TransactionDisputeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionDisputeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transaction_dispute_custom_field(self, transaction_dispute_custom_field_id, transaction_dispute_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TransactionDisputeCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction_dispute_custom_field(transaction_dispute_custom_field_id, transaction_dispute_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_dispute_custom_field_id: Numeric value of the transactiondisputecustomfieldID (required)
        :param TransactionDisputeCustomFieldItem transaction_dispute_custom_field_item: TransactionDisputeCustomField to update (required)
        :return: list[TransactionDisputeCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_transaction_dispute_custom_field_with_http_info(transaction_dispute_custom_field_id, transaction_dispute_custom_field_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transaction_dispute_custom_field_with_http_info(transaction_dispute_custom_field_id, transaction_dispute_custom_field_item, **kwargs)  # noqa: E501
            return data

    def update_transaction_dispute_custom_field_with_http_info(self, transaction_dispute_custom_field_id, transaction_dispute_custom_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TransactionDisputeCustomField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction_dispute_custom_field_with_http_info(transaction_dispute_custom_field_id, transaction_dispute_custom_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_dispute_custom_field_id: Numeric value of the transactiondisputecustomfieldID (required)
        :param TransactionDisputeCustomFieldItem transaction_dispute_custom_field_item: TransactionDisputeCustomField to update (required)
        :return: list[TransactionDisputeCustomFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_dispute_custom_field_id', 'transaction_dispute_custom_field_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transaction_dispute_custom_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transaction_dispute_custom_field_id' is set
        if ('transaction_dispute_custom_field_id' not in params or
                params['transaction_dispute_custom_field_id'] is None):
            raise ValueError("Missing the required parameter `transaction_dispute_custom_field_id` when calling `update_transaction_dispute_custom_field`")  # noqa: E501
        # verify the required parameter 'transaction_dispute_custom_field_item' is set
        if ('transaction_dispute_custom_field_item' not in params or
                params['transaction_dispute_custom_field_item'] is None):
            raise ValueError("Missing the required parameter `transaction_dispute_custom_field_item` when calling `update_transaction_dispute_custom_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transaction_dispute_custom_field_id' in params:
            path_params['TransactionDisputeCustomFieldID'] = params['transaction_dispute_custom_field_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transaction_dispute_custom_field_item' in params:
            body_params = params['transaction_dispute_custom_field_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TransactionDisputeCustomField/{TransactionDisputeCustomFieldID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionDisputeCustomFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transaction_dispute_item(self, transaction_dispute_item_id, transaction_dispute_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TransactionDisputeItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction_dispute_item(transaction_dispute_item_id, transaction_dispute_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_dispute_item_id: Numeric value of the transactiondisputeitemID (required)
        :param TransactionDisputeItemItem transaction_dispute_item_item: TransactionDisputeItem to update (required)
        :return: list[TransactionDisputeItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_transaction_dispute_item_with_http_info(transaction_dispute_item_id, transaction_dispute_item_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transaction_dispute_item_with_http_info(transaction_dispute_item_id, transaction_dispute_item_item, **kwargs)  # noqa: E501
            return data

    def update_transaction_dispute_item_with_http_info(self, transaction_dispute_item_id, transaction_dispute_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TransactionDisputeItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction_dispute_item_with_http_info(transaction_dispute_item_id, transaction_dispute_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_dispute_item_id: Numeric value of the transactiondisputeitemID (required)
        :param TransactionDisputeItemItem transaction_dispute_item_item: TransactionDisputeItem to update (required)
        :return: list[TransactionDisputeItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_dispute_item_id', 'transaction_dispute_item_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transaction_dispute_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transaction_dispute_item_id' is set
        if ('transaction_dispute_item_id' not in params or
                params['transaction_dispute_item_id'] is None):
            raise ValueError("Missing the required parameter `transaction_dispute_item_id` when calling `update_transaction_dispute_item`")  # noqa: E501
        # verify the required parameter 'transaction_dispute_item_item' is set
        if ('transaction_dispute_item_item' not in params or
                params['transaction_dispute_item_item'] is None):
            raise ValueError("Missing the required parameter `transaction_dispute_item_item` when calling `update_transaction_dispute_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transaction_dispute_item_id' in params:
            path_params['TransactionDisputeItemID'] = params['transaction_dispute_item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transaction_dispute_item_item' in params:
            body_params = params['transaction_dispute_item_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TransactionDisputeItem/{TransactionDisputeItemID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionDisputeItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transaction_link(self, transaction_link_id, transaction_link_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TransactionLink in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction_link(transaction_link_id, transaction_link_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_link_id: Numeric value of the transactionlinkID (required)
        :param TransactionLinkItem transaction_link_item: TransactionLink to update (required)
        :return: list[TransactionLinkItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_transaction_link_with_http_info(transaction_link_id, transaction_link_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transaction_link_with_http_info(transaction_link_id, transaction_link_item, **kwargs)  # noqa: E501
            return data

    def update_transaction_link_with_http_info(self, transaction_link_id, transaction_link_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TransactionLink in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction_link_with_http_info(transaction_link_id, transaction_link_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_link_id: Numeric value of the transactionlinkID (required)
        :param TransactionLinkItem transaction_link_item: TransactionLink to update (required)
        :return: list[TransactionLinkItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_link_id', 'transaction_link_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transaction_link" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transaction_link_id' is set
        if ('transaction_link_id' not in params or
                params['transaction_link_id'] is None):
            raise ValueError("Missing the required parameter `transaction_link_id` when calling `update_transaction_link`")  # noqa: E501
        # verify the required parameter 'transaction_link_item' is set
        if ('transaction_link_item' not in params or
                params['transaction_link_item'] is None):
            raise ValueError("Missing the required parameter `transaction_link_item` when calling `update_transaction_link`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transaction_link_id' in params:
            path_params['TransactionLinkID'] = params['transaction_link_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transaction_link_item' in params:
            body_params = params['transaction_link_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TransactionLink/{TransactionLinkID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionLinkItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transaction_link_item(self, transaction_link_item_id, transaction_link_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TransactionLinkItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction_link_item(transaction_link_item_id, transaction_link_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_link_item_id: Numeric value of the transactionlinkitemID (required)
        :param TransactionLinkItemItem transaction_link_item_item: TransactionLinkItem to update (required)
        :return: list[TransactionLinkItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_transaction_link_item_with_http_info(transaction_link_item_id, transaction_link_item_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transaction_link_item_with_http_info(transaction_link_item_id, transaction_link_item_item, **kwargs)  # noqa: E501
            return data

    def update_transaction_link_item_with_http_info(self, transaction_link_item_id, transaction_link_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TransactionLinkItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction_link_item_with_http_info(transaction_link_item_id, transaction_link_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_link_item_id: Numeric value of the transactionlinkitemID (required)
        :param TransactionLinkItemItem transaction_link_item_item: TransactionLinkItem to update (required)
        :return: list[TransactionLinkItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_link_item_id', 'transaction_link_item_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transaction_link_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transaction_link_item_id' is set
        if ('transaction_link_item_id' not in params or
                params['transaction_link_item_id'] is None):
            raise ValueError("Missing the required parameter `transaction_link_item_id` when calling `update_transaction_link_item`")  # noqa: E501
        # verify the required parameter 'transaction_link_item_item' is set
        if ('transaction_link_item_item' not in params or
                params['transaction_link_item_item'] is None):
            raise ValueError("Missing the required parameter `transaction_link_item_item` when calling `update_transaction_link_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transaction_link_item_id' in params:
            path_params['TransactionLinkItemID'] = params['transaction_link_item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transaction_link_item_item' in params:
            body_params = params['transaction_link_item_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TransactionLinkItem/{TransactionLinkItemID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionLinkItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transaction_tag(self, transaction_tag_id, transaction_tag_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TransactionTag in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction_tag(transaction_tag_id, transaction_tag_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_tag_id: Numeric value of the transactiontagID (required)
        :param TransactionTagItem transaction_tag_item: TransactionTag to update (required)
        :return: list[TransactionTagItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_transaction_tag_with_http_info(transaction_tag_id, transaction_tag_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transaction_tag_with_http_info(transaction_tag_id, transaction_tag_item, **kwargs)  # noqa: E501
            return data

    def update_transaction_tag_with_http_info(self, transaction_tag_id, transaction_tag_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TransactionTag in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction_tag_with_http_info(transaction_tag_id, transaction_tag_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_tag_id: Numeric value of the transactiontagID (required)
        :param TransactionTagItem transaction_tag_item: TransactionTag to update (required)
        :return: list[TransactionTagItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_tag_id', 'transaction_tag_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transaction_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transaction_tag_id' is set
        if ('transaction_tag_id' not in params or
                params['transaction_tag_id'] is None):
            raise ValueError("Missing the required parameter `transaction_tag_id` when calling `update_transaction_tag`")  # noqa: E501
        # verify the required parameter 'transaction_tag_item' is set
        if ('transaction_tag_item' not in params or
                params['transaction_tag_item'] is None):
            raise ValueError("Missing the required parameter `transaction_tag_item` when calling `update_transaction_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transaction_tag_id' in params:
            path_params['TransactionTagID'] = params['transaction_tag_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transaction_tag_item' in params:
            body_params = params['transaction_tag_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TransactionTag/{TransactionTagID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionTagItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transaction_template(self, transaction_template_id, transaction_template_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TransactionTemplate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction_template(transaction_template_id, transaction_template_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_template_id: Numeric value of the transactiontemplateID (required)
        :param TransactionTemplateItem transaction_template_item: TransactionTemplate to update (required)
        :return: list[TransactionTemplateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_transaction_template_with_http_info(transaction_template_id, transaction_template_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transaction_template_with_http_info(transaction_template_id, transaction_template_item, **kwargs)  # noqa: E501
            return data

    def update_transaction_template_with_http_info(self, transaction_template_id, transaction_template_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TransactionTemplate in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction_template_with_http_info(transaction_template_id, transaction_template_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_template_id: Numeric value of the transactiontemplateID (required)
        :param TransactionTemplateItem transaction_template_item: TransactionTemplate to update (required)
        :return: list[TransactionTemplateItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_template_id', 'transaction_template_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transaction_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transaction_template_id' is set
        if ('transaction_template_id' not in params or
                params['transaction_template_id'] is None):
            raise ValueError("Missing the required parameter `transaction_template_id` when calling `update_transaction_template`")  # noqa: E501
        # verify the required parameter 'transaction_template_item' is set
        if ('transaction_template_item' not in params or
                params['transaction_template_item'] is None):
            raise ValueError("Missing the required parameter `transaction_template_item` when calling `update_transaction_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transaction_template_id' in params:
            path_params['TransactionTemplateID'] = params['transaction_template_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transaction_template_item' in params:
            body_params = params['transaction_template_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TransactionTemplate/{TransactionTemplateID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionTemplateItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_transaction_template_item(self, transaction_template_item_id, transaction_template_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TransactionTemplateItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction_template_item(transaction_template_item_id, transaction_template_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_template_item_id: Numeric value of the transactiontemplateitemID (required)
        :param TransactionTemplateItemItem transaction_template_item_item: TransactionTemplateItem to update (required)
        :return: list[TransactionTemplateItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_transaction_template_item_with_http_info(transaction_template_item_id, transaction_template_item_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_transaction_template_item_with_http_info(transaction_template_item_id, transaction_template_item_item, **kwargs)  # noqa: E501
            return data

    def update_transaction_template_item_with_http_info(self, transaction_template_item_id, transaction_template_item_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an TransactionTemplateItem in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_transaction_template_item_with_http_info(transaction_template_item_id, transaction_template_item_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int transaction_template_item_id: Numeric value of the transactiontemplateitemID (required)
        :param TransactionTemplateItemItem transaction_template_item_item: TransactionTemplateItem to update (required)
        :return: list[TransactionTemplateItemItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_template_item_id', 'transaction_template_item_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_transaction_template_item" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transaction_template_item_id' is set
        if ('transaction_template_item_id' not in params or
                params['transaction_template_item_id'] is None):
            raise ValueError("Missing the required parameter `transaction_template_item_id` when calling `update_transaction_template_item`")  # noqa: E501
        # verify the required parameter 'transaction_template_item_item' is set
        if ('transaction_template_item_item' not in params or
                params['transaction_template_item_item'] is None):
            raise ValueError("Missing the required parameter `transaction_template_item_item` when calling `update_transaction_template_item`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transaction_template_item_id' in params:
            path_params['TransactionTemplateItemID'] = params['transaction_template_item_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transaction_template_item_item' in params:
            body_params = params['transaction_template_item_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/TransactionTemplateItem/{TransactionTemplateItemID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TransactionTemplateItemItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_visitor(self, visitor_id, visitor_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Visitor in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_visitor(visitor_id, visitor_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int visitor_id: Numeric value of the visitorID (required)
        :param VisitorItem visitor_item: Visitor to update (required)
        :return: list[VisitorItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_visitor_with_http_info(visitor_id, visitor_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_visitor_with_http_info(visitor_id, visitor_item, **kwargs)  # noqa: E501
            return data

    def update_visitor_with_http_info(self, visitor_id, visitor_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Visitor in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_visitor_with_http_info(visitor_id, visitor_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int visitor_id: Numeric value of the visitorID (required)
        :param VisitorItem visitor_item: Visitor to update (required)
        :return: list[VisitorItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['visitor_id', 'visitor_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_visitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'visitor_id' is set
        if ('visitor_id' not in params or
                params['visitor_id'] is None):
            raise ValueError("Missing the required parameter `visitor_id` when calling `update_visitor`")  # noqa: E501
        # verify the required parameter 'visitor_item' is set
        if ('visitor_item' not in params or
                params['visitor_item'] is None):
            raise ValueError("Missing the required parameter `visitor_item` when calling `update_visitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'visitor_id' in params:
            path_params['VisitorID'] = params['visitor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'visitor_item' in params:
            body_params = params['visitor_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Visitor/{VisitorID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VisitorItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_visitor_type(self, visitor_type_id, visitor_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VisitorType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_visitor_type(visitor_type_id, visitor_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int visitor_type_id: Numeric value of the visitortypeID (required)
        :param VisitorTypeItem visitor_type_item: VisitorType to update (required)
        :return: list[VisitorTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_visitor_type_with_http_info(visitor_type_id, visitor_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_visitor_type_with_http_info(visitor_type_id, visitor_type_item, **kwargs)  # noqa: E501
            return data

    def update_visitor_type_with_http_info(self, visitor_type_id, visitor_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VisitorType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_visitor_type_with_http_info(visitor_type_id, visitor_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int visitor_type_id: Numeric value of the visitortypeID (required)
        :param VisitorTypeItem visitor_type_item: VisitorType to update (required)
        :return: list[VisitorTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['visitor_type_id', 'visitor_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_visitor_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'visitor_type_id' is set
        if ('visitor_type_id' not in params or
                params['visitor_type_id'] is None):
            raise ValueError("Missing the required parameter `visitor_type_id` when calling `update_visitor_type`")  # noqa: E501
        # verify the required parameter 'visitor_type_item' is set
        if ('visitor_type_item' not in params or
                params['visitor_type_item'] is None):
            raise ValueError("Missing the required parameter `visitor_type_item` when calling `update_visitor_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'visitor_type_id' in params:
            path_params['VisitorTypeID'] = params['visitor_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'visitor_type_item' in params:
            body_params = params['visitor_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/VisitorType/{VisitorTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VisitorTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_vm_data(self, vm_data_id, vm_data_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMData in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_data(vm_data_id, vm_data_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_data_id: Numeric value of the vmdataID (required)
        :param VMDataItem vm_data_item: VMData to update (required)
        :return: list[VMDataItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_vm_data_with_http_info(vm_data_id, vm_data_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_vm_data_with_http_info(vm_data_id, vm_data_item, **kwargs)  # noqa: E501
            return data

    def update_vm_data_with_http_info(self, vm_data_id, vm_data_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMData in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_data_with_http_info(vm_data_id, vm_data_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_data_id: Numeric value of the vmdataID (required)
        :param VMDataItem vm_data_item: VMData to update (required)
        :return: list[VMDataItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_data_id', 'vm_data_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vm_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'vm_data_id' is set
        if ('vm_data_id' not in params or
                params['vm_data_id'] is None):
            raise ValueError("Missing the required parameter `vm_data_id` when calling `update_vm_data`")  # noqa: E501
        # verify the required parameter 'vm_data_item' is set
        if ('vm_data_item' not in params or
                params['vm_data_item'] is None):
            raise ValueError("Missing the required parameter `vm_data_item` when calling `update_vm_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'vm_data_id' in params:
            path_params['VMDataID'] = params['vm_data_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'vm_data_item' in params:
            body_params = params['vm_data_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/VMData/{VMDataID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMDataItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_vm_group(self, vm_group_id, vm_group_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_group(vm_group_id, vm_group_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_group_id: Numeric value of the vmgroupID (required)
        :param VMGroupItem vm_group_item: VMGroup to update (required)
        :return: list[VMGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_vm_group_with_http_info(vm_group_id, vm_group_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_vm_group_with_http_info(vm_group_id, vm_group_item, **kwargs)  # noqa: E501
            return data

    def update_vm_group_with_http_info(self, vm_group_id, vm_group_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMGroup in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_group_with_http_info(vm_group_id, vm_group_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_group_id: Numeric value of the vmgroupID (required)
        :param VMGroupItem vm_group_item: VMGroup to update (required)
        :return: list[VMGroupItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_group_id', 'vm_group_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vm_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'vm_group_id' is set
        if ('vm_group_id' not in params or
                params['vm_group_id'] is None):
            raise ValueError("Missing the required parameter `vm_group_id` when calling `update_vm_group`")  # noqa: E501
        # verify the required parameter 'vm_group_item' is set
        if ('vm_group_item' not in params or
                params['vm_group_item'] is None):
            raise ValueError("Missing the required parameter `vm_group_item` when calling `update_vm_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'vm_group_id' in params:
            path_params['VMGroupID'] = params['vm_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'vm_group_item' in params:
            body_params = params['vm_group_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/VMGroup/{VMGroupID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMGroupItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_vm_group_extension(self, vm_group_extension_id, vm_group_extension_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMGroupExtension in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_group_extension(vm_group_extension_id, vm_group_extension_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_group_extension_id: Numeric value of the vmgroupextensionID (required)
        :param VMGroupExtensionItem vm_group_extension_item: VMGroupExtension to update (required)
        :return: list[VMGroupExtensionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_vm_group_extension_with_http_info(vm_group_extension_id, vm_group_extension_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_vm_group_extension_with_http_info(vm_group_extension_id, vm_group_extension_item, **kwargs)  # noqa: E501
            return data

    def update_vm_group_extension_with_http_info(self, vm_group_extension_id, vm_group_extension_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMGroupExtension in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_group_extension_with_http_info(vm_group_extension_id, vm_group_extension_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_group_extension_id: Numeric value of the vmgroupextensionID (required)
        :param VMGroupExtensionItem vm_group_extension_item: VMGroupExtension to update (required)
        :return: list[VMGroupExtensionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_group_extension_id', 'vm_group_extension_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vm_group_extension" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'vm_group_extension_id' is set
        if ('vm_group_extension_id' not in params or
                params['vm_group_extension_id'] is None):
            raise ValueError("Missing the required parameter `vm_group_extension_id` when calling `update_vm_group_extension`")  # noqa: E501
        # verify the required parameter 'vm_group_extension_item' is set
        if ('vm_group_extension_item' not in params or
                params['vm_group_extension_item'] is None):
            raise ValueError("Missing the required parameter `vm_group_extension_item` when calling `update_vm_group_extension`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'vm_group_extension_id' in params:
            path_params['VMGroupExtensionID'] = params['vm_group_extension_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'vm_group_extension_item' in params:
            body_params = params['vm_group_extension_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/VMGroupExtension/{VMGroupExtensionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMGroupExtensionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_vm_group_mail_box(self, vm_group_mail_box_id, vm_group_mail_box_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMGroupMailBox in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_group_mail_box(vm_group_mail_box_id, vm_group_mail_box_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_group_mail_box_id: Numeric value of the vmgroupmailboxID (required)
        :param VMGroupMailBoxItem vm_group_mail_box_item: VMGroupMailBox to update (required)
        :return: list[VMGroupMailBoxItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_vm_group_mail_box_with_http_info(vm_group_mail_box_id, vm_group_mail_box_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_vm_group_mail_box_with_http_info(vm_group_mail_box_id, vm_group_mail_box_item, **kwargs)  # noqa: E501
            return data

    def update_vm_group_mail_box_with_http_info(self, vm_group_mail_box_id, vm_group_mail_box_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMGroupMailBox in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_group_mail_box_with_http_info(vm_group_mail_box_id, vm_group_mail_box_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_group_mail_box_id: Numeric value of the vmgroupmailboxID (required)
        :param VMGroupMailBoxItem vm_group_mail_box_item: VMGroupMailBox to update (required)
        :return: list[VMGroupMailBoxItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_group_mail_box_id', 'vm_group_mail_box_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vm_group_mail_box" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'vm_group_mail_box_id' is set
        if ('vm_group_mail_box_id' not in params or
                params['vm_group_mail_box_id'] is None):
            raise ValueError("Missing the required parameter `vm_group_mail_box_id` when calling `update_vm_group_mail_box`")  # noqa: E501
        # verify the required parameter 'vm_group_mail_box_item' is set
        if ('vm_group_mail_box_item' not in params or
                params['vm_group_mail_box_item'] is None):
            raise ValueError("Missing the required parameter `vm_group_mail_box_item` when calling `update_vm_group_mail_box`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'vm_group_mail_box_id' in params:
            path_params['VMGroupMailBoxID'] = params['vm_group_mail_box_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'vm_group_mail_box_item' in params:
            body_params = params['vm_group_mail_box_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/VMGroupMailBox/{VMGroupMailBoxID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMGroupMailBoxItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_vm_group_message(self, vm_group_message_id, vm_group_message_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMGroupMessage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_group_message(vm_group_message_id, vm_group_message_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_group_message_id: Numeric value of the vmgroupmessageID (required)
        :param VMGroupMessageItem vm_group_message_item: VMGroupMessage to update (required)
        :return: list[VMGroupMessageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_vm_group_message_with_http_info(vm_group_message_id, vm_group_message_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_vm_group_message_with_http_info(vm_group_message_id, vm_group_message_item, **kwargs)  # noqa: E501
            return data

    def update_vm_group_message_with_http_info(self, vm_group_message_id, vm_group_message_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMGroupMessage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_group_message_with_http_info(vm_group_message_id, vm_group_message_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_group_message_id: Numeric value of the vmgroupmessageID (required)
        :param VMGroupMessageItem vm_group_message_item: VMGroupMessage to update (required)
        :return: list[VMGroupMessageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_group_message_id', 'vm_group_message_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vm_group_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'vm_group_message_id' is set
        if ('vm_group_message_id' not in params or
                params['vm_group_message_id'] is None):
            raise ValueError("Missing the required parameter `vm_group_message_id` when calling `update_vm_group_message`")  # noqa: E501
        # verify the required parameter 'vm_group_message_item' is set
        if ('vm_group_message_item' not in params or
                params['vm_group_message_item'] is None):
            raise ValueError("Missing the required parameter `vm_group_message_item` when calling `update_vm_group_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'vm_group_message_id' in params:
            path_params['VMGroupMessageID'] = params['vm_group_message_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'vm_group_message_item' in params:
            body_params = params['vm_group_message_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/VMGroupMessage/{VMGroupMessageID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMGroupMessageItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_vm_line_usage(self, vm_line_usage_id, vm_line_usage_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMLineUsage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_line_usage(vm_line_usage_id, vm_line_usage_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_line_usage_id: Numeric value of the vmlineusageID (required)
        :param VMLineUsageItem vm_line_usage_item: VMLineUsage to update (required)
        :return: list[VMLineUsageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_vm_line_usage_with_http_info(vm_line_usage_id, vm_line_usage_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_vm_line_usage_with_http_info(vm_line_usage_id, vm_line_usage_item, **kwargs)  # noqa: E501
            return data

    def update_vm_line_usage_with_http_info(self, vm_line_usage_id, vm_line_usage_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMLineUsage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_line_usage_with_http_info(vm_line_usage_id, vm_line_usage_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_line_usage_id: Numeric value of the vmlineusageID (required)
        :param VMLineUsageItem vm_line_usage_item: VMLineUsage to update (required)
        :return: list[VMLineUsageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_line_usage_id', 'vm_line_usage_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vm_line_usage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'vm_line_usage_id' is set
        if ('vm_line_usage_id' not in params or
                params['vm_line_usage_id'] is None):
            raise ValueError("Missing the required parameter `vm_line_usage_id` when calling `update_vm_line_usage`")  # noqa: E501
        # verify the required parameter 'vm_line_usage_item' is set
        if ('vm_line_usage_item' not in params or
                params['vm_line_usage_item'] is None):
            raise ValueError("Missing the required parameter `vm_line_usage_item` when calling `update_vm_line_usage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'vm_line_usage_id' in params:
            path_params['VMLineUsageID'] = params['vm_line_usage_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'vm_line_usage_item' in params:
            body_params = params['vm_line_usage_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/VMLineUsage/{VMLineUsageID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMLineUsageItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_vm_mail_box(self, vm_mail_box_id, vm_mail_box_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMMailBox in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_mail_box(vm_mail_box_id, vm_mail_box_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_mail_box_id: Numeric value of the vmmailboxID (required)
        :param VMMailBoxItem vm_mail_box_item: VMMailBox to update (required)
        :return: list[VMMailBoxItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_vm_mail_box_with_http_info(vm_mail_box_id, vm_mail_box_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_vm_mail_box_with_http_info(vm_mail_box_id, vm_mail_box_item, **kwargs)  # noqa: E501
            return data

    def update_vm_mail_box_with_http_info(self, vm_mail_box_id, vm_mail_box_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMMailBox in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_mail_box_with_http_info(vm_mail_box_id, vm_mail_box_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_mail_box_id: Numeric value of the vmmailboxID (required)
        :param VMMailBoxItem vm_mail_box_item: VMMailBox to update (required)
        :return: list[VMMailBoxItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_mail_box_id', 'vm_mail_box_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vm_mail_box" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'vm_mail_box_id' is set
        if ('vm_mail_box_id' not in params or
                params['vm_mail_box_id'] is None):
            raise ValueError("Missing the required parameter `vm_mail_box_id` when calling `update_vm_mail_box`")  # noqa: E501
        # verify the required parameter 'vm_mail_box_item' is set
        if ('vm_mail_box_item' not in params or
                params['vm_mail_box_item'] is None):
            raise ValueError("Missing the required parameter `vm_mail_box_item` when calling `update_vm_mail_box`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'vm_mail_box_id' in params:
            path_params['VMMailBoxID'] = params['vm_mail_box_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'vm_mail_box_item' in params:
            body_params = params['vm_mail_box_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/VMMailBox/{VMMailBoxID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMMailBoxItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_vm_mail_box_type(self, vm_mail_box_type_id, vm_mail_box_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMMailBoxType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_mail_box_type(vm_mail_box_type_id, vm_mail_box_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_mail_box_type_id: Numeric value of the vmmailboxtypeID (required)
        :param VMMailBoxTypeItem vm_mail_box_type_item: VMMailBoxType to update (required)
        :return: list[VMMailBoxTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_vm_mail_box_type_with_http_info(vm_mail_box_type_id, vm_mail_box_type_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_vm_mail_box_type_with_http_info(vm_mail_box_type_id, vm_mail_box_type_item, **kwargs)  # noqa: E501
            return data

    def update_vm_mail_box_type_with_http_info(self, vm_mail_box_type_id, vm_mail_box_type_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMMailBoxType in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_mail_box_type_with_http_info(vm_mail_box_type_id, vm_mail_box_type_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_mail_box_type_id: Numeric value of the vmmailboxtypeID (required)
        :param VMMailBoxTypeItem vm_mail_box_type_item: VMMailBoxType to update (required)
        :return: list[VMMailBoxTypeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_mail_box_type_id', 'vm_mail_box_type_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vm_mail_box_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'vm_mail_box_type_id' is set
        if ('vm_mail_box_type_id' not in params or
                params['vm_mail_box_type_id'] is None):
            raise ValueError("Missing the required parameter `vm_mail_box_type_id` when calling `update_vm_mail_box_type`")  # noqa: E501
        # verify the required parameter 'vm_mail_box_type_item' is set
        if ('vm_mail_box_type_item' not in params or
                params['vm_mail_box_type_item'] is None):
            raise ValueError("Missing the required parameter `vm_mail_box_type_item` when calling `update_vm_mail_box_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'vm_mail_box_type_id' in params:
            path_params['VMMailBoxTypeID'] = params['vm_mail_box_type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'vm_mail_box_type_item' in params:
            body_params = params['vm_mail_box_type_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/VMMailBoxType/{VMMailBoxTypeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMMailBoxTypeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_vm_message(self, vm_message_id, vm_message_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMMessage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_message(vm_message_id, vm_message_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_message_id: Numeric value of the vmmessageID (required)
        :param VMMessageItem vm_message_item: VMMessage to update (required)
        :return: list[VMMessageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_vm_message_with_http_info(vm_message_id, vm_message_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_vm_message_with_http_info(vm_message_id, vm_message_item, **kwargs)  # noqa: E501
            return data

    def update_vm_message_with_http_info(self, vm_message_id, vm_message_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMMessage in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_message_with_http_info(vm_message_id, vm_message_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_message_id: Numeric value of the vmmessageID (required)
        :param VMMessageItem vm_message_item: VMMessage to update (required)
        :return: list[VMMessageItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_message_id', 'vm_message_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vm_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'vm_message_id' is set
        if ('vm_message_id' not in params or
                params['vm_message_id'] is None):
            raise ValueError("Missing the required parameter `vm_message_id` when calling `update_vm_message`")  # noqa: E501
        # verify the required parameter 'vm_message_item' is set
        if ('vm_message_item' not in params or
                params['vm_message_item'] is None):
            raise ValueError("Missing the required parameter `vm_message_item` when calling `update_vm_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'vm_message_id' in params:
            path_params['VMMessageID'] = params['vm_message_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'vm_message_item' in params:
            body_params = params['vm_message_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/VMMessage/{VMMessageID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMMessageItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_vm_message_lamp(self, vm_message_lamp_id, vm_message_lamp_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMMessageLamp in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_message_lamp(vm_message_lamp_id, vm_message_lamp_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_message_lamp_id: Numeric value of the vmmessagelampID (required)
        :param VMMessageLampItem vm_message_lamp_item: VMMessageLamp to update (required)
        :return: list[VMMessageLampItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_vm_message_lamp_with_http_info(vm_message_lamp_id, vm_message_lamp_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_vm_message_lamp_with_http_info(vm_message_lamp_id, vm_message_lamp_item, **kwargs)  # noqa: E501
            return data

    def update_vm_message_lamp_with_http_info(self, vm_message_lamp_id, vm_message_lamp_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMMessageLamp in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vm_message_lamp_with_http_info(vm_message_lamp_id, vm_message_lamp_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vm_message_lamp_id: Numeric value of the vmmessagelampID (required)
        :param VMMessageLampItem vm_message_lamp_item: VMMessageLamp to update (required)
        :return: list[VMMessageLampItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vm_message_lamp_id', 'vm_message_lamp_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vm_message_lamp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'vm_message_lamp_id' is set
        if ('vm_message_lamp_id' not in params or
                params['vm_message_lamp_id'] is None):
            raise ValueError("Missing the required parameter `vm_message_lamp_id` when calling `update_vm_message_lamp`")  # noqa: E501
        # verify the required parameter 'vm_message_lamp_item' is set
        if ('vm_message_lamp_item' not in params or
                params['vm_message_lamp_item'] is None):
            raise ValueError("Missing the required parameter `vm_message_lamp_item` when calling `update_vm_message_lamp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'vm_message_lamp_id' in params:
            path_params['VMMessageLampID'] = params['vm_message_lamp_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'vm_message_lamp_item' in params:
            body_params = params['vm_message_lamp_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/VMMessageLamp/{VMMessageLampID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMMessageLampItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_vmmci(self, vmmciid, vmmci_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMMCI in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vmmci(vmmciid, vmmci_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vmmciid: Numeric value of the vmmciID (required)
        :param VMMCIItem vmmci_item: VMMCI to update (required)
        :return: list[VMMCIItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_vmmci_with_http_info(vmmciid, vmmci_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_vmmci_with_http_info(vmmciid, vmmci_item, **kwargs)  # noqa: E501
            return data

    def update_vmmci_with_http_info(self, vmmciid, vmmci_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an VMMCI in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_vmmci_with_http_info(vmmciid, vmmci_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int vmmciid: Numeric value of the vmmciID (required)
        :param VMMCIItem vmmci_item: VMMCI to update (required)
        :return: list[VMMCIItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vmmciid', 'vmmci_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vmmci" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'vmmciid' is set
        if ('vmmciid' not in params or
                params['vmmciid'] is None):
            raise ValueError("Missing the required parameter `vmmciid` when calling `update_vmmci`")  # noqa: E501
        # verify the required parameter 'vmmci_item' is set
        if ('vmmci_item' not in params or
                params['vmmci_item'] is None):
            raise ValueError("Missing the required parameter `vmmci_item` when calling `update_vmmci`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'vmmciid' in params:
            path_params['VMMCIID'] = params['vmmciid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'vmmci_item' in params:
            body_params = params['vmmci_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/VMMCI/{VMMCIID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[VMMCIItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_wait_list(self, wait_list_id, wait_list_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WaitList in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_wait_list(wait_list_id, wait_list_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_id: Numeric value of the waitlistID (required)
        :param WaitListItem wait_list_item: WaitList to update (required)
        :return: list[WaitListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_wait_list_with_http_info(wait_list_id, wait_list_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_wait_list_with_http_info(wait_list_id, wait_list_item, **kwargs)  # noqa: E501
            return data

    def update_wait_list_with_http_info(self, wait_list_id, wait_list_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WaitList in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_wait_list_with_http_info(wait_list_id, wait_list_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_id: Numeric value of the waitlistID (required)
        :param WaitListItem wait_list_item: WaitList to update (required)
        :return: list[WaitListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wait_list_id', 'wait_list_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_wait_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'wait_list_id' is set
        if ('wait_list_id' not in params or
                params['wait_list_id'] is None):
            raise ValueError("Missing the required parameter `wait_list_id` when calling `update_wait_list`")  # noqa: E501
        # verify the required parameter 'wait_list_item' is set
        if ('wait_list_item' not in params or
                params['wait_list_item'] is None):
            raise ValueError("Missing the required parameter `wait_list_item` when calling `update_wait_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'wait_list_id' in params:
            path_params['WaitListID'] = params['wait_list_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'wait_list_item' in params:
            body_params = params['wait_list_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WaitList/{WaitListID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WaitListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_wait_list_classification(self, wait_list_classification_id, wait_list_classification_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WaitListClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_wait_list_classification(wait_list_classification_id, wait_list_classification_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_classification_id: Numeric value of the waitlistclassificationID (required)
        :param WaitListClassificationItem wait_list_classification_item: WaitListClassification to update (required)
        :return: list[WaitListClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_wait_list_classification_with_http_info(wait_list_classification_id, wait_list_classification_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_wait_list_classification_with_http_info(wait_list_classification_id, wait_list_classification_item, **kwargs)  # noqa: E501
            return data

    def update_wait_list_classification_with_http_info(self, wait_list_classification_id, wait_list_classification_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WaitListClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_wait_list_classification_with_http_info(wait_list_classification_id, wait_list_classification_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_classification_id: Numeric value of the waitlistclassificationID (required)
        :param WaitListClassificationItem wait_list_classification_item: WaitListClassification to update (required)
        :return: list[WaitListClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wait_list_classification_id', 'wait_list_classification_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_wait_list_classification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'wait_list_classification_id' is set
        if ('wait_list_classification_id' not in params or
                params['wait_list_classification_id'] is None):
            raise ValueError("Missing the required parameter `wait_list_classification_id` when calling `update_wait_list_classification`")  # noqa: E501
        # verify the required parameter 'wait_list_classification_item' is set
        if ('wait_list_classification_item' not in params or
                params['wait_list_classification_item'] is None):
            raise ValueError("Missing the required parameter `wait_list_classification_item` when calling `update_wait_list_classification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'wait_list_classification_id' in params:
            path_params['WaitListClassificationID'] = params['wait_list_classification_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'wait_list_classification_item' in params:
            body_params = params['wait_list_classification_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WaitListClassification/{WaitListClassificationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WaitListClassificationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_wait_list_entry_application(self, wait_list_entry_application_id, wait_list_entry_application_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WaitListEntryApplication in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_wait_list_entry_application(wait_list_entry_application_id, wait_list_entry_application_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_entry_application_id: Numeric value of the waitlistentryapplicationID (required)
        :param WaitListEntryApplicationItem wait_list_entry_application_item: WaitListEntryApplication to update (required)
        :return: list[WaitListEntryApplicationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_wait_list_entry_application_with_http_info(wait_list_entry_application_id, wait_list_entry_application_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_wait_list_entry_application_with_http_info(wait_list_entry_application_id, wait_list_entry_application_item, **kwargs)  # noqa: E501
            return data

    def update_wait_list_entry_application_with_http_info(self, wait_list_entry_application_id, wait_list_entry_application_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WaitListEntryApplication in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_wait_list_entry_application_with_http_info(wait_list_entry_application_id, wait_list_entry_application_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_entry_application_id: Numeric value of the waitlistentryapplicationID (required)
        :param WaitListEntryApplicationItem wait_list_entry_application_item: WaitListEntryApplication to update (required)
        :return: list[WaitListEntryApplicationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wait_list_entry_application_id', 'wait_list_entry_application_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_wait_list_entry_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'wait_list_entry_application_id' is set
        if ('wait_list_entry_application_id' not in params or
                params['wait_list_entry_application_id'] is None):
            raise ValueError("Missing the required parameter `wait_list_entry_application_id` when calling `update_wait_list_entry_application`")  # noqa: E501
        # verify the required parameter 'wait_list_entry_application_item' is set
        if ('wait_list_entry_application_item' not in params or
                params['wait_list_entry_application_item'] is None):
            raise ValueError("Missing the required parameter `wait_list_entry_application_item` when calling `update_wait_list_entry_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'wait_list_entry_application_id' in params:
            path_params['WaitListEntryApplicationID'] = params['wait_list_entry_application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'wait_list_entry_application_item' in params:
            body_params = params['wait_list_entry_application_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WaitListEntryApplication/{WaitListEntryApplicationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WaitListEntryApplicationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_wait_list_profile(self, wait_list_profile_id, wait_list_profile_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WaitListProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_wait_list_profile(wait_list_profile_id, wait_list_profile_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_profile_id: Numeric value of the waitlistprofileID (required)
        :param WaitListProfileItem wait_list_profile_item: WaitListProfile to update (required)
        :return: list[WaitListProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_wait_list_profile_with_http_info(wait_list_profile_id, wait_list_profile_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_wait_list_profile_with_http_info(wait_list_profile_id, wait_list_profile_item, **kwargs)  # noqa: E501
            return data

    def update_wait_list_profile_with_http_info(self, wait_list_profile_id, wait_list_profile_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WaitListProfile in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_wait_list_profile_with_http_info(wait_list_profile_id, wait_list_profile_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_profile_id: Numeric value of the waitlistprofileID (required)
        :param WaitListProfileItem wait_list_profile_item: WaitListProfile to update (required)
        :return: list[WaitListProfileItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wait_list_profile_id', 'wait_list_profile_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_wait_list_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'wait_list_profile_id' is set
        if ('wait_list_profile_id' not in params or
                params['wait_list_profile_id'] is None):
            raise ValueError("Missing the required parameter `wait_list_profile_id` when calling `update_wait_list_profile`")  # noqa: E501
        # verify the required parameter 'wait_list_profile_item' is set
        if ('wait_list_profile_item' not in params or
                params['wait_list_profile_item'] is None):
            raise ValueError("Missing the required parameter `wait_list_profile_item` when calling `update_wait_list_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'wait_list_profile_id' in params:
            path_params['WaitListProfileID'] = params['wait_list_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'wait_list_profile_item' in params:
            body_params = params['wait_list_profile_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WaitListProfile/{WaitListProfileID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WaitListProfileItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_wait_list_room_space(self, wait_list_room_space_id, wait_list_room_space_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WaitListRoomSpace in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_wait_list_room_space(wait_list_room_space_id, wait_list_room_space_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_room_space_id: Numeric value of the waitlistroomspaceID (required)
        :param WaitListRoomSpaceItem wait_list_room_space_item: WaitListRoomSpace to update (required)
        :return: list[WaitListRoomSpaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_wait_list_room_space_with_http_info(wait_list_room_space_id, wait_list_room_space_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_wait_list_room_space_with_http_info(wait_list_room_space_id, wait_list_room_space_item, **kwargs)  # noqa: E501
            return data

    def update_wait_list_room_space_with_http_info(self, wait_list_room_space_id, wait_list_room_space_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WaitListRoomSpace in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_wait_list_room_space_with_http_info(wait_list_room_space_id, wait_list_room_space_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int wait_list_room_space_id: Numeric value of the waitlistroomspaceID (required)
        :param WaitListRoomSpaceItem wait_list_room_space_item: WaitListRoomSpace to update (required)
        :return: list[WaitListRoomSpaceItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wait_list_room_space_id', 'wait_list_room_space_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_wait_list_room_space" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'wait_list_room_space_id' is set
        if ('wait_list_room_space_id' not in params or
                params['wait_list_room_space_id'] is None):
            raise ValueError("Missing the required parameter `wait_list_room_space_id` when calling `update_wait_list_room_space`")  # noqa: E501
        # verify the required parameter 'wait_list_room_space_item' is set
        if ('wait_list_room_space_item' not in params or
                params['wait_list_room_space_item'] is None):
            raise ValueError("Missing the required parameter `wait_list_room_space_item` when calling `update_wait_list_room_space`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'wait_list_room_space_id' in params:
            path_params['WaitListRoomSpaceID'] = params['wait_list_room_space_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'wait_list_room_space_item' in params:
            body_params = params['wait_list_room_space_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WaitListRoomSpace/{WaitListRoomSpaceID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WaitListRoomSpaceItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_web_block(self, web_block_id, web_block_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebBlock in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_block(web_block_id, web_block_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_block_id: Numeric value of the webblockID (required)
        :param WebBlockItem web_block_item: WebBlock to update (required)
        :return: list[WebBlockItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_web_block_with_http_info(web_block_id, web_block_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_web_block_with_http_info(web_block_id, web_block_item, **kwargs)  # noqa: E501
            return data

    def update_web_block_with_http_info(self, web_block_id, web_block_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebBlock in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_block_with_http_info(web_block_id, web_block_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_block_id: Numeric value of the webblockID (required)
        :param WebBlockItem web_block_item: WebBlock to update (required)
        :return: list[WebBlockItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_block_id', 'web_block_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_web_block" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'web_block_id' is set
        if ('web_block_id' not in params or
                params['web_block_id'] is None):
            raise ValueError("Missing the required parameter `web_block_id` when calling `update_web_block`")  # noqa: E501
        # verify the required parameter 'web_block_item' is set
        if ('web_block_item' not in params or
                params['web_block_item'] is None):
            raise ValueError("Missing the required parameter `web_block_item` when calling `update_web_block`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'web_block_id' in params:
            path_params['WebBlockID'] = params['web_block_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_block_item' in params:
            body_params = params['web_block_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WebBlock/{WebBlockID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebBlockItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_web_control(self, web_control_id, web_control_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebControl in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_control(web_control_id, web_control_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_control_id: Numeric value of the webcontrolID (required)
        :param WebControlItem web_control_item: WebControl to update (required)
        :return: list[WebControlItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_web_control_with_http_info(web_control_id, web_control_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_web_control_with_http_info(web_control_id, web_control_item, **kwargs)  # noqa: E501
            return data

    def update_web_control_with_http_info(self, web_control_id, web_control_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebControl in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_control_with_http_info(web_control_id, web_control_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_control_id: Numeric value of the webcontrolID (required)
        :param WebControlItem web_control_item: WebControl to update (required)
        :return: list[WebControlItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_control_id', 'web_control_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_web_control" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'web_control_id' is set
        if ('web_control_id' not in params or
                params['web_control_id'] is None):
            raise ValueError("Missing the required parameter `web_control_id` when calling `update_web_control`")  # noqa: E501
        # verify the required parameter 'web_control_item' is set
        if ('web_control_item' not in params or
                params['web_control_item'] is None):
            raise ValueError("Missing the required parameter `web_control_item` when calling `update_web_control`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'web_control_id' in params:
            path_params['WebControlID'] = params['web_control_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_control_item' in params:
            body_params = params['web_control_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WebControl/{WebControlID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebControlItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_web_email_text(self, web_email_text_id, web_email_text_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebEmailText in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_email_text(web_email_text_id, web_email_text_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_email_text_id: Numeric value of the webemailtextID (required)
        :param WebEmailTextItem web_email_text_item: WebEmailText to update (required)
        :return: list[WebEmailTextItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_web_email_text_with_http_info(web_email_text_id, web_email_text_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_web_email_text_with_http_info(web_email_text_id, web_email_text_item, **kwargs)  # noqa: E501
            return data

    def update_web_email_text_with_http_info(self, web_email_text_id, web_email_text_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebEmailText in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_email_text_with_http_info(web_email_text_id, web_email_text_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_email_text_id: Numeric value of the webemailtextID (required)
        :param WebEmailTextItem web_email_text_item: WebEmailText to update (required)
        :return: list[WebEmailTextItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_email_text_id', 'web_email_text_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_web_email_text" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'web_email_text_id' is set
        if ('web_email_text_id' not in params or
                params['web_email_text_id'] is None):
            raise ValueError("Missing the required parameter `web_email_text_id` when calling `update_web_email_text`")  # noqa: E501
        # verify the required parameter 'web_email_text_item' is set
        if ('web_email_text_item' not in params or
                params['web_email_text_item'] is None):
            raise ValueError("Missing the required parameter `web_email_text_item` when calling `update_web_email_text`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'web_email_text_id' in params:
            path_params['WebEmailTextID'] = params['web_email_text_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_email_text_item' in params:
            body_params = params['web_email_text_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WebEmailText/{WebEmailTextID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebEmailTextItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_web_field(self, web_field_id, web_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_field(web_field_id, web_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_field_id: Numeric value of the webfieldID (required)
        :param WebFieldItem web_field_item: WebField to update (required)
        :return: list[WebFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_web_field_with_http_info(web_field_id, web_field_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_web_field_with_http_info(web_field_id, web_field_item, **kwargs)  # noqa: E501
            return data

    def update_web_field_with_http_info(self, web_field_id, web_field_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebField in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_field_with_http_info(web_field_id, web_field_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_field_id: Numeric value of the webfieldID (required)
        :param WebFieldItem web_field_item: WebField to update (required)
        :return: list[WebFieldItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_field_id', 'web_field_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_web_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'web_field_id' is set
        if ('web_field_id' not in params or
                params['web_field_id'] is None):
            raise ValueError("Missing the required parameter `web_field_id` when calling `update_web_field`")  # noqa: E501
        # verify the required parameter 'web_field_item' is set
        if ('web_field_item' not in params or
                params['web_field_item'] is None):
            raise ValueError("Missing the required parameter `web_field_item` when calling `update_web_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'web_field_id' in params:
            path_params['WebFieldID'] = params['web_field_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_field_item' in params:
            body_params = params['web_field_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WebField/{WebFieldID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebFieldItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_web_log(self, web_log_id, web_log_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebLog in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_log(web_log_id, web_log_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_log_id: Numeric value of the weblogID (required)
        :param WebLogItem web_log_item: WebLog to update (required)
        :return: list[WebLogItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_web_log_with_http_info(web_log_id, web_log_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_web_log_with_http_info(web_log_id, web_log_item, **kwargs)  # noqa: E501
            return data

    def update_web_log_with_http_info(self, web_log_id, web_log_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebLog in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_log_with_http_info(web_log_id, web_log_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_log_id: Numeric value of the weblogID (required)
        :param WebLogItem web_log_item: WebLog to update (required)
        :return: list[WebLogItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_log_id', 'web_log_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_web_log" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'web_log_id' is set
        if ('web_log_id' not in params or
                params['web_log_id'] is None):
            raise ValueError("Missing the required parameter `web_log_id` when calling `update_web_log`")  # noqa: E501
        # verify the required parameter 'web_log_item' is set
        if ('web_log_item' not in params or
                params['web_log_item'] is None):
            raise ValueError("Missing the required parameter `web_log_item` when calling `update_web_log`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'web_log_id' in params:
            path_params['WebLogID'] = params['web_log_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_log_item' in params:
            body_params = params['web_log_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WebLog/{WebLogID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebLogItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_web_menu(self, web_menu_id, web_menu_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebMenu in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_menu(web_menu_id, web_menu_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_menu_id: Numeric value of the webmenuID (required)
        :param WebMenuItem web_menu_item: WebMenu to update (required)
        :return: list[WebMenuItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_web_menu_with_http_info(web_menu_id, web_menu_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_web_menu_with_http_info(web_menu_id, web_menu_item, **kwargs)  # noqa: E501
            return data

    def update_web_menu_with_http_info(self, web_menu_id, web_menu_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebMenu in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_menu_with_http_info(web_menu_id, web_menu_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_menu_id: Numeric value of the webmenuID (required)
        :param WebMenuItem web_menu_item: WebMenu to update (required)
        :return: list[WebMenuItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_menu_id', 'web_menu_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_web_menu" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'web_menu_id' is set
        if ('web_menu_id' not in params or
                params['web_menu_id'] is None):
            raise ValueError("Missing the required parameter `web_menu_id` when calling `update_web_menu`")  # noqa: E501
        # verify the required parameter 'web_menu_item' is set
        if ('web_menu_item' not in params or
                params['web_menu_item'] is None):
            raise ValueError("Missing the required parameter `web_menu_item` when calling `update_web_menu`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'web_menu_id' in params:
            path_params['WebMenuID'] = params['web_menu_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_menu_item' in params:
            body_params = params['web_menu_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WebMenu/{WebMenuID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebMenuItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_web_menu_classification(self, web_menu_classification_id, web_menu_classification_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebMenuClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_menu_classification(web_menu_classification_id, web_menu_classification_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_menu_classification_id: Numeric value of the webmenuclassificationID (required)
        :param WebMenuClassificationItem web_menu_classification_item: WebMenuClassification to update (required)
        :return: list[WebMenuClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_web_menu_classification_with_http_info(web_menu_classification_id, web_menu_classification_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_web_menu_classification_with_http_info(web_menu_classification_id, web_menu_classification_item, **kwargs)  # noqa: E501
            return data

    def update_web_menu_classification_with_http_info(self, web_menu_classification_id, web_menu_classification_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebMenuClassification in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_menu_classification_with_http_info(web_menu_classification_id, web_menu_classification_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_menu_classification_id: Numeric value of the webmenuclassificationID (required)
        :param WebMenuClassificationItem web_menu_classification_item: WebMenuClassification to update (required)
        :return: list[WebMenuClassificationItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_menu_classification_id', 'web_menu_classification_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_web_menu_classification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'web_menu_classification_id' is set
        if ('web_menu_classification_id' not in params or
                params['web_menu_classification_id'] is None):
            raise ValueError("Missing the required parameter `web_menu_classification_id` when calling `update_web_menu_classification`")  # noqa: E501
        # verify the required parameter 'web_menu_classification_item' is set
        if ('web_menu_classification_item' not in params or
                params['web_menu_classification_item'] is None):
            raise ValueError("Missing the required parameter `web_menu_classification_item` when calling `update_web_menu_classification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'web_menu_classification_id' in params:
            path_params['WebMenuClassificationID'] = params['web_menu_classification_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_menu_classification_item' in params:
            body_params = params['web_menu_classification_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WebMenuClassification/{WebMenuClassificationID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebMenuClassificationItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_web_module(self, web_module_id, web_module_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebModule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_module(web_module_id, web_module_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_module_id: Numeric value of the webmoduleID (required)
        :param WebModuleItem web_module_item: WebModule to update (required)
        :return: list[WebModuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_web_module_with_http_info(web_module_id, web_module_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_web_module_with_http_info(web_module_id, web_module_item, **kwargs)  # noqa: E501
            return data

    def update_web_module_with_http_info(self, web_module_id, web_module_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebModule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_module_with_http_info(web_module_id, web_module_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_module_id: Numeric value of the webmoduleID (required)
        :param WebModuleItem web_module_item: WebModule to update (required)
        :return: list[WebModuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_module_id', 'web_module_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_web_module" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'web_module_id' is set
        if ('web_module_id' not in params or
                params['web_module_id'] is None):
            raise ValueError("Missing the required parameter `web_module_id` when calling `update_web_module`")  # noqa: E501
        # verify the required parameter 'web_module_item' is set
        if ('web_module_item' not in params or
                params['web_module_item'] is None):
            raise ValueError("Missing the required parameter `web_module_item` when calling `update_web_module`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'web_module_id' in params:
            path_params['WebModuleID'] = params['web_module_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_module_item' in params:
            body_params = params['web_module_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WebModule/{WebModuleID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebModuleItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_web_payment(self, web_payment_id, web_payment_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebPayment in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_payment(web_payment_id, web_payment_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_payment_id: Numeric value of the webpaymentID (required)
        :param WebPaymentItem web_payment_item: WebPayment to update (required)
        :return: list[WebPaymentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_web_payment_with_http_info(web_payment_id, web_payment_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_web_payment_with_http_info(web_payment_id, web_payment_item, **kwargs)  # noqa: E501
            return data

    def update_web_payment_with_http_info(self, web_payment_id, web_payment_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebPayment in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_payment_with_http_info(web_payment_id, web_payment_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_payment_id: Numeric value of the webpaymentID (required)
        :param WebPaymentItem web_payment_item: WebPayment to update (required)
        :return: list[WebPaymentItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_payment_id', 'web_payment_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_web_payment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'web_payment_id' is set
        if ('web_payment_id' not in params or
                params['web_payment_id'] is None):
            raise ValueError("Missing the required parameter `web_payment_id` when calling `update_web_payment`")  # noqa: E501
        # verify the required parameter 'web_payment_item' is set
        if ('web_payment_item' not in params or
                params['web_payment_item'] is None):
            raise ValueError("Missing the required parameter `web_payment_item` when calling `update_web_payment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'web_payment_id' in params:
            path_params['WebPaymentID'] = params['web_payment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_payment_item' in params:
            body_params = params['web_payment_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WebPayment/{WebPaymentID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebPaymentItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_web_rule(self, web_rule_id, web_rule_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebRule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_rule(web_rule_id, web_rule_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_rule_id: Numeric value of the webruleID (required)
        :param WebRuleItem web_rule_item: WebRule to update (required)
        :return: list[WebRuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_web_rule_with_http_info(web_rule_id, web_rule_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_web_rule_with_http_info(web_rule_id, web_rule_item, **kwargs)  # noqa: E501
            return data

    def update_web_rule_with_http_info(self, web_rule_id, web_rule_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebRule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_rule_with_http_info(web_rule_id, web_rule_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_rule_id: Numeric value of the webruleID (required)
        :param WebRuleItem web_rule_item: WebRule to update (required)
        :return: list[WebRuleItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_rule_id', 'web_rule_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_web_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'web_rule_id' is set
        if ('web_rule_id' not in params or
                params['web_rule_id'] is None):
            raise ValueError("Missing the required parameter `web_rule_id` when calling `update_web_rule`")  # noqa: E501
        # verify the required parameter 'web_rule_item' is set
        if ('web_rule_item' not in params or
                params['web_rule_item'] is None):
            raise ValueError("Missing the required parameter `web_rule_item` when calling `update_web_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'web_rule_id' in params:
            path_params['WebRuleID'] = params['web_rule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_rule_item' in params:
            body_params = params['web_rule_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WebRule/{WebRuleID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebRuleItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_web_rule_link(self, web_rule_link_id, web_rule_link_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebRuleLink in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_rule_link(web_rule_link_id, web_rule_link_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_rule_link_id: Numeric value of the webrulelinkID (required)
        :param WebRuleLinkItem web_rule_link_item: WebRuleLink to update (required)
        :return: list[WebRuleLinkItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_web_rule_link_with_http_info(web_rule_link_id, web_rule_link_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_web_rule_link_with_http_info(web_rule_link_id, web_rule_link_item, **kwargs)  # noqa: E501
            return data

    def update_web_rule_link_with_http_info(self, web_rule_link_id, web_rule_link_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebRuleLink in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_rule_link_with_http_info(web_rule_link_id, web_rule_link_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_rule_link_id: Numeric value of the webrulelinkID (required)
        :param WebRuleLinkItem web_rule_link_item: WebRuleLink to update (required)
        :return: list[WebRuleLinkItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_rule_link_id', 'web_rule_link_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_web_rule_link" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'web_rule_link_id' is set
        if ('web_rule_link_id' not in params or
                params['web_rule_link_id'] is None):
            raise ValueError("Missing the required parameter `web_rule_link_id` when calling `update_web_rule_link`")  # noqa: E501
        # verify the required parameter 'web_rule_link_item' is set
        if ('web_rule_link_item' not in params or
                params['web_rule_link_item'] is None):
            raise ValueError("Missing the required parameter `web_rule_link_item` when calling `update_web_rule_link`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'web_rule_link_id' in params:
            path_params['WebRuleLinkID'] = params['web_rule_link_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_rule_link_item' in params:
            body_params = params['web_rule_link_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WebRuleLink/{WebRuleLinkID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebRuleLinkItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_web_section(self, web_section_id, web_section_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebSection in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_section(web_section_id, web_section_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_section_id: Numeric value of the websectionID (required)
        :param WebSectionItem web_section_item: WebSection to update (required)
        :return: list[WebSectionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_web_section_with_http_info(web_section_id, web_section_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_web_section_with_http_info(web_section_id, web_section_item, **kwargs)  # noqa: E501
            return data

    def update_web_section_with_http_info(self, web_section_id, web_section_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebSection in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_section_with_http_info(web_section_id, web_section_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_section_id: Numeric value of the websectionID (required)
        :param WebSectionItem web_section_item: WebSection to update (required)
        :return: list[WebSectionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_section_id', 'web_section_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_web_section" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'web_section_id' is set
        if ('web_section_id' not in params or
                params['web_section_id'] is None):
            raise ValueError("Missing the required parameter `web_section_id` when calling `update_web_section`")  # noqa: E501
        # verify the required parameter 'web_section_item' is set
        if ('web_section_item' not in params or
                params['web_section_item'] is None):
            raise ValueError("Missing the required parameter `web_section_item` when calling `update_web_section`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'web_section_id' in params:
            path_params['WebSectionID'] = params['web_section_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_section_item' in params:
            body_params = params['web_section_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WebSection/{WebSectionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebSectionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_web_section_text_block(self, web_section_text_block_id, web_section_text_block_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebSectionTextBlock in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_section_text_block(web_section_text_block_id, web_section_text_block_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_section_text_block_id: Numeric value of the websectiontextblockID (required)
        :param WebSectionTextBlockItem web_section_text_block_item: WebSectionTextBlock to update (required)
        :return: list[WebSectionTextBlockItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_web_section_text_block_with_http_info(web_section_text_block_id, web_section_text_block_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_web_section_text_block_with_http_info(web_section_text_block_id, web_section_text_block_item, **kwargs)  # noqa: E501
            return data

    def update_web_section_text_block_with_http_info(self, web_section_text_block_id, web_section_text_block_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebSectionTextBlock in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_section_text_block_with_http_info(web_section_text_block_id, web_section_text_block_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_section_text_block_id: Numeric value of the websectiontextblockID (required)
        :param WebSectionTextBlockItem web_section_text_block_item: WebSectionTextBlock to update (required)
        :return: list[WebSectionTextBlockItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_section_text_block_id', 'web_section_text_block_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_web_section_text_block" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'web_section_text_block_id' is set
        if ('web_section_text_block_id' not in params or
                params['web_section_text_block_id'] is None):
            raise ValueError("Missing the required parameter `web_section_text_block_id` when calling `update_web_section_text_block`")  # noqa: E501
        # verify the required parameter 'web_section_text_block_item' is set
        if ('web_section_text_block_item' not in params or
                params['web_section_text_block_item'] is None):
            raise ValueError("Missing the required parameter `web_section_text_block_item` when calling `update_web_section_text_block`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'web_section_text_block_id' in params:
            path_params['WebSectionTextBlockID'] = params['web_section_text_block_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_section_text_block_item' in params:
            body_params = params['web_section_text_block_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WebSectionTextBlock/{WebSectionTextBlockID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebSectionTextBlockItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_web_setting(self, web_setting_id, web_setting_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebSetting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_setting(web_setting_id, web_setting_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_setting_id: Numeric value of the websettingID (required)
        :param WebSettingItem web_setting_item: WebSetting to update (required)
        :return: list[WebSettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_web_setting_with_http_info(web_setting_id, web_setting_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_web_setting_with_http_info(web_setting_id, web_setting_item, **kwargs)  # noqa: E501
            return data

    def update_web_setting_with_http_info(self, web_setting_id, web_setting_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebSetting in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_setting_with_http_info(web_setting_id, web_setting_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_setting_id: Numeric value of the websettingID (required)
        :param WebSettingItem web_setting_item: WebSetting to update (required)
        :return: list[WebSettingItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_setting_id', 'web_setting_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_web_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'web_setting_id' is set
        if ('web_setting_id' not in params or
                params['web_setting_id'] is None):
            raise ValueError("Missing the required parameter `web_setting_id` when calling `update_web_setting`")  # noqa: E501
        # verify the required parameter 'web_setting_item' is set
        if ('web_setting_item' not in params or
                params['web_setting_item'] is None):
            raise ValueError("Missing the required parameter `web_setting_item` when calling `update_web_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'web_setting_id' in params:
            path_params['WebSettingID'] = params['web_setting_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_setting_item' in params:
            body_params = params['web_setting_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WebSetting/{WebSettingID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebSettingItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_web_site(self, web_site_id, web_site_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebSite in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_site(web_site_id, web_site_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_site_id: Numeric value of the websiteID (required)
        :param WebSiteItem web_site_item: WebSite to update (required)
        :return: list[WebSiteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_web_site_with_http_info(web_site_id, web_site_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_web_site_with_http_info(web_site_id, web_site_item, **kwargs)  # noqa: E501
            return data

    def update_web_site_with_http_info(self, web_site_id, web_site_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebSite in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_site_with_http_info(web_site_id, web_site_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_site_id: Numeric value of the websiteID (required)
        :param WebSiteItem web_site_item: WebSite to update (required)
        :return: list[WebSiteItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_site_id', 'web_site_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_web_site" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'web_site_id' is set
        if ('web_site_id' not in params or
                params['web_site_id'] is None):
            raise ValueError("Missing the required parameter `web_site_id` when calling `update_web_site`")  # noqa: E501
        # verify the required parameter 'web_site_item' is set
        if ('web_site_item' not in params or
                params['web_site_item'] is None):
            raise ValueError("Missing the required parameter `web_site_item` when calling `update_web_site`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'web_site_id' in params:
            path_params['WebSiteID'] = params['web_site_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_site_item' in params:
            body_params = params['web_site_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WebSite/{WebSiteID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebSiteItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_web_transaction(self, web_transaction_id, web_transaction_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebTransaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_transaction(web_transaction_id, web_transaction_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_transaction_id: Numeric value of the webtransactionID (required)
        :param WebTransactionItem web_transaction_item: WebTransaction to update (required)
        :return: list[WebTransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_web_transaction_with_http_info(web_transaction_id, web_transaction_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_web_transaction_with_http_info(web_transaction_id, web_transaction_item, **kwargs)  # noqa: E501
            return data

    def update_web_transaction_with_http_info(self, web_transaction_id, web_transaction_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WebTransaction in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_web_transaction_with_http_info(web_transaction_id, web_transaction_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int web_transaction_id: Numeric value of the webtransactionID (required)
        :param WebTransactionItem web_transaction_item: WebTransaction to update (required)
        :return: list[WebTransactionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['web_transaction_id', 'web_transaction_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_web_transaction" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'web_transaction_id' is set
        if ('web_transaction_id' not in params or
                params['web_transaction_id'] is None):
            raise ValueError("Missing the required parameter `web_transaction_id` when calling `update_web_transaction`")  # noqa: E501
        # verify the required parameter 'web_transaction_item' is set
        if ('web_transaction_item' not in params or
                params['web_transaction_item'] is None):
            raise ValueError("Missing the required parameter `web_transaction_item` when calling `update_web_transaction`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'web_transaction_id' in params:
            path_params['WebTransactionID'] = params['web_transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'web_transaction_item' in params:
            body_params = params['web_transaction_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WebTransaction/{WebTransactionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebTransactionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_workflow(self, workflow_id, workflow_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Workflow in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_workflow(workflow_id, workflow_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_id: Numeric value of the workflowID (required)
        :param WorkflowItem workflow_item: Workflow to update (required)
        :return: list[WorkflowItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_workflow_with_http_info(workflow_id, workflow_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_workflow_with_http_info(workflow_id, workflow_item, **kwargs)  # noqa: E501
            return data

    def update_workflow_with_http_info(self, workflow_id, workflow_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an Workflow in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_workflow_with_http_info(workflow_id, workflow_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_id: Numeric value of the workflowID (required)
        :param WorkflowItem workflow_item: Workflow to update (required)
        :return: list[WorkflowItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['workflow_id', 'workflow_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_workflow" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'workflow_id' is set
        if ('workflow_id' not in params or
                params['workflow_id'] is None):
            raise ValueError("Missing the required parameter `workflow_id` when calling `update_workflow`")  # noqa: E501
        # verify the required parameter 'workflow_item' is set
        if ('workflow_item' not in params or
                params['workflow_item'] is None):
            raise ValueError("Missing the required parameter `workflow_item` when calling `update_workflow`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workflow_id' in params:
            path_params['WorkflowID'] = params['workflow_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'workflow_item' in params:
            body_params = params['workflow_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/Workflow/{WorkflowID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WorkflowItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_workflow_history(self, workflow_history_id, workflow_history_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WorkflowHistory in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_workflow_history(workflow_history_id, workflow_history_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_history_id: Numeric value of the workflowhistoryID (required)
        :param WorkflowHistoryItem workflow_history_item: WorkflowHistory to update (required)
        :return: list[WorkflowHistoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_workflow_history_with_http_info(workflow_history_id, workflow_history_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_workflow_history_with_http_info(workflow_history_id, workflow_history_item, **kwargs)  # noqa: E501
            return data

    def update_workflow_history_with_http_info(self, workflow_history_id, workflow_history_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WorkflowHistory in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_workflow_history_with_http_info(workflow_history_id, workflow_history_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_history_id: Numeric value of the workflowhistoryID (required)
        :param WorkflowHistoryItem workflow_history_item: WorkflowHistory to update (required)
        :return: list[WorkflowHistoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['workflow_history_id', 'workflow_history_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_workflow_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'workflow_history_id' is set
        if ('workflow_history_id' not in params or
                params['workflow_history_id'] is None):
            raise ValueError("Missing the required parameter `workflow_history_id` when calling `update_workflow_history`")  # noqa: E501
        # verify the required parameter 'workflow_history_item' is set
        if ('workflow_history_item' not in params or
                params['workflow_history_item'] is None):
            raise ValueError("Missing the required parameter `workflow_history_item` when calling `update_workflow_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workflow_history_id' in params:
            path_params['WorkflowHistoryID'] = params['workflow_history_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'workflow_history_item' in params:
            body_params = params['workflow_history_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WorkflowHistory/{WorkflowHistoryID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WorkflowHistoryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_workflow_permission(self, workflow_permission_id, workflow_permission_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WorkflowPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_workflow_permission(workflow_permission_id, workflow_permission_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_permission_id: Numeric value of the workflowpermissionID (required)
        :param WorkflowPermissionItem workflow_permission_item: WorkflowPermission to update (required)
        :return: list[WorkflowPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_workflow_permission_with_http_info(workflow_permission_id, workflow_permission_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_workflow_permission_with_http_info(workflow_permission_id, workflow_permission_item, **kwargs)  # noqa: E501
            return data

    def update_workflow_permission_with_http_info(self, workflow_permission_id, workflow_permission_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WorkflowPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_workflow_permission_with_http_info(workflow_permission_id, workflow_permission_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_permission_id: Numeric value of the workflowpermissionID (required)
        :param WorkflowPermissionItem workflow_permission_item: WorkflowPermission to update (required)
        :return: list[WorkflowPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['workflow_permission_id', 'workflow_permission_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_workflow_permission" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'workflow_permission_id' is set
        if ('workflow_permission_id' not in params or
                params['workflow_permission_id'] is None):
            raise ValueError("Missing the required parameter `workflow_permission_id` when calling `update_workflow_permission`")  # noqa: E501
        # verify the required parameter 'workflow_permission_item' is set
        if ('workflow_permission_item' not in params or
                params['workflow_permission_item'] is None):
            raise ValueError("Missing the required parameter `workflow_permission_item` when calling `update_workflow_permission`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workflow_permission_id' in params:
            path_params['WorkflowPermissionID'] = params['workflow_permission_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'workflow_permission_item' in params:
            body_params = params['workflow_permission_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WorkflowPermission/{WorkflowPermissionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WorkflowPermissionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_workflow_step(self, workflow_step_id, workflow_step_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WorkflowStep in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_workflow_step(workflow_step_id, workflow_step_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_step_id: Numeric value of the workflowstepID (required)
        :param WorkflowStepItem workflow_step_item: WorkflowStep to update (required)
        :return: list[WorkflowStepItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_workflow_step_with_http_info(workflow_step_id, workflow_step_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_workflow_step_with_http_info(workflow_step_id, workflow_step_item, **kwargs)  # noqa: E501
            return data

    def update_workflow_step_with_http_info(self, workflow_step_id, workflow_step_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WorkflowStep in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_workflow_step_with_http_info(workflow_step_id, workflow_step_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_step_id: Numeric value of the workflowstepID (required)
        :param WorkflowStepItem workflow_step_item: WorkflowStep to update (required)
        :return: list[WorkflowStepItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['workflow_step_id', 'workflow_step_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_workflow_step" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'workflow_step_id' is set
        if ('workflow_step_id' not in params or
                params['workflow_step_id'] is None):
            raise ValueError("Missing the required parameter `workflow_step_id` when calling `update_workflow_step`")  # noqa: E501
        # verify the required parameter 'workflow_step_item' is set
        if ('workflow_step_item' not in params or
                params['workflow_step_item'] is None):
            raise ValueError("Missing the required parameter `workflow_step_item` when calling `update_workflow_step`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workflow_step_id' in params:
            path_params['WorkflowStepID'] = params['workflow_step_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'workflow_step_item' in params:
            body_params = params['workflow_step_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WorkflowStep/{WorkflowStepID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WorkflowStepItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_workflow_step_permission(self, workflow_step_permission_id, workflow_step_permission_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WorkflowStepPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_workflow_step_permission(workflow_step_permission_id, workflow_step_permission_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_step_permission_id: Numeric value of the workflowsteppermissionID (required)
        :param WorkflowStepPermissionItem workflow_step_permission_item: WorkflowStepPermission to update (required)
        :return: list[WorkflowStepPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_workflow_step_permission_with_http_info(workflow_step_permission_id, workflow_step_permission_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_workflow_step_permission_with_http_info(workflow_step_permission_id, workflow_step_permission_item, **kwargs)  # noqa: E501
            return data

    def update_workflow_step_permission_with_http_info(self, workflow_step_permission_id, workflow_step_permission_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an WorkflowStepPermission in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_workflow_step_permission_with_http_info(workflow_step_permission_id, workflow_step_permission_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int workflow_step_permission_id: Numeric value of the workflowsteppermissionID (required)
        :param WorkflowStepPermissionItem workflow_step_permission_item: WorkflowStepPermission to update (required)
        :return: list[WorkflowStepPermissionItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['workflow_step_permission_id', 'workflow_step_permission_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_workflow_step_permission" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'workflow_step_permission_id' is set
        if ('workflow_step_permission_id' not in params or
                params['workflow_step_permission_id'] is None):
            raise ValueError("Missing the required parameter `workflow_step_permission_id` when calling `update_workflow_step_permission`")  # noqa: E501
        # verify the required parameter 'workflow_step_permission_item' is set
        if ('workflow_step_permission_item' not in params or
                params['workflow_step_permission_item'] is None):
            raise ValueError("Missing the required parameter `workflow_step_permission_item` when calling `update_workflow_step_permission`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'workflow_step_permission_id' in params:
            path_params['WorkflowStepPermissionID'] = params['workflow_step_permission_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'workflow_step_permission_item' in params:
            body_params = params['workflow_step_permission_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/WorkflowStepPermission/{WorkflowStepPermissionID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WorkflowStepPermissionItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_zip_post_code(self, zip_post_code_id, zip_post_code_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ZipPostCode in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_zip_post_code(zip_post_code_id, zip_post_code_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int zip_post_code_id: Numeric value of the zippostcodeID (required)
        :param ZipPostCodeItem zip_post_code_item: ZipPostCode to update (required)
        :return: list[ZipPostCodeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_zip_post_code_with_http_info(zip_post_code_id, zip_post_code_item, **kwargs)  # noqa: E501
        else:
            (data) = self.update_zip_post_code_with_http_info(zip_post_code_id, zip_post_code_item, **kwargs)  # noqa: E501
            return data

    def update_zip_post_code_with_http_info(self, zip_post_code_id, zip_post_code_item, **kwargs):  # noqa: E501
        """  # noqa: E501

        Updates an ZipPostCode in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_zip_post_code_with_http_info(zip_post_code_id, zip_post_code_item, async=True)
        >>> result = thread.get()

        :param async bool
        :param int zip_post_code_id: Numeric value of the zippostcodeID (required)
        :param ZipPostCodeItem zip_post_code_item: ZipPostCode to update (required)
        :return: list[ZipPostCodeItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['zip_post_code_id', 'zip_post_code_item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_zip_post_code" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'zip_post_code_id' is set
        if ('zip_post_code_id' not in params or
                params['zip_post_code_id'] is None):
            raise ValueError("Missing the required parameter `zip_post_code_id` when calling `update_zip_post_code`")  # noqa: E501
        # verify the required parameter 'zip_post_code_item' is set
        if ('zip_post_code_item' not in params or
                params['zip_post_code_item'] is None):
            raise ValueError("Missing the required parameter `zip_post_code_item` when calling `update_zip_post_code`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'zip_post_code_id' in params:
            path_params['ZipPostCodeID'] = params['zip_post_code_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'zip_post_code_item' in params:
            body_params = params['zip_post_code_item']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['UserSecurity']  # noqa: E501

        return self.api_client.call_api(
            'update/ZipPostCode/{ZipPostCodeID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ZipPostCodeItem]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
